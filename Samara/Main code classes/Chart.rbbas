#tag ClassClass Chart	#tag Method, Flags = &h0		Sub addGeometry(geometry as screenGeometry)		  mConverter = geometry		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub calculateXaxisTicks(minValue as double, maxValue as double)		  // The method is passed the lowest and highest data values and must		  // best guesses at increments and label values,		  		  dim i, j, noOfTicks, ratio as integer		  dim lowestTick, currentTick as double		  dim whole, fraction, dataRange, increment, smallIncrement as double		  		  dataRange = maxValue - minValue		  		  // Calculate the increment		  fraction = log(dataRange)/log(10)  // get the log 10 value of the range of the data		  whole = floor(fraction)                           // get just the number to the left of the decimal place		  fraction = fraction - whole           // get the number to the right		  		  if fraction < 0.300 then		    increment = pow(10, whole)/5.0  //eg if range = 14, then whole = 1, fraction=0.146, and incs = 10^1/5 = 2		    smallIncrement = increment /4.0		    		  elseif fraction < 0.600 then		    increment = pow(10, whole)/2   //eg if range = 20, then whole =1, fraction=0.301, and incs =10^1/2 = 5		    smallIncrement = increment /5.0		    		  elseif fraction < 0.840 then		    increment = pow(10, whole)      //eg if range =50, then whole =1, fraction=0.700, and incs =10^1 = 10		    smallIncrement = increment /10.0		    		  else		    increment = pow(10, whole)*2  //eg if range =80, then whole =1, fraction=0.901, and incs =10^1*2 =20		    smallIncrement = increment /10.0		    		  end if		  		  		  // calculate and store the tick mark values		  lowestTick = (floor(minValue/increment) + 1.0) * increment		  noOfTicks =  ceil((maxValue - lowestTick)/increment)		  		  redim mXaxisTicks(noOfTicks)		  		  currentTick = lowestTick		  		  for i = 1 to noOfTicks		    		    mXaxisTicks(i) = currentTick		    currentTick = currentTick + increment		    		  next		  		  // calculate and store the intermediate tick mark values		  lowestTick = (floor(minValue/smallIncrement) + 1.0) * smallIncrement		  noOfTicks =  ceil((maxValue - lowestTick)/smallIncrement)		  		  redim mXaxisSmallTicks(noOfTicks)		  		  currentTick = lowestTick		  		  for i = 1 to noOfTicks		    		    mXaxisSmallTicks(i) = currentTick		    currentTick = currentTick + smallIncrement		    		  next		  		  		exception err		  gHandleException err, "calculateXaxisTicks method of the Chart class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function changeYAxisScale(upwards as boolean, components() as string) As boolean		  // in response to a user input, this method is called to change the scale of the y axis in a given		  // direction ("up" or "down") for given graphs ("x", "y", "vx", etc)		  // it returns true if the graphs actually need to be redrawn, false if no change occurs.		  		  dim i, upperLimit as integer		  dim graph as string		  dim currLimit, change as single		  dim directionSign as integer		  dim altered as boolean = false		  		  if upwards then		    directionSign = 1		  else		    directionSign = -1		  end if		  		  upperLimit = uBound(components)		  		  for i = 0 to upperLimit		    graph = components(i)  // ie x, y, vx etc		    change = mYAxisSteps.value(graph)  // the step eg 5 deg, 250 deg/s		    currLimit = mYAxisLimits.value(graph)		    if upwards then		      mYAxisLimits.value(graph) = currLimit + change  // increase the upper axis value		      altered = true		    else		      if currLimit - change > 0 then  // decrease the max value, but only if there is a step able to be made		        mYAxisLimits.value(graph) = currLimit - change		        altered = true		      end		    end if		  next		  		  return altered		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function constrainWithinGraphFrame(yValueInPixels as integer) As integer		  // checks whether a passed y axis value will fall within the bounds of the graph frame.		  // If not, the values are clipped so that they do.		  		  // NB plotting is based on the origin being at top left so higher graphed values		  // actually have smalller y pixel values.		  		  if yValueInPixels < mHighestGraphAreaPixel then yValueInPixels = mHighestGraphAreaPixel		  if yValueInPixels > mLowestGraphAreaPixel then yValueInPixels = mLowestGraphAreaPixel		  		  return yValueInPixels		  		exception err		  gHandleException err, "constrainWithinGraphFrame method of chart class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function cursorObjects() As group2D		  return mCursorObjects		  		exception err		  gHandleException err, "cursorObjects method of chart class."		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub plot2D(g as graphics, samples() as dataPoint, stimuli() as stimulus, backGrounds() as backGroundImage, resolution as integer)		  // This method is called by the iViewSet class		  // g comes from either a printer or a picture.  If a printer, need to check for resolution and scale fonts and line widths appropriately.		  		  // NB the graphics origin is at top left, so need to 'invert' data to get it displayed the right way up.		  		  dim i, numStimuli, numPoints, numBackgrounds as integer		  dim useQuartz as boolean          // only plot with Quartz if there is a small number of samples.		  dim printing as boolean = false // determine this from the resolution.		  dim plotBackgroundColour, borderColour, stimulusColour, lineColour, maskColour as color		  dim canvasAspectRatio, backgroundAspectRatio, multiplier, transparency as double		  dim drawingWidth, drawingHeight, cornerX, cornerY, canvasWidth, canvasHeight, stimulusWidth, x, y, prevX, prevY as integer		  dim currPic, mask as picture		  		  // g is a graphics object either from a printer or picture		  canvasWidth = g.width		  canvasHeight = g.height		  useQuartz = true // try using quartz all the time for 2D plots as may need some fancy effects with overlapping stimuli		  		  plotBackgroundColour = RGB(236,242,255) // light blue grid		  lineColour = RGB(0,0,100)  // dark blue		  borderColour = &cAAAAAA'RGB(214,227,255) // slightly darker blue than the plotBackgroundColour		  		  // set the size of the area of the graphics in which the plot will be drawn.		  backgroundAspectRatio = mConverter.pixelWidth/mConverter.pixelHeight  // e.g. 800/600 pixels as seen by the subject		  canvasAspectRatio = canvasWidth/canvasHeight     // the dimensions of the printer or canvas graphics		  		  if canvasAspectRatio  >= backgroundAspectRatio then		    drawingHeight = canvasHeight		    drawingWidth = round(drawingHeight * backGroundAspectRatio)		    // so the drawing will be centred within the canvas:		    cornerY = 0		    cornerX = round((canvasWidth - drawingWidth)/2)		  else		    drawingWidth = canvaswidth		    drawingHeight = round(drawingWidth / backGroundAspectRatio)		    // so the drawing will be centred within the canvas:		    cornerX = 0		    cornerY = round((canvasHeight - drawingHeight)/2)		  end if		  		  // assume square pixels, and create a multiplier to scale original pixel values into the smaller or larger canvas		  multiplier = drawingWidth/mConverter.pixelWidth		  		  // any extra space will be filled in with the default background colour if the aspect ratios don't match:		  g.foreColor = gBackgroundColour		  g.fillRect(0, 0, canvasWidth, canvasHeight)		  		  g.foreColor = borderColour		  g.drawRect(0, 0, canvasWidth, canvasHeight)		  		  // drawBackground images if they exist:		  numBackgrounds = uBound(backGrounds)		  		  if numBackgrounds < 0  then		    		    // no background image defined, so just fill in a default solid colour		    g.foreColor = plotBackgroundColour		    g.fillRect(cornerX, cornerY, drawingWidth, drawingHeight)		    		  else		    		    // there is at least one background image, so draw the first one with full opacity.		    // need to define a full mask here, as it may previously have been created with a different value if the image has already been shown		    currPic = backGrounds(0).pic		    mask = newPicture(currPic.width, currPic.height, 32)		    mask.graphics.foreColor = &c000000		    mask.graphics.fillRect(0, 0, mask.width, mask.height)		    currPic.mask.graphics.drawPicture(mask,0,0)		    g.drawPicture(currPic, cornerX, cornerY, drawingWidth, drawingHeight, 0, 0, currPic.width, currPic.height)		    		  end if		  		  if numBackgrounds > 0  then  // any subsequent backgrounds get overlaid with some transparency		    		    // create a mask		    transparency= 1.0/(numBackgrounds+1)		    mask = newPicture(backGrounds(0).pic.width, backGrounds(0).pic.height, 32)		    maskColour = RGB(255-(transparency*255), 255-(transparency*255), 255-(transparency*255))		    mask.graphics.foreColor = maskColour		    mask.graphics.fillRect(0, 0, mask.width, mask.height)		    		    // draw remaining backgrounds		    for i = 1 to numBackgrounds		      currPic = backGrounds(i).pic		      		      if currPic <> nil then		        		        currPic.mask.graphics.drawPicture(mask,0,0)		        g.drawPicture(currPic, cornerX, cornerY, drawingWidth, drawingHeight, 0, 0, currPic.width, currPic.height)		        		      end if		      		    next		    		  end if		  		  		  		  // draw a border to delineate when images have the same backgroundcolour as the canvas		  g.foreColor = borderColour		  g.drawRect(cornerX, cornerY, drawingWidth, drawingHeight)		  		  // draw stimuli		  g.penHeight = 1		  g.penWidth = 1		  stimulusWidth = round(16 *multiplier)		  		  numStimuli = uBound(stimuli)		  		  for i = 0 to numStimuli		    		    // determine the colour of this particular stimulus		    if stimuli(i).hasKey("colour") and stimuli(i).value("colour") <> nil then		      stimulusColour = stimuli(i).value("colour")		    else		      stimulusColour = RGB(255,78,81)  // red		    end if		    		    // create the stimulus drawing		    g.foreColor = stimulusColour		    x = round(mConverter.convertAngleToPixels(stimuli(i).value("x"), TRUE) * multiplier)+cornerX		    y = round(mConverter.convertAngleToPixels(stimuli(i).value("y"),FALSE) * multiplier)+cornerY		    g.drawOval x-stimulusWidth/2, y-stimulusWidth/2, stimulusWidth, stimulusWidth		    		  next i		  		  // plot the data.		  g.foreColor = &cFF0080 'lineColour		  		  // the first line will be drawn connecting to the 0th sample to itself:		  prevX = round(mConverter.convertAngleToPixels(samples(0).x, TRUE) * multiplier)+cornerX		  prevY = round(mConverter.convertAngleToPixels(samples(0).y,FALSE) * multiplier)+cornerY		  		  numPoints = uBound(samples)		  		  for i = 1 to numPoints		    		    x = round(mConverter.convertAngleToPixels(samples(i).x, TRUE) * multiplier)+cornerX		    y = round(mConverter.convertAngleToPixels(samples(i).y,FALSE) * multiplier)+cornerY		    if samples(i).valid and samples(i-1).valid then g.drawLine prevX, prevY, x, y		    prevX = x		    prevY = y		    		  next i		  		exception err		  gHandleException err, "plot2D method of chart class."		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function plotCrossHair(mouseX as integer, mouseY as integer) As group2D		  // The parameters passed in should be the mouse coordinates relative to the canvas.		  		  dim i, j as integer		  dim time as double		  dim line as curveShape		  dim crossHair as new group2D		  		  'gLog "plotCrossHair method of chart class."		  		  if mouseX > mLeftPadding and mouseX < mLeftPadding + mPlotWidth then		    		    for j = 0 to mNumberOfPlots		      line = new curveShape		      line.borderColor = &cAAAAAA		      line.x = mouseX		      line.y = j*(mChartHeight + mSpaceBetweenGraphs)  + mTopSpace // the top of the line is at the top of the plot		      line.x2 = mouseX		      line.y2 = mPlotHeight + j*(mChartHeight + mSpaceBetweenGraphs)   + mTopSpace  // the bottom of the line is at the bottom of the plot		      crossHair.append line		    next		    		  end if		  		  // calculate the time value corresponding to the mouse position:		  time = (mouseX - mLeftPadding)/mXFactor + mMinTime		  // NB calculating the y value will be trickier, as the constants required for that can be different for each plot.		  // Should store them in arrays, and access the apprpriate value depending on which plot the cursor is in.		  		  'gLog "Mouse x: " + str(mouseX) + " = " + str(time) + " s"		  		  return crossHair		  		exception err		  gHandleException err, "plotCrossHair method of chart class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub plotCursors(cursors() as cursor)		  // The chart is passed an array of cursors and calculates the vector objects needed to display them.		  // This method relies on the plotData method having already been called for the current view of the data		  // so that the properties of this object required for the calculations have been populated with the correct values.		  		  dim i, j as integer		  dim x as single		  dim line as curveShape		  		  'gLog "plotCursors method of chart class."		  		  mCursorObjects = new group2D		  		  for i = uBound(cursors) downTo 0  // go backwards so that the cursors are drawn in the correct overlapping order		    // the x coordinate is constant for all instances of this cursor		    x = (cursors(i).t-mMinTime) * mXFactor + mLeftPadding		    		    for j = 0 to mNumberOfPlots		      line = new curveShape		      line.borderColor = cursors(i).colour		      line.x = x		      line.y = j*(mChartHeight + mSpaceBetweenGraphs)  + mTopSpace // the top of the line is at the top of the plot		      line.x2 = x		      line.y2 = mPlotHeight + j*(mChartHeight + mSpaceBetweenGraphs)   + mTopSpace  // the bottom of the line is at the bottom of the plot		      mCursorObjects.append line		    next		    		  next		  		exception err		  gHandleException err, "plotCursors method of chart class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub plotLineTraces(g as graphics, samples() as dataPoint, stimuli() as stimulus, component() as string, resolution as integer, movementGain as double = 1.00, responses() as response, analyse2D as boolean = FALSE)		  // This method is called by the iViewSet class		  // The component array (eg 'x', 'y', etc) indicates which data components are to be plotted and determines the number of graphs.		  // g comes from either a printer or a picture.  If a printer, will need to check for resolution and scale fonts and line widths appropriately.		  // Will also need to scale the constants used to calculate the padding and chartWidth values.		  		  // chartWidth and chartHeight indicate the pixel bounds within which the entire chart(s) (including labels and axes) must fit.		  // Within this method, we then calculate plotWidth and plotHeight which is the subset of that area in which the data resides.		  // To plot a point in this data space, calculate its proportional location within the plot, (using mXFactor and yFactor)		  // and then add leftPadding pixels to the  x coordinate, and bottomPadding pixels to the y coordinate.		  // ie chartWidth = leftPadding + plotWidth		  // chartHeight = bottomPadding + plotHeight		  // NB the graphics origin is at top left, so need to 'invert' data to get it displayed the right way up.		  // the parameter movementGain is needed only for arm movement trials where the feedback of the subject's movement may have been manipulated.		  // maybe also useful for saccadic adaptation tasks?		  // This affects the intended size of their movement and so we need to display a 'virtual' target representation or else they will falsely appear to be		  // inaccurate wrt to the actual target location.		  		  dim i, j, overlay, upperLimit, chartWidth, canvasWidth, canvasHeight, noOfSamples as integer		  dim bottomPadding as integer		  dim x, y, x2, y2, numberOfTickMarks, numberOfSmallTickMarks as integer		  dim minValue, maxValue as double = 0		  dim timeRange, valueRange, maxTime, yFactor, markValue, tickNumber as double		  dim currSampleValue, prevSampleValue as double		  dim currSample, prevSample as dataPoint		  dim t1, t2, t3, t4, value1, value2, gainAppliedValue as double		  dim currentComponent, overlayComponents(3) as string		  dim label as stringShape		  dim frame as rectShape		  dim sampleCircle as ovalShape		  dim zeroLine, tickMark as curveShape		  dim plotOffsetMessages as boolean = TRUE // whether we display the times of offset messages as a check for stimulus timings		  dim showSamples as boolean = FALSE		  dim useQuartz as boolean = FALSE // only plot with Quartz if there is a small number of samples.		  dim printing as boolean = FALSE // determine this from the resolution		  dim printScaleFactor as double // scale certain things up for high res printing		  dim scaledTextSize as double = 12.0		  dim plotBackgroundColour, borderColour, stimulusColour, adaptedStimulusColour, lineColour, gridLineColour, overlayColours(3) as color		  		  'gLog "plotData method of chart class."		  'gLog "Resolution : " + str(resolution)		  		  // The following variables have been made properties so that they remain accessible later for updating cursor positions		  // without having to redraw the whole graph: mMinTime, mXFactor,  mLeftPadding, mChartHeight, mSpaceBetweenGraphs, mPlotHeight, mTopSpace		  		  // g is a graphics object either from a printer or picture		  canvasWidth = g.width		  canvasHeight = g.height		  g.foreColor = gBackgroundColour		  g.fillRect(0, 0, canvasWidth, canvasHeight)		  noOfSamples = uBound(samples)		  if noOfSamples < 10000 then		    useQuartz = TRUE  // ie use pretty Quartz plotting only when not plotting very many points (~8 s of 1250 Hz data).		  end if		  		  // is this for printing or screen?		  printScaleFactor = resolution / 72		  'gLog "printScaleFactor : " + str(printScaleFactor)		  if printScaleFactor > 1.0 then		    printing = true		    scaledTextSize = 12 * printScaleFactor * 0.75  // a proportional scaling seems too large (eg at 300 dpi, 12 pts would otherwise scale to 50 pt)		    plotBackgroundColour = &cFFFFFF  // don't print a background colour		    'stimulusColour = &c888888  // grey lines		    'adaptedStimulusColour = &c555555  // lighter grey		    lineColour = &c000000		    borderColour = &c000000		    gridLineColour = &cD3D3D3		    		  else		    		    if analyse2D then		      plotBackgroundColour = &cFFF5D7 // cream grid		      borderColour = &cE4D9B7 // slightly darker than the plotBackgroundColour		      		    else		      plotBackgroundColour = RGB(236,242,255) // light blue grid		      borderColour = &cBACBEF // slightly darker blue than the plotBackgroundColour RGB(214,227,255)		    end if		    		    adaptedStimulusColour = RGB(150,78,81)		    lineColour = RGB(0,0,100)  // dark blue		    gridLineColour = &cFFFFFF		    		  end if		  'gLog "scaledTextSize : " + str(scaledTextSize)		  		  		  // how many graphs need to be drawn?		  mNumberOfPlots = uBound(component)		  		  // set the size of the area of the canvas in which each graph will be drawn.		  // a chart is the space taken by an entire graph, including labels etc.		  // a plot is the data-containing rectangle  within the greater chart area.		  bottomPadding = (20 * printScaleFactor)		  chartWidth = canvasWidth - (20 * printScaleFactor)		  mTopSpace = 10 * printScaleFactor		  mSpaceBetweenGraphs = 10 * printScaleFactor		  mLeftPadding = 40 * printScaleFactor		  mChartHeight = (canvasHeight - (mTopSpace))/(mNumberOfPlots+1) - (mSpaceBetweenGraphs)		  		  // need to find the range of time values to be plottted (common to all plots).		  mMinTime = samples(0).t		  if mMinTime <> mMinTime then gLog "NaN in sample 0"		  maxTime = samples(uBound(samples)).t		  if mMinTime <> mMinTime then gLog "NaN in last sample"		  // come up with some reasonable values on the x axis to have tick marks (stored in mXaxisTicks)		  self.calculateXaxisTicks(mMinTime, maxTime)		  		  // calculate the range of time values.		  timeRange = maxTime - mMinTime		  		  		  		  // divide up the allotted pixel area into the plot area plus surroundings (including labels and axes)		  mPlotWidth = chartWidth - mLeftPadding		  mPlotHeight = mChartHeight - bottomPadding		  mXFactor = mPlotWidth / timeRange		  		  // if a small data range is being displayed, show individual samples		  if noOfSamples < mPlotWidth/6.0 then		    showSamples = TRUE		    sampleCircle = new ovalShape		    sampleCircle.width = 5.0 * printScaleFactor		    sampleCircle.height = sampleCircle.width		    sampleCircle.fillColor = lineColour		    'sampleCircle.border = 25		    'sampleCircle.borderColor = &C000000		    sampleCircle.Fill = 20		  end if		  		  // now do all those things that need to be done separately for each graph.  Create a graph for each component		  // (eg x, y, xVel) listed in the passed component array		  		  for j = 0 to mNumberOfPlots		    currentComponent = component(j)		    if not useQuartz then g.useOldRenderer = true  // needs to be reset each time through the loop as Quartz is always switched on for drawing the text labels		    		    mHighestGraphAreaPixel = j*(mChartHeight + mSpaceBetweenGraphs) + mTopSpace		    mLowestGraphAreaPixel = j*(mChartHeight + mSpaceBetweenGraphs) + mPlotHeight + mTopSpace		    		    // NB have for the time being disabled automatic checking of value ranges and opted for fixed ranges.		    // these values are set in the chart constructor and thereafter can be altered by the user		    maxValue = mYAxisLimits.value(currentComponent)		    // 2D or 3D velocities are inherently absolute values and so should have a minumum value of zero:		    if component(j) = "v" or component(j) = "a3" then		      minValue = 0		    else  // have a min value the opposite sign of the max value:		      minValue = mYAxisLimits.value(currentComponent) * -1.0		    end if		    		    // the y scaling factor needs to be calculated separately for each graph:		    valueRange = maxValue - minValue		    yFactor = mPlotHeight / valueRange		    		    // make a frame for the graph		    frame = new rectShape		    frame.width = mPlotWidth		    frame.height = mPlotHeight		    frame.x = mPlotWidth/2 + mLeftPadding		    frame.y = mPlotHeight/2  + j*(mChartHeight + mSpaceBetweenGraphs) + mTopSpace		    frame.border = 0		    frame.fillColor = plotBackgroundColour		    frame.fill = 100		    g.drawObject frame		    		    // add some tickMarks to the y axis		    numberOfTickMarks = (maxValue - minValue)/mYAxisSteps.value(currentComponent)		    tickMark = new curveShape		    		    for tickNumber = 0 to numberOfTickMarks // NB tickNumber is real and not integer, as otherwise multiplying by it would force the result to be integer		      markValue = tickNumber * mYAxisSteps.value(currentComponent) + minValue		      tickMark.Y = mPlotHeight - ((markValue - minValue) * yFactor) + j*(mChartHeight + mSpaceBetweenGraphs) + mTopSpace		      tickMark.Y2 = tickMark.Y		      		      // draw tick		      tickMark.X = mLeftPadding - (5 * printScaleFactor)		      tickMark.X2 = mLeftPadding		      tickMark.borderColor = borderColour		      g.drawObject tickMark		      		      // draw grid line		      tickMark.X = mLeftPadding		      tickMark.X2 = mLeftPadding + mPlotWidth		      tickMark.borderColor = gridLineColour		      g.drawObject tickMark		      		    next		    		    		    		    // create drawings of subject responses, but only in the top panel		    if j = 0 then		      upperLimit = uBound(responses)		      		      for i = 0 to upperLimit		        // get the time axis value for the start of the response, in pixels.		        t1 = responses(i).time		        t1 = truncateStimulusValueWithinGraphFrame(t1,mMinTime, maxTime, mXFactor, mLeftPadding, mPlotWidth)		        // draw a circle indicating a response was made		        g.foreColor = &cFF8000		        g.fillOval(t1, frame.height*0.1, scaledTextSize*1.25, scaledTextSize*1.25)		        // draw the value of the response		        g.foreColor = plotBackgroundColour		        g.bold = TRUE		        g.drawString(left(responses(i).value,1), t1+scaledTextSize*0.4, frame.height*0.1+scaledTextSize)		        g.bold = FALSE		      next		      		    end if		    		    // create drawings of stimuli, but not for velocity or acceleration graphs, where stimuli are undefined		    if inStr(currentComponent, "v") = 0 and  inStr(currentComponent, "a") = 0 then		      upperLimit = uBound(stimuli)  // if there are no stimuli for this set, then this will be - 1 and the following loop will not execute		      		      g.penHeight = 2		      g.penWidth = 2		      		      for i = 0 to upperLimit		        // get the time axis value for the start of the stimulus, in pixels.  Truncate any stimulus which might extend outside of the time window.		        t1 = stimuli(i).value("onsetTime")		        t1 = truncateStimulusValueWithinGraphFrame(t1,mMinTime, maxTime, mXFactor, mLeftPadding, mPlotWidth)		        		        // get the time axis value for the end of the stimulus, in pixels.  Truncate any stimulus which might extend outside of the time window.		        t2 = stimuli(i).value("offsetTime")		        t2 = truncateStimulusValueWithinGraphFrame(t2,mMinTime, maxTime, mXFactor, mLeftPadding, mPlotWidth)		        		        // get the time axis value for the point in the stimulus where the connecting line will be drawn to:		        if stimuli(i).value("delay") > 0.0 then		          t3 = stimuli(i).value("onsetTime") + stimuli(i).value("delay") // a delay, so draw the connecting line to the end of the delay period		        else		          t3 = stimuli(i).value("onsetTime")  // connect to the time at which the target appeared (i.e. gap, standard, or overlap target)		        end if		        t3 = truncateStimulusValueWithinGraphFrame(t3,mMinTime, maxTime, mXFactor, mLeftPadding, mPlotWidth) // Truncate if needed:		        		        // get the time axis value for the stimulus offset message (if it exists), in pixels.		        if stimuli(i).hasKey("offsetMsgTime") then		          plotOffsetMessages = true		          t4 = stimuli(i).value("offsetMsgTime")		          t4 = truncateStimulusValueWithinGraphFrame(t4,mMinTime, maxTime, mXFactor, mLeftPadding, mPlotWidth)		          // ideally we shouldn't display the offset message time if the truncation procedure would put it at the wrong time, but for the moment, ignore this		        else		          plotOffsetMessages = false		        end if		        		        // get the component value (eg x or y)		        value1 = mPlotHeight - ((stimuli(i).value(currentComponent) - minValue) * yFactor) + j*(mChartHeight + mSpaceBetweenGraphs) + mTopSpace		        value1 = constrainWithinGraphFrame(value1)  // truncate it within the graphed area		        if movementGain <> 1.0 then		          gainAppliedValue = constrainWithinGraphFrame(mPlotHeight - ((stimuli(i).value(currentComponent)/movementGain - minValue) * yFactor) + j*(mChartHeight + mSpaceBetweenGraphs) + mTopSpace)		          g.foreColor = adaptedStimulusColour // to distinguish from real stimuli		          g.drawLine t1, gainAppliedValue, t2, gainAppliedValue		        end if		        		        // determine the colour of this particular stimulus		        if stimuli(i).hasKey("colour") and stimuli(i).value("colour") <> nil then		          stimulusColour = stimuli(i).value("colour")		        else		          stimulusColour = RGB(255,78,81)  // red		        end if		        		        // highlight the stimulus line if required		        if self.displayHighlightedStimulus then		          if stimuli(i).highlighted then		            g.penHeight = 12		            g.foreColor = highlightColor()		            g.drawLine t1, value1-5, t2, value1-5		            g.penHeight = 2		          end if		        end if		        		        // draw the stimulus itself		        g.foreColor = stimulusColour		        g.drawLine t1, value1, t2, value1		        		        // draw the offset message if required		        if plotOffsetMessages then		          g.foreColor = lineColour  // black		          g.drawLine(t4,value1-1, t4,value1+1)		        end if		        		        // create the link to the previous stimulus		        if not stimuli(i).disconnected then  // for some stimuli, displaying a connecting line is confusing, so it can be disabled in the <TGT> message.		          if i > 0  then // the first stimulus can't be linked to any before it		            y2 = mPlotHeight - ((stimuli(i-1).value(currentComponent) - minValue) * yFactor) + j*(mChartHeight + mSpaceBetweenGraphs) + mTopSpace		            y2 = constrainWithinGraphFrame(y2)  // truncate it within the graphed area		            // draw the line, taking into account any gap/overlap value		            g.foreColor = stimulusColour		            g.drawLine t3, value1, t3, y2		          end		        end if		        		      next i		    end if		    		    // now create a plotline for each data sample, scaling it within the data range and the size of plot.		    upperLimit = uBound(samples)		    		    g.penHeight = 1		    g.penWidth = 1		    		    // for MoVE data only, the vx and ax graphs are special cases where multiple data series are plotted on one graph:		    if sourceOfData = "MoVE" and (currentComponent = "vx" or currentComponent = "ax") then		      if currentComponent = "vx" then		        overlayComponents(0) = "vx"		        overlayComponents(1) = "vy"		        overlayComponents(2) = "vz"		        overlayComponents(3) = "v"		      else		        overlayComponents(0) = "ax"		        overlayComponents(1) = "ay"		        overlayComponents(2) = "az"		        overlayComponents(3) = "a3"		      end if		      		      overlayColours(0) = &cFF0000		      overlayColours(1) = &c00FF00		      overlayColours(2) = &c0000FF		      overlayColours(3) = &c000000		      		      for overlay = 0 to 3		        g.foreColor = overlayColours(overlay)  // blue for data lines		        		        for i = 1 to upperLimit		          		          // if the current or previous sample is invalid, don't draw a line or there will be spikes in the data.		          // Similarly, sample(i-1) may be valid yet not itself have valid velocity data (-9999) as the sample(i-2) may have been invalid		          currSample = samples(i)		          prevSample = samples(i-1)		          		          if currSample.valid and prevSample.valid then		            		            prevSampleValue = prevSample.getDataValue(overlayComponents(overlay))		            currSampleValue = currSample.getDataValue(overlayComponents(overlay))		            		            if prevSampleValue <> -9999 and currSampleValue <> -9999 then		              		              // give the line start coordinates from the previous valid sample		              x = (prevSample.t - mMinTime) * mXFactor + mLeftPadding		              y = mPlotHeight - ((prevSampleValue - minValue) * yFactor) + j*(mChartHeight + mSpaceBetweenGraphs) + mTopSpace		              y = constrainWithinGraphFrame(y)  // truncate it within the graphed area		              		              // give it end coordinates from the current sample		              x2 = (currSample.t - mMinTime) * mXFactor + mLeftPadding		              y2 = mPlotHeight - ((currSampleValue - minValue) * yFactor) + j*(mChartHeight + mSpaceBetweenGraphs) + mTopSpace		              y2 = constrainWithinGraphFrame(y2)  // truncate it within the graphed area		              		              // draw it, but as a way of decreasing the number of samples drawn unnecessarily, don't draw any lines which, because of the data density,		              // won't actually appear to go anywhere beyond a single pixel.		              if x <> x2 or y <> y2 then		                g.drawLine x, y, x2, y2		              end if		            end if		          end if		          		        next i		      next overlay		      		    else		      		      g.foreColor = lineColour  // blue for data lines		      		      for i = 1 to upperLimit		        		        // if the current or previous sample is invalid, don't draw a line or there will be spikes in the data.		        // Similarly, sample(i-1) may be valid yet not itself have valid velocity data (-9999) as the sample(i-2) may have been invalid		        currSample = samples(i)		        prevSample = samples(i-1)		        		        if currSample.valid and prevSample.valid then		          		          prevSampleValue = prevSample.getDataValue(currentComponent)		          currSampleValue = currSample.getDataValue(currentComponent)		          		          if prevSampleValue <> -9999 and currSampleValue <> -9999 and currSampleValue < maxValue and  currSampleValue > minValue then		            		            // give the line start coordinates from the previous valid sample		            x = (prevSample.t - mMinTime) * mXFactor + mLeftPadding		            y = mPlotHeight - ((prevSampleValue - minValue) * yFactor) + j*(mChartHeight + mSpaceBetweenGraphs) + mTopSpace		            y = constrainWithinGraphFrame(y)  // truncate it within the graphed area		            		            // give it end coordinates from the current sample		            x2 = (currSample.t - mMinTime) * mXFactor + mLeftPadding		            y2 = mPlotHeight - ((currSampleValue - minValue) * yFactor) + j*(mChartHeight + mSpaceBetweenGraphs) + mTopSpace		            y2 = constrainWithinGraphFrame(y2)  // truncate it within the graphed area		            		            // draw it, but as a way of decreasing the number of samples drawn unnecessarily, don't draw any lines which, because of the data density,		            // won't actually appear to go anywhere beyond a single pixel (x and y are integers).		            if x <> x2 or y <> y2 then		              g.drawLine x, y, x2, y2		              		              if showSamples then		                sampleCircle.X = x		                sampleCircle.Y = y		                g.drawObject sampleCircle		              end if		              		            end if		          end if		        end if		        		      next i		      		    end if		    		    g.useOldRenderer = FALSE // regardless of whether Quartz is being used for plotting, turn it on for text purposes		    		    // add tickMarks to the x axis		    numberOfTickMarks = uBound(mXaxisTicks)		    tickMark.Y = mPlotHeight + j*(mChartHeight + mSpaceBetweenGraphs) + mTopSpace		    tickMark.Y2 = tickMark.Y + (11 * printScaleFactor)		    tickMark.borderColor = borderColour		    		    label = new stringShape		    label.textFont = "Helvetica"		    label.TextSize = scaledTextSize		    label.Y = tickMark.Y2 + (13 * printScaleFactor)		    		    for tickNumber = 1 to numberOfTickMarks // NB tickNumber is real and not integer, as otherwise multiplying by it would force the result to be integer		      		      markValue = mXaxisTicks(tickNumber)		      tickMark.X = (markValue - mMinTime) * mXFactor + mLeftPadding		      tickMark.X2 = tickMark.X		      		      g.drawObject tickMark		      		      if j = mNumberOfPlots then  // only for the bottom plot, add numeric values to the tick marks		        label.Text = str(markValue) + " s"		        label.X = tickMark.X		        g.drawObject label		      end if		      		    next		    		    // now draw small intermediate tick marks		    numberOfSmallTickMarks = uBound(mXaxisSmallTicks)		    tickMark.Y2 = tickMark.Y + (5 * printScaleFactor)		    		    for tickNumber = 1 to numberOfSmallTickMarks // NB tickNumber is real and not integer, as otherwise multiplying by it would force the result to be integer		      		      markValue = mXaxisSmallTicks(tickNumber)		      tickMark.X = (markValue - mMinTime) * mXFactor + mLeftPadding		      tickMark.X2 = tickMark.X		      		      g.drawObject tickMark		      		    next		    		    		    // add min and max values to the time axis		    if j = mNumberOfPlots then  // only for the last plot		      		      label.TextSize = scaledTextSize*11.0/12.0		      label.Rotation = -1.571		      		      // minTime		      label.Text = format(mMinTime, "-###.00")		      label.x = mLeftPadding + (4 * printScaleFactor)		      label.y = mPlotHeight + (15 * printScaleFactor) + j*(mChartHeight + mSpaceBetweenGraphs) + mTopSpace		      g.drawObject label		      		      // maxTime		      label.Text = format(maxTime, "-###.00")		      label.x = mPlotWidth + mLeftPadding + (8 * printScaleFactor)		      label.y = mPlotHeight + (15 * printScaleFactor) + j*(mChartHeight + mSpaceBetweenGraphs) + mTopSpace		      g.drawObject label		      		    end if		    		    		    // make some value labels for the y axis		    label.TextSize = scaledTextSize		    label.Rotation = 0.0		    for i = 0 to 1		      		      select case i		        		      case 0  // maxValue		        label.Text = format(maxValue,mYAxisFormatString) // the mYAxisFormatString changes depending on eye or arm data (latter needs 1 dp)		        label.x = 20 * printScaleFactor		        // NB to get accurate placement of these, we need to calculate the stringHeight in the graphics class.  Currently just bump them by a fixed number of pixels (eg 5)		        label.y = mPlotHeight - ((maxValue - minValue) * yFactor) + j*(mChartHeight + mSpaceBetweenGraphs) + (5 * printScaleFactor) + mTopSpace		        		      case 1  // minValue		        label.Text = format(minValue, mYAxisFormatString)		        label.x = 20 * printScaleFactor		        label.y = mPlotHeight  + j*(mChartHeight + mSpaceBetweenGraphs) + (5 * printScaleFactor) + mTopSpace		        		      end select		      		      g.drawObject label		    next i		    		    		    // make a text label for the y axis		    label.TextSize = scaledTextSize		    label.bold = true		    label.Text = component(j)		    label.x = 20 * printScaleFactor		    label.y = mPlotHeight/2 + j*(mChartHeight + mSpaceBetweenGraphs) + mTopSpace		    'label.Rotation = -1.571		    g.drawObject label		    		    // redraw the earlier-created frame for the graph, just as an outline		    frame.border = 100		    frame.BorderWidth = 1		    frame.borderColor = borderColour		    frame.fill = 0		    g.drawObject frame		    		  next j		  		  '// for debugging purposes, draw a small circle of a random colour which indicates each time full re-drawing occurs.		  'g.foreColor = RGB(app.rand.inrange(0, 255), app.rand.inrange(0, 255), app.rand.inrange(0, 255))		  'g.fillOval g.width-10, 0, 10, 10		  		  'gLog "exiting plotData method of chart class."		  		  		exception err		  gHandleException err, "plotLineTraces method of chart class."		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function truncateStimulusValueWithinGraphFrame(testvalue as double, minValue as double, maxValue as double, scaleFactor as double, padding as integer, plotSize as integer) As integer		  // checks whether a passed stimulus value will fall within the bounds of the graph frame.		  // If not, the values are clipped so that they do.		  		  // Times are passed in as times and returned as pixels		  		  dim temp as double		  		  if testvalue < minValue  then		    temp = 0  + padding  // truncate it to the left/top		  elseif testvalue > maxValue then		    temp = plotSize  + padding  // truncate it to the  right/bottom		  else		    temp = (testvalue-minValue) * scaleFactor  + padding // plot it somewhere in the middle		  end if		  		  return temp  // now in pixels		  		exception err		  gHandleException err, "truncateStimulusValueWithinGraphFrame method of chart class."		  		End Function	#tag EndMethod	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mDisplayHighlightedStimulus			End Get		#tag EndGetter		#tag Setter			Set			  mDisplayHighlightedStimulus = value			End Set		#tag EndSetter		displayHighlightedStimulus As boolean	#tag EndComputedProperty	#tag Property, Flags = &h1		Protected mChartHeight As integer	#tag EndProperty	#tag Property, Flags = &h1		Protected mChartObjects As group2D	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Holds the screen dimensions, eye-screen distance etc for eye tracking pixel>angle calculations		#tag EndNote		Protected mConverter As screenGeometry	#tag EndProperty	#tag Property, Flags = &h1		Protected mCursorObjects As group2D	#tag EndProperty	#tag Property, Flags = &h1		Protected mDisplayHighlightedStimulus As boolean = FALSE	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			Allows the determination of whether a y-axis value will fall inside or outside the frame of the current graph.			Changes dynamically during the plotData method		#tag EndNote		mHighestGraphAreaPixel As Integer	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			The number of pixels to left of each graph frame, needed for y-axis labels etc.		#tag EndNote		Protected mLeftPadding As integer	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			Allows the determination of whether a y-axis value will fall inside or outside the frame of the current graph.		#tag EndNote		mLowestGraphAreaPixel As Integer	#tag EndProperty	#tag Property, Flags = &h1		Protected mMinTime As single	#tag EndProperty	#tag Property, Flags = &h1		Protected mNumberOfPlots As Integer	#tag EndProperty	#tag Property, Flags = &h1		Protected mPlotHeight As Integer	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Width of each plot, in pixels, set in the plotData method		#tag EndNote		Protected mPlotWidth As integer	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Value = "iView" or "MoVE"			This property allows the data to know where it was imported from so that source-specific things can be done when needed.			Set by the importing thread to the iViewSet which cascades to here.		#tag EndNote		Protected mSourceOfData As string	#tag EndProperty	#tag Property, Flags = &h1		Protected mSpaceBetweenGraphs As integer	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			The amount of space between the top of the canvas and the top edge of the first graph.		#tag EndNote		mTopSpace As Integer	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			The auto-calculated positions of intermediate tick marks on the x axis.			One-based. See calculateXaxisTicks		#tag EndNote		Protected mXaxisSmallTicks() As double	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			The auto-calculated positions of tick marks on the x axis.			One-based. See calculateXaxisTicks		#tag EndNote		Protected mXaxisTicks() As double	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			= plotWidth / timeRange		#tag EndNote		Protected mXFactor As double	#tag EndProperty	#tag Property, Flags = &h1		Protected mYAxisFormatString As string	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Lists default y axis limits.			Set in the sourceOfData setter method to values appropriate for either arm or eye data.		#tag EndNote		Protected mYAxisLimits As dictionary	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Lists how much the y axis changes each time the user wants to change the axis scale.			Set in the sourceOfData setter method to values appropriate for either arm or eye data.		#tag EndNote		Protected mYAxisSteps As dictionary	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Note			Value = "iView" or "MoVE"			This property allows the data to know where it was imported from so that source-specific things can be done when needed.			Set by the importing thread to the iViewSet which cascades to here.		#tag EndNote		#tag Getter			Get			  return mSourceOfData			End Get		#tag EndGetter		#tag Setter			Set			  mSourceOfData = value			  			  select case value			    			  case "iView"			    // sets initial values for axis limits optimised for eye data			    mYAxisLimits = new dictionary			    mYAxisLimits.value("x") = 20			    mYAxisLimits.value("leftx") = 20			    mYAxisLimits.value("rightx") = 20			    mYAxisLimits.value("y") = 20			    mYAxisLimits.value("lefty") = 20			    mYAxisLimits.value("righty") = 20			    mYAxisLimits.value("vx") = 600			    mYAxisLimits.value("leftvx") = 600			    mYAxisLimits.value("rightvx") = 600			    mYAxisLimits.value("vy") = 600			    mYAxisLimits.value("leftvy") = 600			    mYAxisLimits.value("rightvy") = 600			    			    mYAxisLimits.value("v") = 600			    mYAxisLimits.value("leftv") = 600			    mYAxisLimits.value("rightvv") = 600			    			    			    // sets initial values for axis scale changes			    mYAxisSteps = new dictionary			    mYAxisSteps.value("x") = 5			    mYAxisSteps.value("leftx") = 5			    mYAxisSteps.value("rightx") = 5			    mYAxisSteps.value("y") = 5			    mYAxisSteps.value("lefty") = 5			    mYAxisSteps.value("righty") = 5			    mYAxisSteps.value("vx") = 200			    mYAxisSteps.value("leftvx") = 200			    mYAxisSteps.value("rightvx") = 200			    mYAxisSteps.value("vy") = 200			    mYAxisSteps.value("leftvy") = 200			    mYAxisSteps.value("rightvy") = 200			    			    mYAxisSteps.value("v") = 200			    mYAxisSteps.value("leftv") = 200			    mYAxisSteps.value("rightv") = 200			    			    // Set appropriate format string for the y axis labels (eye values are large so have no decimal places)			    mYAxisFormatString = "-######"			    			  case "MoVE"			    // sets initial values for axis limits optimised for arm data			    mYAxisLimits = new dictionary			    mYAxisLimits.value("x") = 0.22000			    mYAxisLimits.value("y") = 0.22000			    mYAxisLimits.value("z") = 0.22000			    mYAxisLimits.value("v") = 1.5000			    mYAxisLimits.value("vx") = 1.5000			    mYAxisLimits.value("a3") = 10.000			    mYAxisLimits.value("ax") = 10.000			    			    // sets initial values for axis scale changes			    mYAxisSteps = new dictionary			    mYAxisSteps.value("x") = 0.04000			    mYAxisSteps.value("y") = 0.04000			    mYAxisSteps.value("z") = 0.04000			    mYAxisSteps.value("v") = 0.2500			    mYAxisSteps.value("vx") = 0.2500			    mYAxisSteps.value("a3") = 2.5000			    mYAxisSteps.value("ax") = 2.5000			    			    // Set appropriate format string for the y axis labels (arm values are smaller so have 1 dp)			    mYAxisFormatString = "-######.00"			    			  end select			  			End Set		#tag EndSetter		sourceOfData As string	#tag EndComputedProperty	#tag ViewBehavior		#tag ViewProperty			Name="displayHighlightedStimulus"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="mHighestGraphAreaPixel"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="mLowestGraphAreaPixel"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="mTopSpace"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="sourceOfData"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass