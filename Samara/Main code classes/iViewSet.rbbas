#tag ClassClass iViewSet	#tag Method, Flags = &h0		Sub addBackgroundImage(b as backgroundImage, currentOnsetTime as double)		  // appends a newly read BackgroundImage to the list after setting the offset time of the previous one		  		  dim numOfImages as integer		  		  numOfImages = uBound(mBackgroundImages)		  		  // set the offset of any preceding image as corresponding to the onset of this latest one		  if numOfImages >= 0 then mBackgroundImages(numOfImages).offset = currentOnsetTime		  		  // at the end of the set importing, only a time is sent (corresponding to the offset of the last image), so there is no new image to store:		  if b <> nil then mBackgroundImages.append b		  		  		exception err		  gHandleException err, "addBackgroundImage method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub addDataPoint(p as dataPoint)		  // appends a newly read dataPoint to the data list		  		  dim upperBound as integer		  		  upperBound = uBound(mDataPoints)		  		  // if the sample is invalid, then knock out the preceding ones as well as there will often be discontinuities there		  if not p.valid then		    if upperBound > -1 then mDataPoints(upperBound).valid = false		    'if upperBound > 0 then mDataPoints(upperBound - 1).valid = false  // further knockouts don't really work as we need to go forwards as well, and that can't be done here.		    'if upperBound > 1 then mDataPoints(upperBound - 2).valid = false		  end if		  		  mDataPoints.append p		  		  		exception err		  gHandleException err, "addDataPoint method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub addGeometry(geometry as screenGeometry)		  // pass on the iView screen dimensions for pixel/angle conversion calculations		  mChart.addGeometry(geometry)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub addResponse(r as response)		  // appends a newly read subject response to the list		  mResponses.append r		  		  		exception err		  gHandleException err, "addResponse method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub addSPstimulus(s() as pursuitStimulus)		  // the parent iViewSession object passes on newly created pursuit stimuli to be appended here.		  // an array can't be passed and then assigned to an array property, so have to populate the array property entry by entry:		  		  dim i, upperLimit as integer		  		  redim mSPstimuli(-1)		  upperLimit = uBound(s)		  		  for i = 0 to upperLimit		    mSPstimuli.append s(i)		  next i		  		exception err		  gHandleException err, "addSPstimulus method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub addStimulus(s() as stimulus)		  // the parent iViewSession object passes on newly created stimuli to be appended here		  // the stimuli need to passed as an array rather than as individual objects (as the datapoints are)		  // because some of their properties are calculated contingent on their relationship to preceding stimuli.		  // an array can't be passed and then assigned to an array property, so have to populate the array property entry by entry:		  		  dim i, upperLimit as integer		  		  redim mStimuli(-1)		  upperLimit = uBound(s)		  		  for i = 0 to upperLimit		    mStimuli.append s(i)		  next i		  		exception err		  gHandleException err, "addStimulus method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub breakCircularReferences()		  mParentSession = nil		  		  if mPostHocCalibration <> nil then		    mPostHocCalibration.breakCircularReferences		    mPostHocCalibration = nil		  end if		  		  redim mBackgroundImages(-1)  // these hold references to pictures stored centrally in the iViewSession		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub calculateVelocities()		  dim i, upperLimit as integer		  dim prevInterval, nextInterval as single		  dim previousSample, currentSample, nextSample as dataPoint		  dim vx, vy, vz, t0, t1, t2, term1, term2, term3  as double		  dim moveData as boolean = false		  		  'gLog "calculateVelocities method of iViewSet class."		  		  mParentSession.displayProgressInfo("Calculating velocities")		  		  if sourceOfData = "MoVE" then moveData = true		  		  // now calculate velocities for the remaining valid points		  upperLimit = uBound(mDataPoints) -1  // as we are going to refer to a 'next sample' above this value		  		  // loop through each sample and calculate the velocity		  for i = 1 to upperLimit		    		    previousSample =  mDataPoints(i-1)		    currentSample = mDataPoints(i)		    nextSample = mDataPoints(i+1)		    		    if currentSample.valid and previousSample.valid and nextSample.valid then		      		      // calculate velocities using polynomial interpolation (see Kincaid & Cheney, Numerical Analysis, 2nd Ed, p. 505).		      t0 = previousSample.t		      t1 = currentSample.t		      t2 = nextSample.t		      term1 = (t1-t2)/((t0-t1)*(t0-t2))		      term2 = (2*t1-t0-t2)/((t1-t0)*(t1-t2))		      term3 = (t1-t0)/((t2-t0)*(t2-t1))		      		      currentSample.vx = previousSample.x * term1 + currentSample.x * term2 + nextSample.x * term3		      currentSample.vy = previousSample.y * term1 + currentSample.y * term2 + nextSample.y * term3		      		      if moveData then		        // calculate z and 3D Euclidean arm velocity		        currentSample.vz = previousSample.z * term1 + currentSample.z * term2 + nextSample.z * term3		        currentSample.v = sqrt(currentSample.vx^2 + currentSample.vy^2 + currentSample.vz^2)		        		      else		        // calculate 2D Euclidean eye velocity (currently just monocular)		        currentSample.v = sqrt(currentSample.vx^2 + currentSample.vy^2)		        		      end if		      		    else		      // either this sample or one of its neighbours is invalid		      if moveData then		        currentSample.v = -9999		      else		        currentSample.vx = -9999		        currentSample.vy = -9999		      end if		      		    end if		    		  next		  		  // The first and last samples need a notional velocity to avoid 'key not found errors' even though the velocity is undefined there.		  // use the adjoining sample as the best estimate.		  if moveData then		    mDataPoints(0).v = mDataPoints(1).v		    mDataPoints(upperLimit+1).v = mDataPoints(upperLimit).v		  else		    mDataPoints(0).vx = mDataPoints(1).vx		    mDataPoints(0).vy = mDataPoints(1).vy		    mDataPoints(upperLimit+1).vx = mDataPoints(upperLimit).vx		    mDataPoints(upperLimit+1).vy = mDataPoints(upperLimit).vy		  end if		  		  // loop through each sample and calculate the acceleration, currently just for arm data:		  if MoVeData then		    		    for i = 1 to upperLimit		      		      previousSample =  mDataPoints(i-1)		      currentSample = mDataPoints(i)		      nextSample = mDataPoints(i+1)		      		      if currentSample.valid and previousSample.valid and nextSample.valid then		        		        // calculate velocities using polynomial interpolation (see Kincaid & Cheney, Numerical Analysis, 2nd Ed, p. 505).		        t0 = previousSample.t		        t1 = currentSample.t		        t2 = nextSample.t		        term1 = (t1-t2)/((t0-t1)*(t0-t2))		        term2 = (2*t1-t0-t2)/((t1-t0)*(t1-t2))		        term3 = (t1-t0)/((t2-t0)*(t2-t1))		        		        if moveData then		          // calculate component and norm acceleration		          currentSample.ax = previousSample.vx * term1 + currentSample.vx* term2 + nextSample.vx * term3		          currentSample.ay = previousSample.vy * term1 + currentSample.vy * term2 + nextSample.vy * term3		          currentSample.az = previousSample.vz * term1 + currentSample.vz * term2 + nextSample.vz * term3		          currentSample.a3 = sqrt(currentSample.ax^2 + currentSample.ay^2 + currentSample.az^2)		          		        else		          // calculate horizontal and vertical velocity (currently just monocular)		          currentSample.ax = previousSample.vx * term1 + currentSample.vx * term2 + nextSample.vx * term3		          currentSample.ay = previousSample.vy * term1 + currentSample.vy * term2 + nextSample.vy * term3		        end if		        		      else		        // either this sample or one of its neighbours is invalid		        if moveData then		          currentSample.v = -9999		        else		          currentSample.vx = -9999		          currentSample.vy = -9999		        end if		        		      end if		      		    next		    		    // The first and last samples need a notional velocity to avoid 'key not found errors' even though the velocity is undefined there.		    // use the adjoining sample as the best estimate.		    if moveData then		      mDataPoints(0).v = mDataPoints(1).v		      mDataPoints(upperLimit+1).v = mDataPoints(upperLimit).v		    else		      mDataPoints(0).vx = mDataPoints(1).vx		      mDataPoints(0).vy = mDataPoints(1).vy		      mDataPoints(upperLimit+1).vx = mDataPoints(upperLimit).vx		      mDataPoints(upperLimit+1).vy = mDataPoints(upperLimit).vy		    end if		    		  end if		  		  mParentSession.displayProgressInfo("") // clear the status message		  		  		exception err		  gHandleException err, "calculateVelocities method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function canMoveAlongTimeAxis(leftward as boolean, amount as single) As boolean		  // called by the iViewSession class to shift the zoomed-in view of the data left or right.		  // the 'leftward' parameter specifies 'direction' and should be TRUE (leftward) or FALSE (rightward).		  // the function returns 'true' if the data can be shifted and the graphs need to be redrawn.		  // if false, the data is already at its limits and can't be scrolled further in the given direction		  // and hence doesn't need to be redrawn		  		  // the 'amount' parameter should be 0.5 (move the data by half its range) or 1.0 (move the end time to be the start).		  		  dim range, originalMinimum as single		  		  'gLog "moveAlongTimeAxis method of iViewSet class"		  		  range = mMaxTimeDisplayed - mMinTimeDisplayed		  originalMinimum = mMinTimeDisplayed		  		  if leftward then		    mMinTimeDisplayed = mMinTimeDisplayed - amount * range  // move the time window leftwards		  else		    mMinTimeDisplayed = mMinTimeDisplayed + amount * range  //move the time window rightwards		  end if		  		  mMaxTimeDisplayed = mMinTimeDisplayed + range		  		  // check that the newly selected time window doesn't exceed the bounds of the data itself		  // if so, just bump up against the beginning or end of the recording as appropriate		  if mMaxTimeDisplayed > mDataDuration then		    mMaxTimeDisplayed = mDataDuration		    mMinTimeDisplayed = mDataDuration - range		  end if		  		  if mMinTimeDisplayed < 0 then		    mMinTimeDisplayed = 0		    mMaxTimeDisplayed = range		  end if		  		  // let the caller know if the data range was actually shifted.  If not, the graph doesn't need to be redrawn		  if mMinTimeDisplayed = originalMinimum then		    return false		  else		    return true		  end if		  		exception err		  gHandleException err, "moveAlongTimeAxis method of iViewSet class."		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function changeYAxisScale(upwards as boolean, components() as string) As boolean		  dim needToRedraw as boolean		  		  needToRedraw = mChart.changeYAxisScale(upwards, components)		  if needToRedraw then self.dirty = TRUE		  		  return needToRedraw		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub compressCursors()		  // in response to a keypress (9), make all the cursors jump back to the position of the first one.		  		  'gLog "compressCursors method of iViewSet class"		  		  dim i, upperLimit, n as integer		  dim t as double		  		  		  upperLimit = uBound(mCursors)		  n = mCursors(0).n		  t = mCursors(0).t		  		  for i = 1 to upperLimit		    mCursors(i).n = n		    mCursors(i).t = t		  next		  		  		exception err		  gHandleException err, "compressCursors method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub compressHigherCursors()		  // in response to a keypress (8), make all the cursors > #3 jump back to the position of the #3.		  		  'gLog "compressHigherCursors method of iViewSet class"		  		  dim i, upperLimit, n as integer		  dim t as double		  		  		  upperLimit = uBound(mCursors)		  n = mCursors(2).n		  t = mCursors(2).t		  		  for i = 3 to upperLimit		    mCursors(i).n = n		    mCursors(i).t = t		  next		  		  		exception err		  gHandleException err, "compressHigherCursors method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(session as iViewSession)		  // create a link to the session object of which this set is a part		  mParentSession = session		  		  // create some needed object properties:		  mChart = new chart		  		  		exception err		  gHandleException err, "Constructor method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Destructor()		  'gLog "iViewSet destructor"		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function detectNextFastMovementInRange(byref lowerSampleNumber as integer, byref upperSampleNumber as integer, detectSmallSaccades as boolean = false) As boolean		  // to find the next saccade, and reposition the cursors if required.		  // Detects the next fast movement within the range of samples specified.		  // if a movement is found, then it returns true, and the byref integer parameters		  // are modified to indicate the start and finish samples of the movement.		  // the detectSmallSaccades parameter defaults to false.  When true,		  // a lower velocity threshold is used for counting small saccades.		  // In general use (when jumping from one primary saccade to the next, it		  // is more convenient to use a larger threshold so the cursors leap from one trial to		  // the next more quickly.		  		  dim i, j, cursor2Bound, detectionN, startN, endN as integer		  dim detected as boolean = false		  dim velocity, velocity2 as single		  dim detectThreshold, endThreshold as single		  dim selectedVelocity as string		  		  		  select case sourceOfData		    		  case "iView"		    		    if self.analyse2D then  // which velocity component is used for deciding when a movement occurs		      		      selectedVelocity = "v"  // euclidean for 2D analysis		      endThreshold = 50.0  // Just used to get in the ball park: search forwards from this value		      // to find the nearest minimum.  This "close to zero as possible" point is the start or end of the movement.		      // Set very high for 2D analysis due to noise issues.		      		      if detectSmallSaccades then // e.g. when counting saccades in the 'measure' method		        detectThreshold = 50.0  // velocity threshold for small, corrective saccade counting.		      else		        detectThreshold = 100.0  // velocity threshold for primary saccade detection when moving the cursors automatically.		      end if		      		    else		      		      selectedVelocity = "vx"  // or just horizontal		      endThreshold = 5.0		      		      if detectSmallSaccades then // e.g. when counting saccades in the 'measure' method		        detectThreshold = 30.0  // velocity threshold for small, corrective saccade counting.		      else		        detectThreshold = 80.0  // velocity threshold for primary saccade detection when moving the cursors automatically.		      end if		      		    end if		    		  case "MoVE"		    		    detectThreshold = 0.15  // 0.15 m/s velocity threshold		    endThreshold = 0.10  // effective zero velocity threshold.  Just used to get in the ball park: search forwards		    // or backward as needed to find the nearest minimum.  This "close to zero as possible" point is the start or end of the movement		    selectedVelocity = "v"  // which velocity component is used for deciding when a movement occurs		    		  end select		  		  cursor2Bound = lowerSampleNumber + 1 // need to give a little bit of wiggle room in case the last cursor is right on a saccade, so have some room to work backwards.		  		  // search the specified range to find the first point with a velocity > detectThreshold		  for i = lowerSampleNumber to upperSampleNumber		    if detected then exit  // when a movement is detected in the embedded loop lower down, the loop is exited and returns to here so need another exit statement		    		    		    		    // this is all very messy- the embedded loop should be unnested, but it works for the time being.		    velocity = abs(mDataPoints(i).getDataValue(selectedVelocity)) // the current point's velocity		    // have we detected a saccade?		    if velocity >= detectThreshold and velocity <> 9999  then // don't get caught out by invalid velocity values		      detectionN = i		      // a saccade is in progress, and we need to search backwards for the onset of the saccade		      for j = detectionN - 1 downTo cursor2Bound		        velocity2 = abs(mDataPoints(j).getDataValue(selectedVelocity))		        if velocity2 < velocity then  // the velocity is decreasing prior to the detection point		          startN = j  // so shift our new start estimate to this sample		          velocity = velocity2		          // put this check in for some cases where movements are continuous (e.g. self-paced arm movements) and the velocity keeps decreasing until the lower end of the		          // interval.  Without this check, the loop would repeat and the peak velocity would be selected as the beginning.		          if startN = cursor2Bound then		            detected = true		            exit		          end if		        else  // the velocity is no longer monotonically decreasing, and we should exit with our current start estimate even though the velocity may be above the start threshold		          startN = j + 1		          detected = true		          exit		        end if		        		        		        		      next		      		      		      		    end if		    		  next		  		  // only if a saccade start was found, then search for a location for the second cursor at the end of the saccade		  if detected then		    lowerSampleNumber = startN		    // search forward from the point at which the movement was detected until the end of the range:		    for i = detectionN to upperSampleNumber		      // the end of the movement must be after the first point at which the velocity drops below threshold again.		      // If there is no such point, the end will be the last data sample.		      endN = i		      		      if abs(mDataPoints(i).getDataValue(selectedVelocity)) <= endThreshold then		        // start searching forward (in the tail section of the movement) until the velocity is no longer monotonically decreasing		        velocity = abs(mDataPoints(i).getDataValue(selectedVelocity))		        		        for j = i + 1 to mHighestSampleNumDisplayed		          		          velocity2 = abs(mDataPoints(j).getDataValue(selectedVelocity))		          if velocity2 < velocity then  // the velocity is decreasing from the value at the threshold point		            endN = j  // so shift our new start estimate to this sample		            velocity = velocity2		          else  // the velocity is no longer monotonically decreasing, and we should exit		            exit		          end if		          		        next j		        		        endN = j - 2  // subtracting two seems to work best		        exit		        		      end if		      		    next i		    		    // set the 2nd cursor to be at the movement end point:		    upperSampleNumber = endN		    		    		  end if		  		  return detected		  		  		exception err		  gHandleException err, "detectNextFastMovementInRange method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub display(g as graphics, component() as string, resolution as integer, gazeDisplay as boolean)		  dim numberOfCharts, i, upperLimit as integer  // how many graphs from this data (eg, x posn and x velocity) will be drawn		  dim chartWidth, chartHeight  as integer      // the height of each of the individual charts to be drawn (all the same size)		  dim samples() as dataPoint		  dim stimuli() as stimulus		  dim backGrounds() as backgroundImage		  dim responses() as response		  dim graphPicture as picture		  		  'gLog "display method of iViewSet class"		  		  // set some properties needed before the data can be displayed		  if not self.mInitialised then		    self.preDisplayTasks		  end if		  		  // get the data samples within the time bounds being drawn on screen:		  samples = self.getSamplesInRange(mMinTimeDisplayed, mMaxTimeDisplayed)		  mLowestSampleNumDisplayed = samples(0).n  // the data object secretly tags these two samples with their indices within the data array.		  mHighestSampleNumDisplayed = samples(uBound(samples)).n		  		  // moving the data may mean that cursors would move out of the range of the displayed data.  If so,		  // shift individual cursors to the relevant boundary.		  upperLimit = uBound(mCursors)		  for i = 0 to upperLimit		    if mCursors(i).n < mLowestSampleNumDisplayed then		      mCursors(i).n = mLowestSampleNumDisplayed		      mCursors(i).t = self.getValueForSample("t", mLowestSampleNumDisplayed)		    end if		    		    if mCursors(i).n > mHighestSampleNumDisplayed then		      mCursors(i).n = mHighestSampleNumDisplayed		      mCursors(i).t = self.getValueForSample("t", mHighestSampleNumDisplayed)		    end if		  next		  		  // only the first time a set is shown, automatically detect the first movement.  Put after the cursor shifting stuff above		  // because there is sometimes a non-displayed period at the start of a set where there are no stimuli, so this ensures that the		  // movement will be detected in the visible part of the data.		  if not self.mInitialised then		    self.moveCursorsToNextMovement		    mInitialised = true		  end if		  		  // get the stimuli and responses within the time bounds being drawn on screen:		  stimuli = self.getStimuliInRange(mMinTimeDisplayed, mMaxTimeDisplayed)		  responses = self.getResponsesInRange(mMinTimeDisplayed, mMaxTimeDisplayed)		  backGrounds = self.getBackgroundsInRange(mMinTimeDisplayed, mMaxTimeDisplayed)		  		  // send the data range to the chart for drawing		  if gazeDisplay then		    mParentSession.displayProgressInfo("Drawing 2D display...")		    mChart.plot2D(g, samples(), stimuli(), backGrounds(), resolution)  // plus need to send the backgrounds(),		  else		    mParentSession.displayProgressInfo("Drawing line traces...")		    mChart.plotLineTraces(g, samples(), stimuli(), component(), resolution, self.movementFeedbackGain, responses(), self.analyse2D)		  end if		  		  self.dirty = FALSE  // has just been redrawn, so reset this flag		  mParentSession.displayProgressInfo("")		  		  		exception err		  gHandleException err, "display method of iViewSet class."		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub displayHighlightedStimulus(value as boolean)		  mChart.displayHighlightedStimulus = value		  self.dirty = value		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub drawCrossHair(mouseX as integer, mouseY as integer)		  dim crossHair as group2D		  		  crossHair = mChart.plotCrossHair(mouseX, mouseY)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function drawCursors() As group2D		  		  dim chartGroup2D as new group2D		  dim cursorGroup2D as new group2D		  		  if self.showCursors then		    mChart.plotCursors(mCursors)		    return mChart.cursorObjects		  else		    return nil		  end if		  		  		exception err		  gHandleException err, "drawCursors method of iViewSet class."		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function exportTrace() As dataTraceForExport		  // this method returns the data as a dataTraceForExport object with columns representing:		  // 0: valid or invalid sample (0 = invalid, 1 = valid)		  // 1: time (beginning of set = 0)		  // MoVE data: 2,3,4 = x,y,z		  // iView data: 2,3 = x,y		  // subsequent columns will be the x,y,z components as appropriate of the stimulus.		  // NB this may distort the actual behaviour of the stimulus in cases where more than one stimulus is visible simultaneously.		  // When the stimulus is invisible, null values are used.		  		  		  dim row, column, numberOfRows, numberOfColumns as integer		  dim endRow, startRow as integer		  dim label, labels() as string		  dim values(), yValues() as variant		  dim traces as dataTraceForExport		  dim traceCursor as new Cursor		  dim currStim as stimulus		  		  'gLog " getDataTrace method of Data class"		  		  		  traces = new dataTraceForExport		  		  // set up what variables will be exported:		  redim labels(5)		  labels(0) = "valid"		  labels(1) = "t"		  labels(2) = "x"		  labels(3) = "y"		  		  select case self.sourceOfData		    		  case "iView"		    labels(4) = "vx"		    labels(5) = "vy"		  case "MoVE"		    labels(4) = "z"		    labels(5) = "v"		  end select		  		  		  startRow = mCursors(0).n		  endRow = mCursors(1).n		  numberOfRows = endRow - startRow		  'numberOfRows = uBound(mDataPoints)  // zero based		  		  numberOfColumns = uBound(labels) // zero based		  		  // get data		  for column = 0 to numberOfColumns		    		    label = labels(column)		    redim values(numberOfRows)		    		    for row = 0 to numberOfRows		      'if mDataPoints(row).hasKey(label) then		      'values(row) = mDataPoints(row).getDataValue(label)		      values(row) = mDataPoints(startRow + row).getDataValue(label)		      'else		      'values(row) = ""		      'end if		    next		    		    traces.addDataColumn(label, values)		    		    redim values(-1)  // clear existing data		    		  next		  		  //get stimulus values		  redim values(numberOfRows)		  redim yValues(numberOfRows)		  		  for row = 0 to numberOfRows		    traceCursor.t = mDataPoints(startRow + row).getDataValue("t")		    currStim = getExactStimulus(traceCursor)		    if currStim <> nil then		      values(row) = getExactStimulus(traceCursor).value("x")		      yValues(row) = getExactStimulus(traceCursor).value("y")		    else		      values(row) = ""		      yValues(row) = ""		    end		  next		  		  traces.addDataColumn("stim x", values)		  traces.addDataColumn("stim y", yValues)		  		  		  		  		  		  return traces		  		  		  		exception err		  gHandleException err, "exportTrace method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub filter(filterType as string)		  		  // filters or unfilters the data, depending on the parameter passed.		  // if the data has not been filtered previously, store the unfiltered x and y coordinates		  // as x0 and y0 values, then calculate new x and y values.		  // then recalculate the velocities.		  		  dim i, upperLimit as integer		  dim xTemp(), yTemp(), zTemp() as double		  dim currPoint, point1, point3 as dataPoint		  dim moveData as boolean = false		  		  'gLog "filter method of iViewSet class"		  		  mAppliedFilter = filterType  // store a label of the currently applied filter type		  		  mParentSession.displayProgressInfo("Applying filter (" + filterType + ")." )		  		  upperLimit = uBound(mDataPoints)		  		  // do some MoVE specific things		  if sourceOfData = "MoVE" then		    moveData = true		    if not mHasBeenFilteredBefore then self.interpolateNaNs  // smooths out any NaN-containing samples		  end if		  		  // choose which filter to apply		  select case filterType		    		  case "Butterworth"		    self.filterButterworth		    		  case "Triangular"		    // NB this code mistakenly filters forwards and backwards when there is no need to do so in this case as this filter,		    // symmetrical about the current sample, introduces no phase shift.  At the moment, there is probably no great harm in this		    // and it probably just strengthens the filtering.  May want to remove this though to be clearer about what is going on.		    // Once the Butterworth filter is implemented for the arm, will probably be best to deprecate this simple triangular filter and use a		    // Butterworth with other weights		    		    // check if data has already been filtered.  If not, store the orginal data values in new keys.		    if not mHasBeenFilteredBefore then		      for i = 0 to upperLimit		        mDataPoints(i).storeOriginalData		      next		    end if		    		    // succeeding points take a triangular weighted value from themselves and nearest neighbours,		    // but only if each of those points is valid.		    		    // create some temporary arrays for the filter to use for storing intermediate values.		    redim xTemp(upperLimit)		    redim yTemp(upperLimit)		    redim zTemp(upperLimit)		    		    // first filter in one direction, creating a temporary store of filtered values		    for i = 1 to upperLimit -1		      point1 = mDataPoints(i-1)		      currPoint = mDataPoints(i)		      point3 = mDataPoints(i+1)		      if point1.valid and currPoint.valid and point3.valid then		        xTemp(i) = point1.x * 0.25 + currPoint.x* 0.5 + point3.x * 0.25		        yTemp(i) = point1.y * 0.25 + currPoint.y* 0.5 + point3.y * 0.25		        if moveData then zTemp(i) = point1.z * 0.25 + currPoint.z* 0.5 + point3.z* 0.25		      else		        xTemp(i) = currPoint.x		        yTemp(i) = currPoint.y		        if moveData then zTemp(i) = currPoint.z		        		      end if		    next		    		    // the first and final points just take the original values		    xTemp(0) = mDataPoints(0).x		    yTemp(0) = mDataPoints(0).y		    if moveData then zTemp(0) = mDataPoints(0).z		    xTemp(upperLimit) = mDataPoints(upperLimit).x		    yTemp(upperLimit) = mDataPoints(upperLimit).y		    if moveData then zTemp(upperLimit) = mDataPoints(upperLimit).z		    		    		    // then filter in the other direction to remove any phase shift, using the previously filtered values (x1, y1)		    // NB this doesn't really matter (no phase shift), so this step is unnecessary		    for i = upperLimit -1 downTo 1		      currPoint = mDataPoints(i)		      point1 = mDataPoints(i-1)		      point3 = mDataPoints(i+1)		      if point1.valid and currPoint.valid and point3.valid then		        currPoint.x = xTemp(i-1) * 0.25 + xTemp(i) * 0.5 + xTemp(i+1) * 0.25		        currPoint.y = yTemp(i-1) * 0.25 + yTemp(i) * 0.5 + yTemp(i+1) * 0.25		        if moveData then currPoint.z = zTemp(i-1) * 0.25 + zTemp(i) * 0.5 + zTemp(i+1) * 0.25		      else		        currPoint.x = xTemp(i)		        currPoint.y = yTemp(i)		        if moveData then currPoint.z = yTemp(i)		      end if		    next		    		    '// the first and final points just take the original values		    'mDataPoints(0).x = mDataPoints(0).value("x0")		    'mDataPoints(0).y = mDataPoints(0).value("y0")		    'mDataPoints(upperLimit).x = mDataPoints(upperLimit).value("x0")		    'mDataPoints(upperLimit).y = mDataPoints(upperLimit).value("y0")		    		    		    // recalculate the velocities		    self.calculateVelocities		    		  case "None"  // ie remove any filtering that may have been applied.		    		    if mHasBeenFilteredBefore then  // check it actually has been filtered before		      for i = 0 to upperLimit		        mDataPoints(i).resetToOriginalData		      next		      		      // recalculate the velocities		      self.calculateVelocities		    end if		    		  case else  // an unrecognised filterType was passed in		    		    msgBox "An attempt was made to apply the unrecognised filter '" + filterType + "' in the Filter method of the iViewSet class."		    		  end select		  		  // set this flag so that certain operations are done only once		  mHasBeenFilteredBefore = true		  		  self.dirty = TRUE		  		exception err		  gHandleException err, "filter method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub filterButterworth()		  // called by the filter method when this particular sort of filter is requested.		  		  // this is a 2nd order Butterworth low-pass filter for a sampling freq of 240 Hz and a cut-off freq of 10Hz for arms.		  // Designed to be used bi-directionally, giving an effective cutoff freq of 8 Hz.		  // y(n) = b(0) * x(n) + b(1)*x(n-1) + b(2)*x(n-2)   - a(1)*y(n-1) - a(2)*y(n-2)		  		  // coefficients produced using the Windows program WinFilter, specifiying Butterworth low pass IIR, Fsample 1250 or 500 Hz etc, Fcut 70 Hz, filter order 2.		  		  		  dim i, j, upperLimit, lowerLimit, noOfCoefficients, validCount as integer		  dim yi(2) as double		  dim currPoint, nearPoint as dataPoint		  dim moveData as boolean = false		  dim a(2), b(2) as double		  dim xTemp(), yTemp(), zTemp() as double		  		  if self.sourceOfData = "MoVE" then		    b(0) = 0.01440144034651		    b(1) = 0.02880288069302		    b(2) = 0.01440144034651		    		    // a(0) is not used		    a(1) = -1.63299316185545		    a(2) = 0.69059892324150		    		  else		    		    select case self.sampleRate		      		    case 200 // eye data at 200 Hz, cut-off freq of 70 Hz		      b(0) = 0.50500102878259168		      b(1) = 1.01000205756518340		      b(2) = 0.50500102878259168		      		      a(1) = 0.74778917825850355		      a(2) = 0.27221493792500723		      		    case 240 // eye data at 240 Hz, cut-off freq of 70 Hz, bi-directionally giving an effective cutoff freq of approx 60 Hz.		      b(0) = 0.37397788016906		      b(1) = 0.74795576033813		      b(2) = 0.37397788016906		      		      a(1) = 0.30756635979221		      a(2) = 0.18834516088404		      		    case 350    // eye data at 350 Hz, cut-off freq of 70 Hz, bi-directionally giving an effective cutoff freq of approx 60 Hz.		      b(0) =  0.20657208382615		      b(1) =  0.41314416765230		      b(2) =  0.20657208382615		      		      a(1) = -0.36952737735124		      a(2) = 0.19581571265583		      		    case 500		      b(0) =  0.11735103613509615		      b(1) =  0.23470207227019230		      b(2) =  0.11735103613509615		      		      a(1) = -0.82523238068947824		      a(2) = 0.294636527587914640		      		    case 1250		      b(0) =  0.024639002858645672		      b(1) =  0.049278005717291344		      b(2) =  0.024639002858645672		      		      a(1) = -1.5095832591930776		      a(2) = 0.60810569138935289		      		      		      		      'case 1250 // 5th order filter, 100 Hz cut off		      'redim a(5)		      'redim b(5)		      'b(0) =  0.00049268056115804961		      'b(1) =  0.00246340280579024780		      'b(2) =  0.00492680561158049570		      'b(3) =  0.00492680561158049570		      'b(4) =  0.00246340280579024780		      'b(5) =  0.00049268056115804961		      '		      'a(1) = -3.37801139459686710000		      'a(2) = 4.75177537470701420000		      'a(3) = -3.43971331083558770000		      'a(4) = 1.27399988148292360000		      'a(5) = -0.19238859600117320000		      		    case else		      beep		      gLog "The Butterworth filter does not have coefficients to deal with data sampled at this rate: " + str(self.sampleRate) + " Hz."		      return		      		    end select		    		  end if		  		  'gLog "filterButterworth method of Data class " + str(self.sampleRate)		  		  noOfCoefficients = uBound(b)  // this is for generalisability.  We may in the future want to change the order of the filter		  upperLimit = uBound(mDataPoints)		  if sourceOfData = "MoVE" then moveData = true		  		  // check if data has already been filtered.  If not, store the original data values in new keys,		  if not mHasBeenFilteredBefore then		    for i = 0 to upperLimit		      mDataPoints(i).storeOriginalData		    next		  end if		  		  // plus create some temporary arrays for the filter to use for storing intermediate values.		  redim xTemp(upperLimit)		  redim yTemp(upperLimit)		  redim zTemp(upperLimit)		  		  // For the first and last few samples, the preceding or following 1 or 2 samples may not exist.  In this case, the contribution of these samples		  // to the equation should be zero.  Currently, there appear to be discontinuities in the velocity and acceleration		  // values at either end of the recording.  These are ignored for the time being but really should be tidied up.		  // But doesn't this bit below (subtracting the number of coefficients) deal with that?		  		  // apply the filter upwards through the data:		  lowerLimit = noOfCoefficients		  upperLimit = upperLimit - noOfCoefficients		  		  for i = lowerLimit to upperLimit		    		    currPoint = mDataPoints(i)		    		    yi(0) = 0		    yi(1) = 0		    yi(2) = 0		    		    for j = 0 to noOfCoefficients  // add the effects of the 'b' coefficients on the raw input data terms, ie the current sample and the two preceding ones (x component)		      		      nearPoint = mDataPoints(i-j)		      yi(0) = yi(0) + (b(j) * nearPoint.x)		      yi(1) = yi(1) + (b(j) * nearPoint.y)		      if moveData then yi(2) = yi(2) + (b(j) * nearPoint.z)		      		    next j		    		    for j = 1 to noOfCoefficients  // add the effects of the 'a' coefficients on the output data terms,		      nearPoint = mDataPoints(i-j)		      yi(0) = yi(0) - (a(j) * xTemp(i-j))  // ie the two preceding filtered values.		      yi(1) = yi(1) - (a(j) * yTemp(i-j))		      if moveData then yi(2) = yi(2) - (a(j) * zTemp(i-j))		    next j		    		    xTemp(i) = yi(0)		    yTemp(i) = yi(1)		    if moveData then zTemp(i) = yi(2)		  next i		  		  // now go back the other way to remove the phase shift introduced by the first pass of the filter:		  for i = upperLimit downTo lowerLimit		    		    currPoint = mDataPoints(i)		    		    yi(0) = 0		    yi(1) = 0		    yi(2) = 0		    		    for j = 0 to noOfCoefficients		      nearPoint = mDataPoints(i+j)		      yi(0) = yi(0) + (b(j) * xTemp(i+j))		      yi(1) = yi(1) + (b(j) * yTemp(i+j))		      if moveData then yi(2) = yi(2) + (b(j) * zTemp(i+j))		    next j		    		    for j = 1 to noOfCoefficients		      nearPoint = mDataPoints(i+j)		      yi(0) = yi(0) - (a(j) * nearPoint.x)		      yi(1) = yi(1) - (a(j) * nearPoint.y)		      if moveData then yi(2) = yi(2) - (a(j) * nearPoint.z)		    next j		    		    // invalid samples cause discontinuities to neighbours, so we should apply the filter only where no invalid points contributed to the process.		    if currPoint.valid and mDataPoints(i-1).valid and mDataPoints(i-2).valid and mDataPoints(i+1).valid and mDataPoints(i+2).valid then		      currPoint.x = yi(0)		      currPoint.y = yi(1)		      if moveData then currPoint.z = yi(2)		    end if		  next i		  		  // invalidate some samples at either end to remove other discontinuities introduced by the filter		  if upperLimit > noOfCoefficients + 2 then  // check this for very rare cases of tiny sets with only a few data samples		    for i = 0 to noOfCoefficients + 2		      mDataPoints(i).valid = false		    next i		    for i = upperLimit -2 to upperLimit + noOfCoefficients		      mDataPoints(i).valid = false		    next i		  end if		  		  // recalculate the velocities based on the newly filtered data		  self.calculateVelocities		  		exception err		  gHandleException err, "filterButterworth method of iViewSet class."		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function firstSampleTime() As double		  // returns the time value of the first sample.  To truncate crappy data at the beginning of sets (in MOVE data),		  // we can set the time of the first displayed sample to be the time of onset of the first stimulus.		  // But when there are no stimuli, as sometimes happens, we need to return 0 so that data will		  // actually be displayed.  We may actually want to insert another check here in the future so that		  // the user can make that behaviour optional so that all data is always displayed.		  		  if uBound(mStimuli) = -1 or self.sourceOfData = "iView" then		    return 0		  else		    return mStimuli(0).Value("onsetTime")		  end if		  		  		exception err		  gHandleException err, "firstSampleTime method of iViewSet class."		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function getAllSamples() As dataPoint()		  dim maxTime as double		  dim samples() as dataPoint		  		  'gLog "getAllSamples method of Data class"		  		  maxTime = mDataPoints(ubound(mDataPoints)).t		  samples() = getSamplesInRange(0, maxTime)		  		  return samples()		  		exception err		  gHandleException err, "getAllSamples method of Data class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function getAppliedFilter() As string		  // returns to the parent session object a string describing the filter currently applied, for GUI purposes		  return mAppliedFilter		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function getBackgroundsInRange(minTime as double, maxTime as double) As backgroundImage()		  // returns a given range of backgroundImages for plotting in the 2D view,		  // given time values which specify the start and end of the desired range.		  // Called by the display method of the iViewSet class.		  		  dim backgrounds(), currentBackground as backgroundImage		  dim i, upperLimit as integer		  		  		  // cycle through all the stimuli in this set and see whether they occur during the desired time window:		  upperLimit = uBound(mBackgroundImages)		  		  for i = 0 to upperLimit		    		    currentBackground = mBackgroundImages(i)		    		    if currentBackground.onset >= minTime and currentBackground.onset <= maxTime then		      backgrounds.append currentBackground		    elseif currentBackground.offset >= minTime and currentBackground.onset <= maxTime then		      backgrounds.append currentBackground		    end if		    		  next i		  		  return backgrounds()		  		  		exception err		  gHandleException err, "getBackgroundsInRange method of iViewSet class."		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function getCursorDisplayData() As dictionary		  // collates information about the current cursor positions and values and returns it to be		  // displayed in the parent session's chartWindow's displayCursorData method		  		  dim cursorData as new dictionary		  dim currStimulus, latencyStimulus as stimulus		  dim stimNumber, chooseAdjoiningStimulus as integer		  dim stimPosn, time1, time2, timeDiff as single		  dim velocityUnit, spatialUnit, velocityFormat, spatialFormat, latencyStr as string		  dim backGround as backgroundImage		  		  select case sourceOfData		    		  case "iView"		    velocityUnit = " deg/s"		    velocityFormat = "-####"		    spatialUnit = " deg"		    spatialFormat = "-##.00"		    		  case "MoVE"		    velocityUnit = " m/s"		    velocityFormat = "-#.000"		    spatialUnit = " m"		    spatialFormat = "-##.000"		    		  end select		  		  // get the latency. The stimulus it is worked out wrt is not necessarily the stimulus at the cursor location.		  // also need to take into account whether a modifier key is being held down to force an earlier or later stimulus to be selected:		  if keyboard.asyncControlKey then		    chooseAdjoiningStimulus = 1  // select the stimulus following the automatically-chosen one		    		  elseif keyboard.asyncShiftKey then		    chooseAdjoiningStimulus= -1  // select the stimulus preceding the automatically-chosen one		    		  else		    chooseAdjoiningStimulus = 0 // select the automatically-chosen stimulus (generally correct).		  end if		  		  		  latencyStr = format(self.getLatencyAtFirstCursor(chooseAdjoiningStimulus), "-####") +  " ms"		  latencyStimulus = self.getStimulusForCurrentTrial(chooseAdjoiningStimulus)		  if latencyStimulus <> nil then latencyStr = latencyStr + ", #" + str(latencyStimulus.value("number"))		  		  		  currStimulus = self.getExactStimulus(mCursors(0))		  if currStimulus <> nil then		    stimNumber = val(currStimulus.value("number"))		  else		    stimNumber = -1		  end if		  		  if stimNumber > -1 then  // the returned stimulus number is -1 if there is no stimulus defined at the cursor position		    stimPosn = self.getValueForStimulus("x", stimNumber)		  else		    stimPosn = -9999		  end if		  time1 = self.getValueForSample("t", mCursors(0).n)		  time2 = self.getValueForSample("t", mCursors(1).n)		  timeDiff = (time2 - time1) * 1000		  // some of these key strings have an extraneous last character which is trimmed when displayed (messy kludge to allow the dictionary to have unique keys)		  cursorData.value("CURSOR 1q") = format(time1, "####.000") + " s"		  cursorData.value("latency1") = latencyStr		  cursorData.value("x position1") = format(self.getValueForSample("x", mCursors(0).n), spatialFormat) + spatialUnit		  cursorData.value("y position1") = format(self.getValueForSample("y", mCursors(0).n), spatialFormat) + spatialUnit		  if sourceOfData = "iView" then		    cursorData.value("x velocity1") = format(self.getValueForSample("vx", mCursors(0).n), velocityFormat) + velocityUnit		    cursorData.value("y velocity1") = format(self.getValueForSample("vy", mCursors(0).n), velocityFormat) + velocityUnit		    cursorData.value("2D velocity1") = format(self.getValueForSample("v", mCursors(0).n), velocityFormat) + velocityUnit		  else		    cursorData.value("z position1") = format(self.getValueForSample("z", mCursors(0).n), spatialFormat) + spatialUnit		    cursorData.value("velocity1") = format(self.getValueForSample("v", mCursors(0).n), velocityFormat) + velocityUnit		  end if		  cursorData.value("1") = " "		  cursorData.value("STIMULUS #q") = format(stimNumber, "-####")		  cursorData.value("x positionq") = format(stimPosn, spatialFormat) + spatialUnit		  		  if sourceOfData = "iView" then		    background = self.getExactBackground(mCursors(0))		    		    if background = nil then		      cursorData.value("Backgroundq") = "Nil"		      cursorData.value("2") = " "		    else		      cursorData.value("Backgroundq") = left(backGround.fileName, 18)  // trim long names so they don't cause a flow to the next line		      if len(background.fileName) <= 18 then		        cursorData.value("2") = " "		      else		        cursorData.value("2") = mid(backGround.fileName, 19, 18)		      end if		    end if		    		  else		    cursorData.value("2") = " "		  end if		  		  cursorData.value("CURSOR 2q") = format(time2, "####.000") + " s"		  cursorData.value("x position2") = format(self.getValueForSample("x", mCursors(1).n), spatialFormat) +spatialUnit		  cursorData.value("time 2-1q") = format(timeDiff, "######") + " ms"		  cursorData.value("3") = " "		  cursorData.value("CURSOR 3q") = format(self.getValueForSample("t", mCursors(2).n), "####.000") + " s"		  cursorData.value("x position3") = format(self.getValueForSample("x", mCursors(2).n), spatialFormat) + spatialUnit		  		  		  		  return cursorData		  		exception err		  gHandleException err, "getCursorDisplayData method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function getDataPointAtIndex(index as integer) As dataPoint		  // finds the dataPoint which is exactly at the position of the cursor.		  // for some purposes, it is useful to know what the index of the data point was, so it is tagged with that before being sent on.		  // i.e. that way we can retain its context outside of its array.  The calibration routines need to fetch the updated datapoints		  // at times, and so can now do so using the embedded index value.		  		  		  dim point as dataPoint		  		  point = mDataPoints(index)		  point.n = index		  		  return point		  		exception err		  gHandleException err, "getDataPointAtIndex method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function getExactBackground(cursor1 as cursor) As backgroundImage		  // finds the backgroundImage which is exactly at the position of the cursor.		  		  dim i, numberOfBackgrounds as integer		  dim backgroundNum as integer = -1		  dim cursorTime as double		  		  cursorTime = cursor1.t		  		  numberOfBackgrounds = uBound(mBackgroundImages)		  if numberOfBackgrounds > -1 then		    		    for i = 0 to numberOfBackgrounds		      if cursorTime > mBackgroundImages(i).onset and cursorTime <  mBackgroundImages(i).offset then		        backgroundNum = i		        exit		      end if		    next		    		  end if		  		  //  return nil if the cursor is not located over any backGroundImage:		  if backgroundNum = -1 then		    return nil		  else		    return mBackgroundImages(backgroundNum)		  end if		  		exception err		  gHandleException err, "getExactBackground method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function getExactStimulus(cursor1 as cursor) As stimulus		  // finds the stimulus which is exactly at the position of the cursor.		  // used in the postHocCalibration calculation		  		  dim i, upperLimit as integer		  dim closestStimulusIndex as integer = -1		  dim cursorTime as double		  		  'gLog "getExactStimulus method of Data class"		  		  cursorTime = cursor1.t		  		  upperLimit = uBound(mStimuli)		  for i = 0 to upperLimit		    if cursorTime > mStimuli(i).value("onsetTime") and cursorTime < mStimuli(i).value("offsetTime") then		      closestStimulusIndex = i		      exit		    end if		  next		  		  //  return nil if the cursor is not located over any stimulus		  if closestStimulusIndex > -1 and closestStimulusIndex <= uBound(mStimuli) then		    mStimuli(closestStimulusIndex).value("number") = closestStimulusIndex		    return mStimuli(closestStimulusIndex)		  else		    return nil		  end if		  		exception err		  gHandleException err, "getExactStimulus method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function getLatencyAtFirstCursor(chooseAdjoiningStimulus as integer) As double		  // returns the latency between the time at cursor 1 and the nearest stimulus to that time		  		  dim currStimulus as stimulus		  dim latency as double		  		  currStimulus = self.getStimulusForCurrentTrial(chooseAdjoiningStimulus)		  		  if currStimulus <> nil then		    		    return (mCursors(0).t - currStimulus.value("onsetTime") - currStimulus.value("delay")) * 1000.0		    		  else		    		    return -99999		    		  end if		  		  		exception err		  gHandleException err, "getLatencyAtFirstCursor method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function getMovementProfiles() As dataTraceForExport()		  // returns a set of movement velocity profiles, one for each movement measured.  i.e. it returns an array of dataTraceForExport instances,		  // each of which gives the velocity values and zero based time values from the first cursor position of that measurement to the last.		  // this will allow the superimposition of many movement profiles in external graphing software.		  		  dim profiles(-1), currentProfile as dataTraceForExport		  dim movement, sample, column, numberOfMovements, numberOfSamples, numberOfColumns, i as integer		  dim samples() as dataPoint		  dim startTime, endTime, firstTimeValue, temp as double		  dim values() as variant		  dim currentMeasurement as dictionary		  dim columnLabels(), currentLabel as string		  		  		  // can only return one or more profiles if at least one movement has been measured and stored:		  if not self.hasSaccadeData then return nil		  		  // determine what values are wanted for the profile output.		  // Currently just t and v as other properties have signs and will likely cancel depending on movement direction.		  if sourceOfData = "iView" then		    columnLabels() = array("t", "x", "y", "vx", "vy")		  else  // MoVE		    columnLabels() = array("t", "v")		  end if		  numberOfColumns = uBound(columnLabels)		  		  		  // cycle through each measured movement and get a profile from it.		  numberOfMovements = uBound(mSaccadeMeasurements)		  		  for movement = 0 to numberOfMovements		    currentMeasurement = mSaccadeMeasurements(movement)		    currentProfile = new dataTraceForExport		    		    // find the timespan of the current movement:		    select case sourceOfData		      		    case "iView"		      // start export from 100 ms before the saccade onset		      startTime = currentMeasurement.value("Stimulus onset (s)") + currentMeasurement.value("Latency (ms)")/1000.0 - 0.100		      endTime  = currentMeasurement.value("Stimulus onset (s)") + currentMeasurement.value("Cursor 3 latency (ms)")/1000.0		      // old code, based on stimulus onset		      'startTime = currentMeasurement.value("Stimulus onset (s)")		      'endTime = startTime + currentMeasurement.value("Cursor 4 latency (ms)")/1000		    case "MoVE"  // NB awkward here cos some dictionary maths doesn't obey bedmas:		      startTime = (currentMeasurement.value("Stimulus onset").doubleValue+currentMeasurement.value("Latency").doubleValue)/1000.0		      endTime = startTime + (currentMeasurement.value("Total duration").doubleValue)/1000		    end select		    		    // get all the samples within that timespan:		    samples = self.getSamplesInRange(startTime, endTime)		    numberOfSamples = uBound(samples)		    redim values(numberOfSamples)		    firstTimeValue = samples(0).getDataValue("t")		    		    // add the set number to the movement profile info:		    temp = self.number		    for i = 0 to numberOfSamples		      values(i) = temp		    next i		    currentProfile.addDataColumn("Set number", values())		    		    // and the number of the measurement		    temp = currentMeasurement.value("Stimulus number")		    for i = 0 to numberOfSamples		      values(i) = temp		    next i		    currentProfile.addDataColumn("Measurement", values())		    		    		    // get each column of data (t, x, y, ...) from the samples and store them:		    for column = 0 to numberOfColumns		      currentLabel = columnLabels(column)  // i.e. are we getting t, x, y, ...		      		      for sample = 0 to numberOfSamples		        values(sample) = samples(sample).getDataValue(currentLabel)		        // zero all time values to the onset of the movement:		        if currentLabel = "t" then values(sample) = values(sample) - firstTimeValue		      next sample		      		      // store this column of data		      currentProfile.addDataColumn(currentLabel, values())		      		    next column		    		    // store this profile:		    profiles.append currentProfile		    		  next movement		  		  return profiles		  		  		exception err		  gHandleException err, "getMovementProfiles method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function getNearestSampleToTime(soughtTime as double) As dataPoint		  // most operations are based on accessing samples by their index.  But occasionally, as in REDOing measurements, we need to go		  // the opposite way, going from a time value to get the corresponding index.		  		  dim numberOfSamples, currentSampleN, nextSampleN, lowerLimit, upperLimit as integer		  dim testValue as double		  dim sampleFound as boolean = FALSE		  dim i, foundIndex as integer		  dim currentSample as dataPoint		  		  'gLog "getNearestSampleToTime method of Data class"		  		  		  numberOfSamples = uBound(mDataPoints) + 1		  		  		  lowerLimit = 0  // set the initial lower bound of the array to search within		  upperLimit = numberOfSamples  // set the initial upper bound of the array to search within		  currentSampleN = numberOfSamples/2  // start the search half way through the list.  CurrentFrame will always be within the upper and lower limits.		  		  do		    testValue =  mDataPoints(currentSampleN).t		    		    if testValue > soughtTime then		      // if the sought time is lower than the time value of this dataPoint, change the upper limit of the search range		      // and choose the next current value to be half way between the upper and lower values		      upperLimit = currentSampleN		      currentSampleN = (upperLimit + lowerLimit)/2		    elseif testValue < soughtTime then		      lowerLimit = currentSampleN		      currentSampleN = (upperLimit + lowerLimit)/2		    else		      // the sought time is exactly this value		      sampleFound = true		    end		    		    // however, the sought time may not be exactly equal to any given data sample's time,		    // so if the process has converged, can assume the upper and lower limts are straddling the value		    if upperLimit - lowerLimit < 2 then		      sampleFound = TRUE		    end		    		    foundIndex = currentSampleN		    		  loop until sampleFound		  		  		  currentSample = mDataPoints(foundIndex)		  currentSample.n = foundIndex // we tag the returned sample with its index		  		  		  return currentSample		  		exception err		  gHandleException err, "getNearestSampleToTime method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function getNearestStimulusNumberToCursor1() As integer		  // called from the 'measure' method to get the index of the stimulus which is closest to the saccade onset		  // as indicated by the first cursor.  This stimulus is returned to the 'measure' method so that		  // stimulus related measures can be gathered.		  		  dim i, upperLimit as integer		  dim closestStimulus as integer = -1		  dim currentTest, closestTest, saccadeStart as double		  dim cursor1 as cursor		  		  'gLog "getNearestStimulus method of Data class"		  		  if uBound(mStimuli) > -1 then  // don't try this unless there are some stimuli. Returns -1 if so.		    		    cursor1 = mCursors(0)		    saccadeStart = cursor1.t		    // an initial seed value for the test of which stimulus is closest		    closestTest = abs(mStimuli(0).value("onsetTime") - saccadeStart)		    closestStimulus = 0		    		    upperLimit = uBound(mStimuli)		    for i = 1 to upperLimit		      currentTest = abs(mStimuli(i).value("onsetTime") - saccadeStart)		      if currentTest < closestTest and not mStimuli(i).displayOnly then  // don't choose any stimuli which are intended only to be drawn, not measured		        closestTest = currentTest		        closestStimulus = i		      end if		    next		    		  end if		  		  return closestStimulus		  		exception err		  gHandleException err, "getNearestStimulusNumber method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function getNearestStimulusNumberToCursor1InDirection(movementDirection as string) As integer		  // called from the 'measure' method to get the index of the stimulus which is closest to the saccade onset		  // as indicated by the first cursor.  This stimulus is returned to the 'measure' method so that		  // stimulus related measures can be gathered.		  // However, we don't just want the temporally closest stimulus, but apply the additional constraint that the stimulus		  // must be moving in the specified direction.  e.g. in a predictive test, a movement may be very early.  So we want the software to		  // choos a stimulus which is the temporally nearest one moving in the same direction.  The two constraints mean we should normally automatically		  // choose the right stimulus.  If not, modifier keys can be used to force the choice of another one.		  		  		  dim i, upperLimit as integer		  dim closestStimulus as integer = -1		  dim currentTest, closestTest, saccadeStart as double		  dim stimulusDirection as string		  dim temp as double		  dim cursor1 as cursor		  		  'gLog "getNearestStimulusNumberInDirection method of Data class"		  		  if uBound(mStimuli) > -1 then  // don't try this unless there are some stimuli. Returns -1 if so.		    		    cursor1 = mCursors(0)		    saccadeStart = cursor1.t		    		    // an initial seed value for the test of which stimulus is closest		    closestTest = abs(mStimuli(0).value("onsetTime") - saccadeStart)		    closestStimulus = 0		    		    upperLimit = uBound(mStimuli)		    for i = 1 to upperLimit		      		      // determine the horizontal direction of the stimulus		      stimulusDirection = "rightward"		      select case self.sourceOfData		      case "iView"		        if mStimuli(i).value("amplitudeX") <= 0 then stimulusDirection = "leftward"		      case "MoVE"		        temp = mStimuli(i).value("x") - mStimuli(i-1).value("x") // for some reason, not using this temp variable and putting the expression directly into an if/then causes strange results		        if temp <= 0 then stimulusDirection = "leftward"		        		      end select		      		      currentTest = abs(mStimuli(i).value("onsetTime") - saccadeStart)		      if currentTest < closestTest and stimulusDirection = movementDirection and not mStimuli(i).displayOnly then  // don't choose any stimuli which are intended only to be drawn, not measured		        closestTest = currentTest		        closestStimulus = i		      end if		    next		    		  end if		  		  		  return closestStimulus		  		exception err		  gHandleException err, "getNearestStimulusNumberInDirection method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function getNextStimulusNumberAheadOfCursor1() As integer		  // called from the 'measure' methods		  // This is specific to the memory-guided task: the target should be the first one whose ONSET follows the position of the		  // first cursor. Theoretically we could do more sophisticated things by looking at the names of the stimuli ('Flash', 'Target', etc) but these		  // weren't used systematically by Charlotte. She also had stray flash stimuli apppearing early without a specified fixation target, so can't		  // rely on order of presentation.		  // A fairly robust rule of thumb should be to look ahead for the next stimulus onset. This should generally capture the appropriate target,		  // even if the saccade is made prematurely in the delay period. If it is made after the onset of the next target, then it is no longer memory-guided		  // and shouldn't be measured.		  		  dim i, upperLimit as integer		  dim currentTest, saccadeStart as double		  		  'gLog "getNearestStimulus method of Data class"		  		  if uBound(mStimuli) > -1 then  // don't try this unless there are some stimuli. Returns -1 if so.		    		    saccadeStart = mCursors(0).t		    		    upperLimit = uBound(mStimuli)		    for i = 0 to upperLimit		      // we are looking for the first stimulus which will yield a +ve value in this test:		      // (i.e. the first stimulus whose onset occurs after the saccade start)		      currentTest = mStimuli(i).value("onsetTime") - saccadeStart		      		      if currentTest > 0 and not mStimuli(i).displayOnly then  // don't choose any stimuli which are intended only to be drawn, not measured		        		        return i // the calling method now has the index to the presumed target. It will work out the latency wrt to stimulus i-2		        		      end if		    next		    		  end if		  		  // an approriate stimulus was not found:		  return -1		  		exception err		  gHandleException err, "getNextStimulusNumberAheadOfCursor1 method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function getResponseLinkedToStimulus(selectedStimulus as stimulus) As response		  // called by the measure methods. If the task collects keyboard responses, the response message includes		  // a <TGT_ID> which indicates to which stimulus the response was associated.		  // e.g. in a set with 50 trials, there might be several stimuli per trial but only one is the salient one		  // for a saccade (the others might be distractors or fixation points). The <ID> tag of this stimulus should match that of its associated response. Non-salient stimuli		  // per trial should be tagged as <DisplayOnly> to avoid them being selected as associated with the saccade measurement.		  // Additionally, the subject may miss a response on a given trial. Explicitly linking responses and stimuli (i.e. trials)		  // ensures that the response to the next trial is not mistakenly associated as a (late) response instead of		  // correctly noticing that no response occurred.		  		  		  dim responses(), currentResponse as response		  dim i, upperLimit as integer		  		  		  // cycle through all the stimuli in this set and see whether they occur during the desired time window:		  upperLimit = uBound(mResponses)		  		  for i = 0 to upperLimit		    		    currentResponse = mResponses(i)		    		    // if a response is found which matches the ID of the stimulus, then return it		    if currentResponse.stimulus_ID = selectedStimulus.value("ID") then		      return currentResponse		    end if		    		  next i		  		  return new response // if none is found, then just return one with undefined values		  		exception err		  gHandleException err, "getResponseLinkedToStimulus method of iViewSet class."		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function getResponsesInRange(minTime as double, maxTime as double) As response()		  // returns a given range of responses for plotting etc,		  // given time values which specify the start and end of the desired range.		  // Called by the display method of the iViewSet class.		  		  dim responses(), currentResponse as response		  dim i, upperLimit as integer		  		  		  // cycle through all the stimuli in this set and see whether they occur during the desired time window:		  upperLimit = uBound(mResponses)		  		  for i = 0 to upperLimit		    		    currentResponse = mResponses(i)		    		    if currentResponse.time >= minTime and currentResponse.time <= maxTime then		      responses.append currentResponse		    end if		    		  next i		  		  return responses()		  		  		exception err		  gHandleException err, "getResponsesInRange method of iViewSet class."		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function getSaccadeData() As dictionary()		  // returns the set of saccade measurements so that they can be displayed, or exported either as an individual set		  // or collated with other sets' info in a single file.  This collation possibility is why exporting this data has been		  // moved from the iViewSet class to the iViewSession class.		  		  // NB we return cloned copies of the dictionaries, as otherwise the array would be returned byref, and could be modified		  // by other classes.  If the data is modified and needs to be updated back here in the iViewSet class, it is sent back in		  // the updateSaccadeData method.		  		  dim copyOfMeasurements() as dictionary		  dim i, upperBound as integer = 0		  		  upperBound = uBound(mSaccadeMeasurements)		  		  for i = 0 to upperBound		    copyOfMeasurements.append mSaccadeMeasurements(i).clone		  next		  		  		  return copyOfMeasurements		  		  		exception err		  gHandleException err, "getSaccadeData method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function getSamplesInRange(minTime as double, maxTime as double) As dataPoint()		  // returns a given range of dataPoints for plotting etc, using a string to specify the eye(s) wanted (see 'eyes' property)		  // and time values which specify the start and end of the desired range.		  // As time values don't correspond neatly to indices in the array of dataPoints,		  // we need to search through the dataPoints to find the samples which correspond to the		  // limits of the time range requested. This is done using  the binary search algorithm from		  // the MoVElab movie viewer to search for the entries corrresponding to the min and max times.		  // That is why there are a few odd terms like 'frame' here rather than 'sample'.		  		  dim numberOfFrames, currentFrame, nextFrame, lowerLimit, upperLimit as integer		  dim testValue, soughtTimes(1) as double		  dim frameFound as boolean		  dim i, foundIndices(1) as integer		  dim currentSample, samples() as dataPoint		  		  'gLog "getSamplesInRange method of Data class"		  		  soughtTimes(0) = minTime		  soughtTimes(1) = maxTime		  numberOfFrames = uBound(mDataPoints) + 1		  		  // have to search twice, once for the min and once for the max value to display.		  for i = 0 to 1		    lowerLimit = 0  // set the initial lower bound of the array to search within		    upperLimit = numberOfFrames  // set the initial upper bound of the array to search within		    currentFrame = numberOfFrames/2  // start the search half way through the list.  CurrentFrame will always be within the upper and lower limits.		    		    do		      testValue =  mDataPoints(currentFrame).t		      		      if testValue > soughtTimes(i) then		        // if the sought time is lower than the time value of this dataPoint, change the upper limit of the search range		        // and choose the next current value to be half way between the upper and lower values		        upperLimit = currentFrame		        currentFrame = (upperLimit + lowerLimit)/2		      elseif testValue < soughtTimes(i) then		        lowerLimit = currentFrame		        currentFrame = (upperLimit + lowerLimit)/2		      else		        // the sought time is exactly this value		        frameFound = true		      end		      		      // however, the sought time may not be exactly equal to any given data sample's time,		      // so if the process has converged, can assume the upper and lower limts are straddling the value		      if upperLimit - lowerLimit < 2 then		        frameFound = true		      end		      		      foundIndices(i) = currentFrame		    loop until frameFound		    // need to reset this flag for the second time through the loop		    frameFound = false		  next i		  		  // we tag the first and last returned samples with their indices		  // this is so that the iViewSet knows the range of samples within which the cursors operate.		  //ie, returning just the range of relevant samples, the caller has no idea which samples in the whole list of data they correspond to		  // so we send this sneaky info attached to just two samples.		  for i = 0 to 1		    mDataPoints(foundIndices(i)).n = foundIndices(i)		  next i		  		  for i = foundIndices(0) to foundIndices(1)		    currentSample = mDataPoints(i)		    samples.append(currentSample)		  next i		  		  return samples()		  		exception err		  gHandleException err, "getSamplesInRange method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function getSetInfoDisplayData() As dictionary		  // collates information about the this trial/set and returns it to be		  // displayed in the parent session's chart window.		  		  // currently, this information exists only for the MoVE data.  It will need to be added		  // for iView data at a later time.		  		  dim setInfo as new dictionary		  dim stimNumber as integer		  dim stimPosn, time1, time2, timeDiff as single		  dim velocityUnit, spatialUnit, velocityFormat, spatialFormat as string		  		  select case sourceOfData		    		  case "iView"		    setInfo.value("Type") = self.testType		    setInfo.value("Test version") = self.testVersion		    		  case "MoVE"		    setInfo.value("Type") = self.testType		    setInfo.value("Description") = self.description		    		  end select		  		  setInfo.value("Sampling rate") = str(self.sampleRate) + " Hz"		  setInfo.value("# of invalid samples") = self.numberOfInvalidPoints		  		  		  return setInfo		  		  		exception err		  gHandleException err, "getSetInfoDisplayData method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function getStimuliInRange(minTime as double, maxTime as double) As stimulus()		  // returns a given range of stimuli for plotting etc,		  // given time values which specify the start and end of the desired range.		  // Called by the display method of the iViewSet class.		  		  dim stimuli(), currentStimulus as stimulus		  dim i, upperLimit as integer		  		  'gLog "getStimuliInRange method of Data class"		  		  // cycle through all the stimuli in this set and see whether they occur during the desired time window:		  upperLimit = uBound(mStimuli)		  		  for i = 0 to upperLimit		    		    currentStimulus = mStimuli(i)		    		    if currentStimulus.value("onsetTime") >= minTime and currentStimulus.value("onsetTime") <= maxTime then		      stimuli.append currentStimulus		    elseif currentStimulus.value("offsetTime") >= minTime and currentStimulus.value("onsetTime") <= maxTime then		      stimuli.append currentStimulus		    end if		    		  next i		  		  return stimuli()		  		  		exception err		  gHandleException err, "getStimuliInRange method of iViewSet class."		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function getStimulusForCurrentTrial(chooseAdjoiningStimulus as integer = 0) As stimulus		  // Designed to reduce code duplication in the stimulus selection between the 1D and 2D measure saccade methods and to fix the memory guided target selection bug.		  // By extracting this from the measurement method, this also allows the stimulus  which would be selected given the current cursor position to be		  // highlighted.		  		  // the chooseAdjoiningStimulus parameter allows the user to change the automatically detected stimulus.  Value 0 means		  // that the saccade is measured relative to the automatically detected stimulus.  A value of -1 forces the preceding stimulus		  // to be used and +1 means the next one is selected.  This is because due to very slow or very anticipatory latencies, the		  // stimulus selection algorithm may not correctly identify the stimulus which corresponds to the movement and so the user can shift it manually.		  // This previously did not take account of the new <displayOnly> tag.		  		  const selfPacedStimulusAmplitude = 20.0		  		  dim n as integer = -1		  dim nPlusBump as integer		  dim target as stimulus		  dim saccadeDirection as string		  		  'gLog "getStimulusForCurrentTrial method of Data class"		  		  // Calculate in which direction the saccade is headed (useful for scoring performance in the self paced test, ?and maybe antisaccades as well?)		  // plus target selection in the predictive task. Take position at cursor 2 - cursor 1 (zero based):		  if mDataPoints(mCursors(1).n).x - mDataPoints(mCursors(0).n).x < 0 then		    saccadeDirection = "leftward"		  else		    saccadeDirection = "rightward"		  end		  		  		  // find the index of the stimulus which is the target of this saccade.		  // Varies by task:		  select case self.testType		    		  case "Self-paced"  // currently, these stimuli are hard wired (need to fix that), so don't attempt to fetch them		    		  case "Predictive"		    // don't just get the nearest stimulus, but the nearest one in the same direction:		    n = self.getNearestStimulusNumberToCursor1InDirection(saccadeDirection)		    		  case "Memory-guided"		    // previous code (until 16 March 2009):		    '// this is a rough-as-guts approximation: the nearest stimulus is likely the fixation for the next trial, so subtract 1 to get the target for the current trial.		    'n = self.getNearestStimulusNumber - 1		    'memoryFixationStimulus = mStimuli(n-1)		    		    // previous code (until 20 May 2009)		    '// new code still a kludge but doesn't have the evident errors in the previous lot: (but subsequently found it still didn't really work)		    '// this is still a rough-as-guts approximation: the nearest stimulus is likely the fixation for the previous trial:		    'n = self.getNearestStimulusNumberToCursor1		    '// so the actual target is the next one (but check array bounds first)		    'if uBound(mStimuli) >= n+1 then n = n+1		    		    // use a method specific to the memory-guided task to identify the target:		    n = getNextStimulusNumberAheadOfCursor1		    		  case else		    // just get the stimulus with the closest onset time		    n = self.getNearestStimulusNumberToCursor1		    		  end select		  		  // apply any shift from the user (which will usuallyy be zero) to force the stimulus to be other than the automatically chosen one:		  if self.testType <> "Self-paced"  then  // currently, this test has no defined stimuli, so don't attempt to fetch them		    		    if self.testType = "Memory-guided" then		      chooseAdjoiningStimulus = chooseAdjoiningStimulus*2 // each memory trial consists of two stimuli, so bumping needs to go two stimuli forward or back		    end if		    nPlusBump = n + chooseAdjoiningStimulus  // but in other test types just shift by one.		    		    // check that the bumped index still lies within array bounds and doesn't lead to selecting a stimulus that is for drawing only:		    		    do		      // trying to select a stimulus which is out of range or there are no stimuli:		      if nPlusBump < 0 or nPlusBump > uBound(mStimuli) then return nil		      		      // otherwise apply any shift and try to select that stimulus. As there may be a number of "display only" stimuli, we		      // must be prepared to loop up or down until we find a real one.		      if mStimuli(nPlusBump).displayOnly then		        nPlusBump = nPlusBump + chooseAdjoiningStimulus // try bumping again		      else		        n = nPlusBump // we've found a goer		        exit		      end if		    loop		    		    'if nPlusBump >= 0 and nPlusBump <= uBound(mStimuli) and not mStimuli(nPlusBump).displayOnly then		    'n = nPlusBump		    'else		    ''msgBox "You are trying to select a stimulus which is out of range.  Try again."		    'beep		    'return nil		    'end if		    		    // make copy of the selected stimulus (for all except the self-paced test, which gets a blank instance below).		    // A copy is made, as some aspects (e.g. onset in the memory task, position in the anti-saccade task) need to		    // be modified  artificially so that the same measurement calculations can be made		    // regardless of task.		    target = mStimuli(n).clone		    		  end if		  		  // set the highlighted flag of the selected stimulus (the original, not the clone) so it can be highlighted when drawn on screen.		  if n > -1 then self.highlightStimulus(n)		  		  // Calculate stimulus position and amplitude etc, depending on saccade task type		  select case self.testType		    		  case "Self-paced"		    // stimulus position & amplitude		    // NB NB NB this code is driven by a constant rather than actually listening to the real stimuli.		    // This code needs to be corrected so that the Experimenter stimulus messages are adhered to.		    // Currently, it is just assumed that the self paced stimulus amplitude is 20 deg.		    target = new stimulus		    		    if saccadeDirection = "leftward" then		      target.value("amplitudeX") = selfPacedStimulusAmplitude*-1.0		      target.value("x") = selfPacedStimulusAmplitude/-2.0		    else		      target.value("amplitudeX") = selfPacedStimulusAmplitude		      target.value("x") = selfPacedStimulusAmplitude/2.0		    end		    		    target.value("background") = "Undefined"		    target.value("number") = 0		    target.value("onsetTime") = 0.0		    target.value("offsetTime") = 0.0		    target.value("gap") = 0.0		    target.value("delay") = 0.0		    target.value("name") = ""		    		    		  case "Memory-guided"		    // the latency for this trial should be calculated from the offset of the previous fixation rather		    // than the onset of the actual target, which appears only after a delay.		    // Here we subtract 2 rather than 1, as the flash occurred after the onset of the previous fixation		    // and so we need to go one further back in the list.		    if n-2 >= 0 then		      target.value("onsetTime") = mStimuli(n-2).value("offsetTime")  // previous fixation offset		      target.value("duration") = mStimuli(n-2).value("offsetTime") - mStimuli(n-1).value("offsetTime") // time previous fixation remained on post-flash		      		      // amplitude values would also have been calculated incorrectly in the importing thread wrt the n-1 (flash) target		      // so need to recalculate those (can't assume that the testType is correctly specified at the importing stage so not worth applying this there).		      target.value("amplitudeX") = target.value("x") - mStimuli(n-2).value("x")		      target.value("amplitudeY") = target.value("y") - mStimuli(n-2).value("y")		      		    else		      target.value("onsetTime") = 99999999		    end if		    target.value("number") = n/2 // takes into account the two stimuli per trial		    		    		  case "Antisaccade", "Anti-saccade"		    // stimulus position & amplitude.		    // Check if this is an anti-saccade target, which might be specified in several ways.		    // Otherwise, it is a "return to centre" movement, and should be treated as a prosaccade:		    if inStr("target anti-saccade antisaccade", target.value("type")) > 0  then		      target.value("x") = target.value("x") * -1.0  // so invert the stimulus position		      target.value("y") = target.value("y") * -1.0		      target.value("amplitudeX") = target.value("amplitudeX") * -1.0  // and the stimulus amplitude		      target.value("amplitudeY") = target.value("amplitudeY") * -1.0		    end if		    		    		  end select		  		  // calculate the stimulus number duration of the previous stimulus		  if self.testType <> "Memory-guided" and self.testType <> "Self-paced" then		    		    target.value("number") = n		    		    if n-1 >= 0 then		      target.value("duration") = mStimuli(n-1).value("offsetTime") - mStimuli(n-1).value("onsetTime")		    else		      target.value("duration") = 0.0		    end if		    		  end if		  		  		  // return the target so that it can be analysed relative to the saccade		  return target		  		exception err		  gHandleException err, "getStimulusForCurrentTrial method of iViewSet class."		  		  		  		  		  		  		  		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function getValueForSample(key as string, n as integer) As variant		  // this method allows the return of any parameter (as specified by the key, eg, x, t, etc) for a given sample number		  		  return mDataPoints(n).getDataValue(key)		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function getValueForStimulus(key as string, n as integer) As variant		  // this method allows the return of any parameter (as specified by the key, eg, x, t, etc) for a given stimulus number		  		  return mStimuli(n).value(key)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function getZoomFactor() As integer		  return mZoomFactor		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function hasSaccadeData() As boolean		  // lets the session object query whether any saccade data exists.		  		  // NB this doesn't report whther the data has been saved, just whether it exists at all.		  // If interested in whther the data is "dirty", use hasUnsavedData		  		  if uBound(mSaccadeMeasurements) = -1 then		    return false		  else		    return true		  end if		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub highlightStimulus(n as integer)		  // set the 'highlight' flag of a specified stimulus.		  // as only one can be highlighted at a time, remove highlighting from any one which may already be selected.		  		  		  dim i, upperLimit as integer		  		  'gLog "highlightStimulus method of Data class"		  		  // unselect all stimuli		  upperLimit = uBound(mStimuli)		  for i = 0 to upperLimit		    mStimuli(i).highlighted = FALSE		  next		  		  // highlight the indicated one		  if n >= 0 and n <= upperLimit then mStimuli(n).highlighted = TRUE		  		exception err		  gHandleException err, "highlightStimulus method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub interpolateNaNs()		  // for MoVE data only, sometimes Liberty drops packets, producing samples with t,x,y,z values of NaN.		  // these need to be replaced with interpolated values as NaNs can mucjk up all sorts of things.  Such samples		  // can't just be skipped during the import stage, as this introduces high greq noise into the velocity calculation/filtering.		  		  		  dim i, upperLimit, numberOfNaNs as integer		  dim currPoint, point1, point3 as dataPoint		  dim t, x, y, z, t1, t3 as double		  		  if sourceOfData <> "MoVE" then return		  		  'gLog "interpolateNaNs method of Data class"		  upperLimit = uBound(mDataPoints) -1		  		  		  for i = 1 to upperLimit		    currPoint = mDataPoints(i)		    // currently, assume won't happen in the first or last samples (unsafe assumptions):		    t = currPoint.t		    if t <> t then // i.e. it is a NaN,		      point1 = mDataPoints(i-1)		      point3 = mDataPoints(i+1)		      t1 = point1.t		      t3 = point3.t		      // only interpolate if the flanking values are both not NaNs, or else we end up propagating NaNs through the data.		      if t1 = t1 and t3 = t3 then		        currPoint.t = (point1.t + point3.t)/2		        currPoint.x = (point1.x + point3.x)/2		        currPoint.y = (point1.y + point3.y)/2		        currPoint.z = (point1.z + point3.z)/2		        currPoint.valid = true // now it has some valid, if invented, data		      end if		    end if		  next		  		exception err		  gHandleException err, "interpolateNaNs method of Data class."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function lastSampleTime() As double		  // returns the time value of the last sample (so calling objects can learn how long the recording is).		  		  return mDataPoints(uBound(mDataPoints)).t		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub manualRecalibration(reset as boolean, A() as double, B() as double, applyToAllSets as boolean, component as string)		  		  // recalibrate the data by either multiplying by a slope factor and adding an offset, or by removing any such applied equation.		  // if the calibration needs to be applied to all sets rather than just this one, pass the message up the chain to the iViewSession,		  // which will pass the message back to all sets, including this one, individually.		  		  // for 1D calibration, A(1) holds the two slope values, while B(1) holds the two offset values.		  // for 2D calibration, A(5) holds the coefficients to transform horizontal data, while B(5) holds those for vertical		  		  mParentSession.displayProgressInfo("Recalibrating data." )		  		  		  dim i, upperLimit as integer		  dim x, y as double		  		  if applyToAllSets then		    mParentSession.manualRecalibration(reset, A, B, applyToAllSets, component)		    return		  end if		  		  		  'gLog "manualRecalibration method of Data class"		  		  upperLimit = uBound(mDataPoints)		  		  if reset then		    // go back to the original data		    		    if mDataPoints(0).originalDataHasBeenStored then		      for i = 0 to upperLimit		        mDataPoints(i).resetToOriginalData		      next		      // need to reapply the filter as this is now raw data again		      self.filter mAppliedFilter  // this method also recalculates the velocities		    end if		    		  else  // apply the new calibration factors		    		    select case component		      		    case "horizontal"		      for i = 0 to upperLimit		        mDataPoints(i).x = mDataPoints(i).x * A(0) + B(0)		      next		      		    case "vertical"		      for i = 0 to upperLimit		        mDataPoints(i).y = mDataPoints(i).y * A(1) + B(1)		      next		      		    case "2D"		      		      for i = 0 to upperLimit		        x = mDataPoints(i).x		        y = mDataPoints(i).y		        		        mDataPoints(i).x = A(0) + A(1)*x + A(2)*y + A(3)*x*y +A(4)*x*x + A(5)*y*y		        mDataPoints(i).y = B(0) + B(1)*x + B(2)*y + B(3)*x*y +B(4)*x*x + B(5)*y*y		        		      next		      		    end select		    		    // NB don't need to refilter as this transformation is being applied to already filtered data.		    // Do however, need to recalculate the velocities		    self.calculateVelocities		    		  end if		  		  // let the calibration instance know the data has been transformed.		  // This is because the calibration can be applied manually and therefore the semi-automatic calibrator		  // would be out of sync with the current state of the data.		  if mPostHocCalibration <> nil then mPostHocCalibration.fetchUpdatedPointsFromSet		  		  self.dirty = TRUE		  if self.currentlySelected then mParentSession.displaySet  // only if this set is the currently visible one, redraw it.		  		exception err		  gHandleException err, "manualRecalibration method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub matchCursorToTime(cursor as cursor, time as double)		  // used when REDOing measurements.  Have a desired time from a previous measurement, and need to shift a given cursor to that time		  // and corresponding sample index value so a measurement can be re-done at the same place.		  		  dim sample as dataPoint		  		  sample = getNearestSampleToTime(time)		  cursor.n =  sample.n		  cursor.t = sample.t		  		exception err		  gHandleException err, "matchCursorToTime method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function measure(chooseAdjoiningStimulus as integer = 0) As dictionary		  // this method is called in response to the user pushing 'enter' or 'return' to take measurements from the current cursor positions.		  // the chooseAdjoiningStimulus parameter allows the user to change the automatically detected stimulus.		  // This is because, due to very slow or very anticipatory latencies, the		  // stimulus selection algorithm may not identify the stimulus which corresponds to the movement. Value 0 means		  // that the saccade is measured relative to the automatically detected stimulus.  A value of -1 forces the preceding stimulus		  // to be used and +1 means the next one is selected.		  // We collate the information required from the corresponding data samples		  // and appropriate stimuli to send back a dictionary containing the statistics for this measurement.		  // this dictionary is then sent to the measurementWindow, in which the user may amend some of the entries.		  		  dim alert as new messageDialog		  dim btn as messageDialogButton		  dim currStimulus as stimulus		  dim measurements as dictionary		  		  if not self.postHocCalibrationMode then // take a measurement		    		    // can only make measurements if we know what the stimulus does in a particular task:		    if self.testType = "" then		      alert.Message = "A test type needs to be assigned before measurements can be made.  Please choose one."		      btn = alert.showModalWithin(mParentSession.parentWindow)		      return nil		    else		      		      select case sourceOfData		        		      case "iView"		        		        if self.analyse2D then		          measurements = measureSaccade2D(chooseAdjoiningStimulus)		        else		          measurements = measureSaccade1D(chooseAdjoiningStimulus)		        end if		        		      case "MoVE"		        measurements = measureArmMovement(chooseAdjoiningStimulus)		        		      end select		      		      		      return measurements  // return the measurements to the calling session object,		      // which displays a window for the user to validate the measurement and add it to the list if OK.		      // The session object also adds a few pieces of info that it knows about (subject sex, ID, group, etc).		      		    end if		    		  else  // we are in calibration mode, so send a dictionary containing the relevant data and stimulus information for that process:		    // the session object 'calls' this method and doesn't itself expect anything back when in calibration mode (it does expect a return		    // when measuring so that it can display the measurement data).		    		    		    currStimulus = self.getExactStimulus(mCursors(0))		    if currStimulus <> nil then  // only send on data if there was a valid stimulus at the selected time		      measurements = new dictionary		      measurements.value("stimulus") = currStimulus		      measurements.value("dataPoint") = self.getDataPointAtIndex(mCursors(0).n)		      mPostHocCalibration.addPoint(measurements)		    end if		    		    		  end if		  		exception err		  gHandleException err, "measure method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function measureArmMovement(chooseAdjoiningStimulus as integer = 0) As dictionary		  // the data object is sent the set of cursors.  It then collates the information required from the corresponding data samples		  // and appropriate stimuli to send back a dictionary containing the statistics for this measurement.		  // this dictionary is then sent to the measurementWindow, in which the user may amend some of the entries.		  // the chooseAdjoiningStimulus parameter allows the user to change the automatically detected stimulus.  Value 0 means		  // that the saccade is measured relative to the automatically detected stimulus.  A value of -1 forces the preceding stimulus		  // to be used and +1 means the next one is selected.  This is because, due to very slow or very anticipatory latencies, the		  // stimulus selection algorithm may not identify the stimulus which corresponds to the movement.		  		  dim samples() as dataPoint		  dim stats as new dictionary		  dim i, n, startN, endN as integer = 0		  dim peakVelocity, currentVelocity, prevInterval, nextInterval as double = 0		  dim priErrAmpl, finalErrAmpl as double = 0		  dim priGain, priAmpl, finalAmpl, stimulusAmpl, latency, stimulusOnset, stimulusGap, timeOfPeakVelocity, totalDuration, primaryDuration, correctionTime as double = 0		  dim initialDirectionalErrorVmax, initialDirectionalError80ms, pathLength as double = 0		  dim previousPosition, currentPosition, tempVec as OxMVector3		  dim destinationStimulusPosition, startStimulusPosition, primaryDisplacement, finalDisplacement as OxMVector3		  dim targetVector, pathVector, armPositionAtStart, positionAtMaxVelocity, positionAt80ms as OxMVector3		  dim nearestStimulus, prevStimulus as stimulus		  dim saccadeLeftward as boolean		  dim stimulusNumber, stimulusType, stimulusDuration, saccadeDirection as string		  dim temp as double		  		  'gLog "measureArmMovement method of Data class"		  		  // get the data sample corresponding to each cursor		  for i = 0 to uBound(mCursors)		    samples.append mDataPoints(mCursors(i).n)		  next		  		  // cycle through to find the peakVelocity between cursors 1 & 2		  startN = mCursors(0).n		  endN = mCursors(1).n		  		  peakVelocity = 0		  for i = startN to endN		    if mDataPoints(i).v > peakVelocity then		      peakVelocity = mDataPoints(i).v		      timeOfPeakVelocity = mDataPoints(i).t - mCursors(0).t		      positionAtMaxVelocity = mDataPoints(i).vector		    end if		  next		  		  		  // cycle through to integrate the path length		  startN = mCursors(0).n		  endN = mCursors(3).n		  previousPosition = mDataPoints(startN).vector		  		  for i = startN to endN		    currentPosition = mDataPoints(i).vector		    tempVec = currentPosition - previousPosition		    pathLength = pathLength + tempVec.length		    		    previousPosition = currentPosition		  next		  		  		  		  // Calculate in which direction the movement is headed (useful for scoring performance in the self paced or predictive tests)		  // Only useful for 1D tasks.		  if samples(1).x - samples(0).x < 0 then		    saccadeLeftward = true		    saccadeDirection = "leftward"		  else		    saccadeLeftward = false		    saccadeDirection = "rightward"		  end		  		  		  // Calculate stimulus position and amplitude, depending on  task type		  select case self.testType		    		  case "Self-paced"		    // stimulus position & amplitude		    if saccadeLeftward then		      destinationStimulusPosition = mStimuli(1).positionVector		      startStimulusPosition = mStimuli(2).positionVector		    else		      destinationStimulusPosition = mStimuli(2).positionVector		      startStimulusPosition = mStimuli(1).positionVector		    end		    tempVec = destinationStimulusPosition - startStimulusPosition		    stimulusAmpl =tempVec.length		    		    		  case "Predictive"		    // find the stimulus which is nearest the onset of this saccade (ie the first cursor) AND moving in the same direction		    n = self.getNearestStimulusNumberToCursor1InDirection(saccadeDirection)		    // apply any shift from the user to force the stimulus to be other than the automatically chosen one:		    if n + chooseAdjoiningStimulus >= 0 and n + chooseAdjoiningStimulus <= uBound(mStimuli) then		      n = n + chooseAdjoiningStimulus		    else		      msgBox "You are trying to select a stimulus which is out of range.  Try again."		      return nil		    end if		    nearestStimulus = mStimuli(n)		    		    // stimulus position & amplitude		    destinationStimulusPosition = nearestStimulus.positionVector		    if n = 0 then  // n is the stimulus index number		      prevStimulus = new stimulus		      prevStimulus.value("x") = 0.0		      prevStimulus.value("x") = 0.0		      prevStimulus.value("x") = 0.0		      startStimulusPosition = prevStimulus.positionVector		    else		      startStimulusPosition = mStimuli(n-1).positionVector		    end if		    tempVec = destinationStimulusPosition - startStimulusPosition		    stimulusAmpl = tempVec.length  // the difference between this stimulus and the previous one		    		    		    		  case "Ballistic", "Visual", "Memory"  // these are fixed, "discrete" trials of only one movement.  The target is always the 2nd stimulus to appear (after the home stimulus)		    // stimulus position & amplitude		    n = 1		    nearestStimulus = mStimuli(n)		    destinationStimulusPosition = nearestStimulus.positionVector		    startStimulusPosition = mStimuli(n-1).positionVector		    tempVec = destinationStimulusPosition - startStimulusPosition		    stimulusAmpl = tempVec.length  // the difference between this stimulus and the previous one		    		  case else		    msgBox "Analysis of this test hasn't been implemented yet."		    return nil		    		  end select		  		  // for all task types, the primary gain equation is the same as the differing stimulus amplitudes have been calculated above:		  primaryDisplacement = samples(1).vector - samples(0).vector		  priAmpl = primaryDisplacement.length  // amplitude of the primary movement		  tempVec = samples(3).vector - samples(0).vector		  finalAmpl =tempVec.length  // total amplitude of the primary saccade + corrective saccade(s)		  priGain = priAmpl/stimulusAmpl  // primary movement gain		  primaryDuration = mCursors(1).t - mCursors(0).t  // duration of primary movement		  correctionTime = mCursors(2).t - mCursors(0).t  // when third cursor is placed, i.e. the time at which any discrete corrective movements begin, following the pri movt.		  totalDuration = mCursors(3).t - mCursors(0).t  // time from beginning of pri movt until all corrections have been completed		  tempVec = samples(1).vector - destinationStimulusPosition		  priErrAmpl =  tempVec.length		  tempVec = samples(3).vector - destinationStimulusPosition		  finalErrAmpl =  tempVec.length		  		  // initial directional error (based on Contreras-Vidal & Buch 2003).  Angle between vector linking the start point of the trajectory to the point at start + 80 ms		  // (so that vision hasn't had a chance to be used in feedback) and the vector linking the start position and the destination target.		  armPositionAtStart = samples(0).vector		  // get the position at 80 ms after the start, which will generally be 19 samples after the start sample (i.e. 240 Hz * 0.080 s)		  // NB not doing bounds checking here, so could problems.		  positionAt80ms = mDataPoints(startN + round(self.sampleRate * 0.080)).vector		  // now link the relevant positions and find the angle between the vectors:		  targetVector = destinationStimulusPosition - armPositionAtStart		  pathVector = positionAt80ms - armPositionAtStart		  initialDirectionalError80ms = acos(targetVector.dotProduct(pathVector)/(targetVector.length*pathVector.length)) *180/gPi  // Fraleigh & Beauregard p. 136		  // initial directional error can also be defined as the angle to the point at which max velocity occurs (as per Scheidt et al 2005, but again with the vectors		  // defined as beginning at the start arm position rather than the start stimulus position, which is what Scheidt uses)		  pathVector = positionAtMaxVelocity - armPositionAtStart		  initialDirectionalErrorVmax = acos(targetVector.dotProduct(pathVector)/(targetVector.length*pathVector.length))  *180/gPi  // Fraleigh & Beauregard p. 136		  		  		  // stimulus number & type etc (undefined for self paced task)		  if self.testType = "Self-paced" then		    stimulusNumber = ""		    stimulusType = ""		    stimulusDuration = ""		    stimulusOnset = mStimuli(1).value("onsetTime")*1000.0		    latency =  (mCursors(0).t - mStimuli(1).value("onsetTime")) *1000.0		    stimulusGap = 0		    		  else  // for all other tests		    stimulusNumber = format(n, "####")		    stimulusType = nearestStimulus.value("type")		    // stimulus duration: NB it is the previous stimulus duration that is of interest as the duration of the stimulus towards which the movement is directed		    // cannot influence the current movement.		    if n > 0 then		      stimulusDuration = format(((mStimuli(n-1).value("offsetTime") - mStimuli(n-1).value("onsetTime")) * 1000.0), "#")  // integer ms		    else		      stimulusDuration = "0"  // ms		    end if		    stimulusOnset = nearestStimulus.value("onsetTime")*1000.0		    latency = (mCursors(0).t - nearestStimulus.value("onsetTime"))*1000.0		    stimulusGap = nearestStimulus.value("gap")*1000.0		  end if		  		  		  // collect all the statistics into a dictionary wihich will be sent to the user for validation		  stats.value("Session label") = mParentSession.label		  stats.value("Date") = mParentSession.date		  stats.value("Group") = mParentSession.subject_group		  stats.value("Subject ID") = mParentSession.subject_id		  stats.value("Sex") = mParentSession.subject_sex		  stats.value("Primary sensor") = mParentSession.primarySensor		  stats.value("Phase") = self.phase		  stats.value("Feedback visible") = self.movementFeedbackVisible		  stats.value("Gain applied to feedback") = self.movementFeedbackGain		  stats.value("Trial number") = format(self.number, "###")  // integer		  stats.value("Trial type") = self.testType  // string		  stats.value("Stimulus number") = stimulusNumber  // string		  stats.value("Stimulus type") = stimulusType  // string		  stats.value("Stimulus amplitude") = format(stimulusAmpl, "-###.0000")		  stats.value("Prior stimulus duration") = stimulusDuration  // string, integer ms		  stats.value("Stimulus gap") = format(stimulusGap, "-#")  // integer ms		  stats.value("Stimulus onset") = format(stimulusOnset, "#")  // integer ms		  stats.value("Latency") = format(latency, "-#")  // integer ms		  stats.value("Primary duration") = format(primaryDuration*1000.0, "#")  // integer ms		  stats.value("Correction time") = format(correctionTime*1000.0, "#")  // integer ms		  stats.value("Total duration") = format(totalDuration*1000.0, "#")  // integer ms		  stats.value("Time to peak velocity") = format(timeOfPeakVelocity*1000.0, "#")  // integer ms		  stats.value("Peak velocity") = format(peakVelocity, "-#.0000")  // m/s		  stats.value("Primary amplitude") = format(priAmpl, "-##0.0000")  // m		  stats.value("Final amplitude") = format(finalAmpl, "-##0.0000")  // m		  stats.value("Primary gain") = format(priGain, "-##0.0000")  // 3 dp		  stats.value("Final gain") = format(finalAmpl/stimulusAmpl, "-##0.0000")  // 3 dp		  stats.value("Primary PEA") = format(abs(stimulusAmpl-priAmpl)/stimulusAmpl * 100.0, "-###0.000")		  stats.value("Final PEA") = format(abs(stimulusAmpl-finalAmpl)/stimulusAmpl * 100.0, "-###0.000")		  stats.value("Primary error amplitude") = format(priErrAmpl, "##0.0000")		  stats.value("Final error amplitude") = format(finalErrAmpl, "##0.0000")		  stats.value("Target X") = format(destinationStimulusPosition.X, "-###.0000")		  stats.value("Target Y") = format(destinationStimulusPosition.Y, "-###.0000")		  stats.value("Target Z") = format(destinationStimulusPosition.Z, "-###.0000")		  stats.value("Start X") = format(samples(0).vector.X, "-###.0000")		  stats.value("Start Y") = format(samples(0).vector.Y, "-###.0000")		  stats.value("Start Z") = format(samples(0).vector.Z, "-###.0000")		  stats.value("Primary X") = format(samples(1).vector.X, "-###.0000")		  stats.value("Primary Y") = format(samples(1).vector.Y, "-###.0000")		  stats.value("Primary Z") = format(samples(1).vector.Z, "-###.0000")		  stats.value("Final X") = format(samples(3).vector.X, "-###.0000")		  stats.value("Final Y") = format(samples(3).vector.Y, "-###.0000")		  stats.value("Final Z") = format(samples(3).vector.Z, "-###.0000")		  stats.value("Comment") = ""		  stats.value("Path length") = format(pathLength, "-###.0000")		  stats.value("IDE Vmax") = format(initialDirectionalErrorVmax, "-###.0000")		  stats.value("IDE 80ms") = format(initialDirectionalError80ms, "-###.0000")		  		  		  // return the dictionary of measured statistics from this saccade		  return stats		  		exception err		  gHandleException err, "measureArmMovement method of Data class."		  		  		  		  		  		  		  		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function measureREDO() As string		  // ReDo all the existing measurements in the set. This allows data to be updated when, for example, we want to add a new dependent variable		  // to existing measurements or if there was a bug in previous measurements, filtering was incorrect, etc. It will cycle through each existing		  // measurement, shift the cursors to their recorded timepoints, and re-measure, being careful to extract the human-generated data from the		  // previous one (such as comments or when another stimulus was selected rather than the default).		  // Called by session.measureREDO		  // a sucessful measurement is indicated by returning the string "OK".  Otherwise return a string containing the error cause.		  		  dim alert as new messageDialog		  dim btn as messageDialogButton		  dim autoStimulus as stimulus		  dim measurements as dictionary		  dim i, j, chooseAdjoiningStimulus, numberOfMeasurements, numberOfCursors, sampleNumber as integer		  dim time as double		  dim existingMeasurement as dictionary		  dim replacementMeasurement as new dictionary		  dim sample as dataPoint		  		  		  		  // can only make measurements if we know what the stimulus does in a particular task:		  if self.testType = "" then return "A test type needs to be assigned before measurements can be made.  Please choose one."		  		  // begin cycling through the existing measurements and replacing them		  numberOfCursors = uBound(mCursors)		  numberOfMeasurements = uBound(mSaccadeMeasurements)		  		  for i = 0 to numberOfMeasurements		    		    existingMeasurement = mSaccadeMeasurements(i)		    		    // set the positions of the cursors to match those previously chosen manually for this measurement:		    self.matchCursorToTime(mCursors(0), val(existingMeasurement.value("Stimulus onset (s)")) + val(existingMeasurement.value("Latency (ms)"))/1000.0)		    		    if self.analyse2D then		      self.matchCursorToTime(mCursors(1), mCursors(0).t + val(existingMeasurement.value("Saccade duration (ms)"))/1000.0)		    else		      self.matchCursorToTime(mCursors(1), mCursors(0).t + val(existingMeasurement.value("Duration (ms)"))/1000.0)		    end if		    		    for j = 2 to numberOfCursors  // can vary, currrently for MoVE data only		      self.matchCursorToTime(mCursors(j), val(existingMeasurement.value("Stimulus onset (s)"))+ val(existingMeasurement.value("Cursor " + str(j+1) + " latency (ms)"))/1000.0)		    next j		    		    		    // get the measurement that would be chosen automatically given the cursor positions:		    autoStimulus = self.getStimulusForCurrentTrial		    // then see if we need to apply a correction because the user chose the stimulus following or preceding the automatically chosen one.		    // chooseAdjoiningStimulus = 0 if use the same one, +1 for next, -1 for previous:		    chooseAdjoiningStimulus = val(existingMeasurement.value("Stimulus number")) - val(autoStimulus.value("number"))		    		    // re-do the measurement		    select case sourceOfData		      		    case "iView"		      		      if self.analyse2D then		        replacementMeasurement = measureSaccade2D(chooseAdjoiningStimulus)		      else		        replacementMeasurement = measureSaccade1D(chooseAdjoiningStimulus)		      end if		      		    case "MoVE"		      replacementMeasurement = measureArmMovement(chooseAdjoiningStimulus)		      		    end select		    		    // transfer the other human-generated data from the previous measurement		    replacementMeasurement.value("Antisaccade error") = existingMeasurement.value("Antisaccade error")		    replacementMeasurement.value("Trial type") = existingMeasurement.value("Trial type")		    replacementMeasurement.value("Comment") = existingMeasurement.value("Comment")		    		    // replace the old with the new:		    mSaccadeMeasurements(i) = replacementMeasurement		  next i		  		  return "OK"		  		exception err		  gHandleException err, "measureREDO method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function measureSaccade1D(chooseAdjoiningStimulus as integer = 0) As dictionary		  // this is the original saccade measurement routine, which is based almost purely on horizontal, 1D measurements, in use until v 3.0.2		  // in general, future studies should be designed to use the more comprehensive 2D measurement method.		  		  // in the release of 3.1, the target selection was extracted to a separate method (getStimulusForCurrentTrial) to be used by both the 1D and 2D measurement methods,		  // reducing the amount of code duplication and making this method much shorter.		  		  // a dictionary containing the statistics for this measurement is sent to the measurementWindow, in which the user may amend some of the entries.		  // the chooseAdjoiningStimulus parameter allows the user to change the automatically detected stimulus.  See the getStimulusForCurrentTrial method		  // for details.		  		  		  dim samples() as dataPoint		  dim stats as new dictionary		  dim i, n, stimulusNumber as integer		  dim peakVelocity, timeOfPeakVelocity as double		  dim priGain, priAmpl, finalAmpl, stimulusAmpl, stimulusPosn, latency, stimulusOnset as double		  dim target as stimulus		  		  'gLog "measureSaccade method of Data class"		  		  		  // select a copy of the STIMULUS appropriate to saccade onset for this type of trial, taking into account any		  // manually applied 'bump' to choose a stimulus before or after what would be automatically chosen:		  target = self.getStimulusForCurrentTrial(chooseAdjoiningStimulus)		  // if no valid target is found, return nil. Else we get into all sorts of problems		  if target = nil then return nil		  		  		  // stimulus position, amplitude, and onset time		  stimulusPosn = target.value("x")		  stimulusAmpl = target.value("amplitudeX")		  stimulusOnset = target.value("onsetTime")		  		  // get the data sample corresponding to each cursor		  for i = 0 to uBound(mCursors)		    samples.append mDataPoints(mCursors(i).n)		  next		  		  // for all saccade types, the primary GAIN equation is the same as the appropriate stimulus amplitudes have been		  // calculated in the getStimulusForCurrentTrial method (e.g., taking into account antisaccade effects):		  priAmpl = samples(1).x - samples(0).x  // amplitude of the primary saccade		  finalAmpl = samples(2).x - samples(0).x  // total amplitude of the primary saccade + corrective saccade(s)		  priGain = priAmpl/stimulusAmpl  // primary saccade gain		  		  // calculate LATENCY		  latency = self.getLatencyAtFirstCursor(chooseAdjoiningStimulus)		  		  // cycle through to find the PEAK VELOCITY between cursors 1 & 2.		  // this is based only on the horizontal component, unlike the measureSaccade2D method		  peakVelocity = 0		  for i = mCursors(0).n to mCursors(1).n		    if abs(mDataPoints(i).vx) > abs(peakVelocity) then		      peakVelocity = mDataPoints(i).vx		      timeOfPeakVelocity = mDataPoints(i).t - mCursors(0).t		    end if		  next		  		  		  // put all these and other statistics into a dictionary for passing around the application:		  stats.value("Samara version") =  str(app.longVersion)		  stats.value("Test version") = self.testVersion		  stats.value("Session label") = mParentSession.label		  stats.value("Date") = mParentSession.date		  stats.value("Group") = mParentSession.subject_group		  stats.value("Subject ID") = mParentSession.subject_id		  stats.value("Sex") = mParentSession.subject_sex		  stats.value("Set number") = format(self.number, "###")  // integer		  stats.value("Analysis type") = self.testType  // string.  Called analysis rather than testType as prosaccade analysis might be used for all sorts of tests.		  stats.value("Stimulus number") = format(target.value("number"), "####.#")  // sometimes in memory guided test, number can end in .5		  stats.value("Stimulus type") = target.value("name")  // string		  stats.value("Stimulus amplitude (deg)") = format(stimulusAmpl, "-###.0#")  // 1 or 2 dp		  stats.value("Stimulus position (deg)") = format(stimulusPosn, "-###.0#")  // 1 or 2 dp		  stats.value("Prior stimulus duration (ms)") = format(target.value("duration")* 1000.0, "#")  // integer ms		  stats.value("Stimulus gap (ms)") = format(target.value("gap")*1000.0, "-#")  // integer ms		  stats.value("Stimulus delay (ms)") = format(target.value("delay")*1000.0, "-#")  // integer ms		  stats.value("Stimulus onset (s)") = format(stimulusOnset, "####.000")  // 3 dp (s)		  stats.value("Latency (ms)") = format(latency, "-#")  // integer ms		  stats.value("Duration (ms)") = format((mCursors(1).t - mCursors(0).t)*1000.0, "#")  // integer ms		  stats.value("Amplitude (deg)") = format(samples(1).x - samples(0).x, "-##0.000")  // degrees, 3dp		  stats.value("Peak velocity (deg/s)") = format(peakVelocity, "-#")  // integer deg/s		  stats.value("Time to peak velocity (ms)") = format(timeOfPeakVelocity * 1000, "#")  // integer ms		  stats.value("Primary gain") = format(priGain, "-##0.000")  // 3 dp		  stats.value("Final gain") = format(finalAmpl/stimulusAmpl, "-####0.000")  // 3 dp		  stats.value("Primary/FEP gain") = format(priAmpl/finalAmpl, "-####0.000")  // 2-3 dp		  stats.value("Final error gain") = format(1 - ((stimulusPosn) - samples(2).x)/stimulusAmpl, "-####0.000")  // 2-3 dp		  stats.value("Primary PEA (%)") = format(abs(stimulusAmpl-priAmpl)/stimulusAmpl * 100.0, "-####0.0")		  stats.value("Initial eye position (deg)") = format(samples(0).x, "-##0.00#")  // 2-3 dp		  stats.value("Mid position (deg)") = format(samples(1).x, "-##0.00#")  // 2-3 dp		  stats.value("Final eye position (deg)") = format(samples(2).x, "-##0.00#")  // 2-3 dp		  stats.value("Cursor 3 latency (ms)") = format((mCursors(2).t - stimulusOnset)*1000.0, "-#")  // integer ms		  stats.value("Cursor 4 position (deg)") = format(samples(3).x , "-###0.00#")  // 2-3 dp		  stats.value("Cursor 4 latency (ms)") = format((mCursors(3).t - stimulusOnset)*1000.0, "-#")  // integer ms		  stats.value("Cursor 5 position (deg)") = format(samples(4).x , "-###0.00#")  // 2-3 dp		  stats.value("Cursor 5 latency (ms)") = format((mCursors(4).t - stimulusOnset)*1000.0, "-#")  // integer ms		  stats.value("Cursor 6 position (deg)") = format(samples(5).x, "-###0.00#")  // 2-3 dp		  stats.value("Cursor 6 latency (ms)") = format((mCursors(5).t - stimulusOnset)*1000.0, "-#")  // integer ms		  stats.value("Antisaccade error") = "None"		  stats.value("Trial type") = ""		  stats.value("Comment") = ""		  stats.value("Saccade count") = str(self.numberOfSaccadesBetweenFirstAndLastCursors)		  stats.value("Background") = target.value("background")		  		  // ## NB append any new dependent variables to the end of this list to preserve compatibility with importing into the same spreadsheet as previously generated files.		  		  		  // return the dictionary of measured statistics from this saccade		  return stats		  		exception err		  gHandleException err, "measureSaccade method of iViewSet class."		  		  		  		  		  		  		  		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function measureSaccade2D(chooseAdjoiningStimulus as integer = 0) As dictionary		  // this is the new saccade measurement routine, available after v 3.0.2		  // As well as providing more general 2D saccade and stimulus measures, it extracts more info from each stimulus		  // and also gives info from response events (e.g. subjects' keypresses).		  		  // a dictionary containing the statistics for this measurement is sent to the measurementWindow, in which the user may amend some of the entries.		  // the chooseAdjoiningStimulus parameter allows the user to change the automatically detected stimulus.  See the getStimulusForCurrentTrial method		  // for details.		  		  const selfPacedStimulusAmplitude = 20		  		  dim samples() as dataPoint		  dim stats as new dictionary		  dim i, startN, endN as integer = 0		  dim peakVelocity, timeOfPeakVelocity as double		  dim priGain, priAmpl, finalAmpl, stimulusAmpl, latency, stimulusOnset as double		  dim initialDirectionalErrorVmax, pathLength, stimulusOrientation, priOrientation, finalOrientation as double = 0		  dim previousPosition, currentPosition, tempVec as OxMVector3 // used in path length calculation		  dim stimulusPosn, stimulusVector, xAxis as OxMVector3		  dim positionAtMaxVelocity, primaryDisplacement, finalDisplacement as OxMVector3		  dim target as stimulus		  dim subjectResponse as response		  dim stimulusDuration as string		  		  'gLog "measureSaccade2D method of Data class"		  		  // get a copy of the STIMULUS appropriate to saccade onset for this type of trial, taking into account any		  // manually applied 'bump' to choose a stimulus before or after what would be automatically chosen:		  target = self.getStimulusForCurrentTrial(chooseAdjoiningStimulus)		  // if no valid target is found, return nil. Else we get into all sorts of problems		  if target = nil then return nil		  		  stimulusVector = target.directionVector		  stimulusPosn = target.positionVector		  		  // get the scalar STIMULUS AMPLITUDE in degrees		  stimulusAmpl = stimulusVector.length		  // and its ORIENTATION in degrees		  stimulusOrientation = stimulusVector.angleInDegreesFromXaxis		  // and ONSET TIME		  stimulusOnset = target.value("onsetTime")		  		  // calculate LATENCY		  latency = self.getLatencyAtFirstCursor(chooseAdjoiningStimulus)		  		  // get the data sample corresponding to each cursor		  for i = 0 to uBound(mCursors)		    samples.append mDataPoints(mCursors(i).n)		  next		  		  		  // for all saccade types, the PRIMARY GAIN equation is the same as the appropriate differing stimulus amplitudes have been calculated		  // in the getStimulusForCurrentTrial method:		  primaryDisplacement = samples(1).vector - samples(0).vector		  priAmpl = primaryDisplacement.length  // amplitude of the primary movement		  priOrientation = primaryDisplacement.angleInDegreesFromXaxis		  		  finalDisplacement = samples(2).vector - samples(0).vector		  finalAmpl = finalDisplacement.Length  // total distance between starting position and final eye position		  finalOrientation = finalDisplacement.angleInDegreesFromXaxis		  		  priGain = priAmpl/stimulusAmpl  // primary saccade gain		  		  		  // cycle through to find the PEAK VELOCITY between cursors 1 & 2		  startN = mCursors(0).n		  endN = mCursors(1).n		  		  peakVelocity = 0		  for i = startN to endN		    if mDataPoints(i).v > peakVelocity then		      peakVelocity = mDataPoints(i).v		      timeOfPeakVelocity = mDataPoints(i).t - mCursors(0).t		      positionAtMaxVelocity = mDataPoints(i).vector		    end if		  next		  		  		  // cycle through to integrate the PATH LENGTH, just of the primary saccade		  startN = mCursors(0).n		  endN = mCursors(1).n // was 3 in the arm measurement code		  previousPosition = mDataPoints(startN).vector		  		  for i = startN to endN		    currentPosition = mDataPoints(i).vector		    tempVec = currentPosition - previousPosition		    pathLength = pathLength + tempVec.length		    		    previousPosition = currentPosition		  next		  		  		  // get any response from the subject which is associated with the stimulus' ID value		  subjectResponse = getResponseLinkedToStimulus(target)		  		  		  // put all these and other statistics into a dictionary for passing around the application:		  // add some session level info to the measurement		  stats.value("Samara version") =  str(app.longVersion)		  stats.value("Test version") = self.testVersion		  stats.value("Session label") = mParentSession.label		  stats.value("Date") = mParentSession.date		  stats.value("Group") = mParentSession.subject_group		  stats.value("Subject ID") = mParentSession.subject_id		  stats.value("Sex") = mParentSession.subject_sex		  stats.value("Set number") = format(self.number, "###")  // integer		  stats.value("Analysis type") = self.testType  // string.  Called analysis rather than testType as prosaccade analysis might be used for all sorts of tests.		  stats.value("Stimulus number") = format(target.value("number"), "####.#")  // sometimes in memory guided test, number can end in .5		  stats.value("Stimulus type") = target.value("name")  // string		  stats.value("Stimulus comment") = target.value("comment")  // string		  stats.value("Stimulus amplitude (deg)") = format(stimulusAmpl, "-###.0#")  // 1 or 2 dp		  stats.value("Stimulus direction (deg)") = format(stimulusOrientation, "-###.00")  // 2 dp		  stats.value("Stimulus x movement (deg)") = format(stimulusVector.X, "-###.0#")  // 1 or 2 dp		  stats.value("Stimulus y movement (deg)") = format(stimulusVector.Y, "-###.0#")  // 1 or 2 dp		  stats.value("Stimulus x position (deg)") = format(stimulusPosn.X, "-###.0#")  // 1 or 2 dp		  stats.value("Stimulus y position (deg)") = format(stimulusPosn.Y, "-###.0#")  // 1 or 2 dp		  stats.value("Prior stimulus duration (ms)") = format(target.value("duration")* 1000.0, "#")  // integer ms		  stats.value("Stimulus gap (ms)") = format(target.value("gap")*1000.0, "-#")  // integer ms		  stats.value("Stimulus delay (ms)") = format(target.value("delay")*1000.0, "-#")  // integer ms		  stats.value("Stimulus onset (s)") = format(stimulusOnset, "####.000")  // 3 dp (s)		  stats.value("Latency (ms)") = format(latency, "-#")  // integer ms		  stats.value("Peak velocity (deg/s)") = format(peakVelocity, "-#")  // integer deg/s		  stats.value("Time to peak velocity (ms)") = format(timeOfPeakVelocity * 1000, "#")  // integer ms		  stats.value("Saccade duration (ms)") = format((mCursors(1).t - mCursors(0).t)*1000.0, "#")  // integer ms		  stats.value("Primary path length (deg)") = format(pathLength, "####.000")		  stats.value("Saccade count") = str(self.numberOfSaccadesBetweenFirstAndLastCursors)		  stats.value("Primary gain") = format(priGain, "-##0.000")  // 3 dp		  stats.value("Primary amplitude (deg)") = format(priAmpl, "-##0.000")  // degrees, 3dp		  stats.value("Final amplitude (deg)") = format(finalAmpl, "-##0.000")  // degrees, 3dp		  stats.value("Final gain") = format(finalAmpl/stimulusAmpl, "-####0.000")  // 3 dp		  stats.value("Primary/FEP gain") = format(priAmpl/finalAmpl, "-####0.000")  // 2-3 dp		  stats.value("Final error gain") = "needs new formula"'format(1 - ((stimulusPosn) - samples(2).x)/stimulusAmpl, "-####0.000")  // 2-3 dp		  stats.value("Primary PEA (%)") = format(abs(stimulusAmpl-priAmpl)/stimulusAmpl * 100.0, "-####0.0")		  stats.value("Initial x position (deg)") = format(samples(0).x, "-##0.00#")  // 2-3 dp		  stats.value("Initial y position (deg)") = format(samples(0).y, "-##0.00#")  // 2-3 dp		  stats.value("Mid x position (deg)") = format(samples(1).x, "-##0.00#")  // 2-3 dp		  stats.value("Mid y position (deg)") = format(samples(1).y, "-##0.00#")  // 2-3 dp		  stats.value("Final x position (deg)") = format(samples(2).x, "-##0.00#")  // 2-3 dp		  stats.value("Final y position (deg)") = format(samples(2).y, "-##0.00#")  // 2-3 dp		  stats.value("Cursor 3 latency (ms)") = format((mCursors(2).t - stimulusOnset)*1000.0, "-#")  // integer ms		  stats.value("Cursor 4 position (deg)") = format(samples(3).x , "-###0.00#")  // 2-3 dp		  stats.value("Cursor 4 latency (ms)") = format((mCursors(3).t - stimulusOnset)*1000.0, "-#")  // integer ms		  stats.value("Cursor 5 position (deg)") = format(samples(4).x , "-###0.00#")  // 2-3 dp		  stats.value("Cursor 5 latency (ms)") = format((mCursors(4).t - stimulusOnset)*1000.0, "-#")  // integer ms		  stats.value("Cursor 6 position (deg)") = format(samples(5).x, "-###0.00#")  // 2-3 dp		  stats.value("Cursor 6 latency (ms)") = format((mCursors(5).t - stimulusOnset)*1000.0, "-#")  // integer ms		  stats.value("Antisaccade error") = "None"		  stats.value("Trial type") = ""		  stats.value("Comment") = ""		  stats.value("Background") = target.value("background")		  		  stats.value("Response value") = subjectResponse.value		  stats.value("Actual") = subjectResponse.actual		  stats.value("Judgment") = subjectResponse.judgment		  stats.value("Time") = subjectResponse.time		  stats.value("Primary direction (deg)") = format(priOrientation, "-####0.00")  // 2 dp		  stats.value("Final direction (deg)") = format(finalOrientation, "-####0.00")  // 2 dp		  		  ' positionAtMaxVelocity, initialDirectionalErrorVmax etc		  		  // ## NB append any new dependent variables to the end of this list to preserve compatibility with importing into the same spreadsheet as previously generated files.		  		  		  // return the dictionary of measured statistics from this saccade		  return stats		  		exception err		  gHandleException err, "measureSaccade2D method of iViewSet class."		  		  		  		  		  		  		  		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function moveCursor(leftward as boolean, amount as integer = 1) As boolean		  dim i, j, samplesToMove, boundary, test, upperLimit as integer		  dim c as cursor		  dim changed as boolean = false		  		  'gLog "moveCursor method of iViewSet class"		  		  if amount = 1 then		    samplesToMove = amount // ie move by one sample (default)		  else		    // move by a proportion of the data range displayed. e.g. or by 1/15th when the ctrl key is held down, 1/45th when shift is held		    samplesToMove = (mHighestSampleNumDisplayed-mLowestSampleNumDisplayed)/amount		  end		  		  if  leftward then		    boundary = mLowestSampleNumDisplayed		    samplesToMove = -1 * samplesToMove		  else		    boundary = mHighestSampleNumDisplayed		  end if		  		  upperLimit = uBound(mCursors)		  		  for i = 0 to upperLimit		    c = mCursors(i)		    if c.selected then  // only selected cursor(s) should move		      		      test = boundary - (c.n + samplesToMove)   // check whether the new cursor position will fall outside the displayed range of samples		      if sign(test) <> sign(samplesToMove) then  // if the cursor will move out of range these signs will be different (eg if the direction is -ve, then the test will be 0 or +ve)		        		        if c.n <> boundary then  // if already at the boundary, do nothing, otherwise, shift the cursor to the boundary		          c.n = boundary  // eg you are trying to move up 20 samples, but there are only ten samples left to the boundary, so just jump as far as the boundary		          c.t = getValueForSample("t", c.n) // get the new time value for the sample the cursor is now on.		          changed = true  // keeps track of whether any cursor has shifted		        end if		        		      else  // we are well within the displayed data range so can just move the cursor the desired number of samples		        c.n = c.n + samplesToMove  // increment the number of the sample the cursor is over.		        c.t = getValueForSample("t", c.n) // get the new time value for the sample the cursor is now on.		        changed = true		      end		      		      // Other cursors may not be selected for movement, but nonetheless will have to move if the cursor above it would end up with a lower time value		      // That is, if cursor 2 is selected, if necessary it will 'bump' cursor 1 so that cursor 2 can never have a time value lower than cursor 1.		      for j = 0 to upperLimit		        		        if not mCursors(j).selected then  // only shift non-selected cursors, as selected cursors take care of themselves (otherwise we get anomalies and needless checks)		          		          if j < i then		            if not mCursors(j).selected then		              if mCursors(j).t > c.t then		                mCursors(j).t = c.t		                mCursors(j).n = c.n		              end if		            end if		          end if		          // now need to do the reverse check so that a lower cursor doesn't leapfrog above a higher cursor		          if j > i then		            if mCursors(j).t  < c.t then		              mCursors(j).t = c.t		              mCursors(j).n = c.n		            end if		          end if		          		        end if		        		      next		      		      		    end if		    		    		  next		  		  // cursors 4, 5, and 6 are moved rarely. They should "stick" to the next lowest cursor unless explicitly selected for independent movement.		  if upperLimit > 2 then		    for i = 3 to upperLimit		      c = mCursors(i)		      if c.lockToLowerCursor then		        c.t = mCursors(i-1).t		        c.n = mCursors(i-1).n		      end if		    next		    		  end if		  		  		  // only create new cursor drawings if they have actually moved		  if changed then mChart.plotCursors(mCursors)		  		  return changed  // whether the display needs updating for new cursor positions		  		exception err		  gHandleException err, "moveCursor method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub moveCursorsToNextMovement()		  // find the next saccade, and reposition the cursors if required.		  // This method is called by the session object.  It will then get the set to redisplay, which will be done		  // using the new cursor positions.		  		  // Alternatively, it is called by the set itself in the display method if the set		  // is being shown for the first time only.		  		  dim i, lowerBound, upperBound,  startN, endN as integer		  		  		  lowerBound = mCursors(uBound(mCursors)).n  // the lowest dataPoint from which we need to search forwards for a movement (ie the last cursor position)		  upperBound = mHighestSampleNumDisplayed		  		  if self.detectNextFastMovementInRange(lowerBound, upperBound) then		    // if a movement was detected in the specified range, then lower and upperBound were modified to reflect the onset and end of the movement.		    // shift the first and second cursors to straddle the movement:		    mCursors(0).n = lowerBound		    mCursors(0).t = mDataPoints(lowerBound).t		    mCursors(1).n = upperBound		    mCursors(1).t = mDataPoints(upperBound).t		    		    // now check that no higher cursors have been leapfrogged by the second one.  If so, nudge them to have the same position.		    for i = 2 to uBound(mCursors)		      if mCursors(i).n < upperBound then mCursors(i).n = upperBound		      mCursors(i).t = mDataPoints(upperBound).t		      if i > 2 then mCursors(i).lockToLowerCursor = TRUE		    next		    		  else // try shifting the data along by a 3/4 a screen if a saccade was not found in the current window		    		    if mInitialised then call self.canMoveAlongTimeAxis(FALSE, 0.75)  // don't do this on the first appearance, only afterwards in response to the user wanting to detect a saccade		    self.dirty = TRUE		  end if		  		  		  		exception err		  gHandleException err, "moveCursorsToNextMovement method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function numberOfSaccadesBetweenFirstAndLastCursors() As integer		  // This is called by the measureSaccade method to count the total number of saccades (primary + corrective)		  // taken to get from the position at the first cursor to the position indicated by the last cursor.		  		  dim firstCursorSample, lastCursorSample, lowerBound, upperBound, saccadeCount as integer = 0		  dim timeThisSaccadeStarted, timePreviousSaccadeEnded as double = 0		  dim movementDetected as boolean		  		  // define the fixed bounds within which we will count saccades:		  firstCursorSample = mCursors(0).n		  lastCursorSample = mCursors(uBound(mCursors)).n		  		  // define the initial values of the changeable limits which will alter as we find saccades within the above boundaries:		  lowerBound = firstCursorSample		  upperBound = lastCursorSample		  		  // repeatedly see if we can find saccades within the interval, shifting the start point each time as required, until no more are found:		  do		    movementDetected = detectNextFastMovementInRange(lowerBound, upperBound, true)  // the optional boolean indicates we want a lower velocity threshold to catch small corrective saccades		    		    if movementDetected then		      		      timeThisSaccadeStarted = mDataPoints(lowerBound).t		      		      // to avoid false detections, such as fast overshoots at the end of a primary saccade, enforce a refractory period constraint		      // (i.e. true saccades must be separated by some minimum period, so discount any detections which are closer than this).		      // Only apply the check for the second and subsequent detections, as no previous saccade is defined for the first detected one.		      if saccadeCount = 0 then		        saccadeCount = 1		      elseif timeThisSaccadeStarted - timePreviousSaccadeEnded > 0.040 then // i.e. minimum 40 ms interval between saccade end and next one starting		        saccadeCount = saccadeCount +1		      end if		      		      // detectNextFastMovement sets lowerBound to be the onset of the movement, so we need to make the next search start from the end of the movement:		      lowerBound = upperBound		      timePreviousSaccadeEnded = mDataPoints(lowerBound).t		      // detectNextFastMovement sets upperBound to be the end of the movement, so we need to restore it to the end of the interval:		      upperBound = lastCursorSample		      		    end if		    		  loop until not movementDetected		  		  return saccadeCount		  		exception err		  gHandleException err, "moveCursorsToNextMovement method of iViewSet class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub preDisplayTasks()		  'gLog "preDisplayTasks method of iViewSet class"		  		  // this code used to be in the display() method but now extracted so that these tasks can be carried out without actually drawing the data		  // i.e. as well as being called from self.display(), it can be called elsewhere, such as from the session object when carrying out automatic re-measurement		  		  // if data hasn't been drawn yet, don't know the upper time bound, so set it here		  		  mDataDuration = self.lastSampleTime  - self.firstSampleTime // a fixed value		  mMinTimeDisplayed = self.firstSampleTime		  mMaxTimeDisplayed = self.lastSampleTime  // the initial upper bound of the displayed data		  if mMaxTimeDisplayed > 30.0 then // don't display all of a long set at first, to make things seem snappier		    mMaxTimeDisplayed = 10.0		    mZoomFactor = log(mDataDuration/10.0)/log(2) + 1.0		  end if		  		  self.filter "Butterworth"  // the first time the data needs to be displayed, carry out the default filtering		  		  		exception err		  gHandleException err, "preDisplayTasks method of iViewSet class."		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub selectCursors(cursorSelection as integer)		  // the set receives an integer (0 = "all", 1, 2, 3, ?4) from the session object when the user chooses which cursors should be selected for moving		  		  'gLog "selectCursors method of iViewSet class"		  		  dim i, upperLimit as integer		  		  upperLimit = uBound(mCursors)		  		  if cursorSelection > upperLimit + 1 then  // don't try to select a cursor higher than the number currently implemented		    beep		  else		    		    for i = 0 to upperLimit		      if cursorSelection = 0 then // select all cursors		        mCursors(i).selected = TRUE		      else		        if i+1 = cursorSelection then  // select just this cursor		          mCursors(i).selected = TRUE		          if i > 2 then mCursors(i).lockToLowerCursor = FALSE		        else		          mCursors(i).selected = FALSE  // and deselect any others		        end if		      end if		    next		    		  end if		  		  		exception err		  gHandleException err, "selectCursors method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub storeMeasurement(measurement as dictionary, autoRemeasurement as integer = - 1)		  // store the saccade measurement data for this trial in the array of other measurements.		  // If a standard, manual meaurement, simply append to the existing list.		  // If part of an automatic re-measurement, replace an existing measurement using the index supplied		  		  		  if autoRemeasurement = -1 then  // this is a manually-made measurement, so		    		    // if the user decided (in the measurementWindow instance) to accept a saccade measurement, it was sent back to this		    // set instance for storage and subsequent saving.		    mSaccadeMeasurements.append measurement		    		  else		    // we are re-processing existing measurements automatically. Rather than appending a new measurement, we must replace		    // the corresponding, previously-made, one.		    mSaccadeMeasurements(autoRemeasurement) = measurement		    		  end if		  		  self.hasUnsavedData = true		  gLogMeasurement measurement  // store the measurement in the debugLog for emergency purposes		  		  		exception err		  gHandleException err, "storeMeasurement method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub togglePostHocCalibrationMode()		  		  self.postHocCalibrationMode = not self.postHocCalibrationMode // set the flag indicating which state the set is in		  AnalysisCalibrationMode.Checked = self.postHocCalibrationMode		  		  if self.postHocCalibrationMode then		    // create a new calibrator instance, ready for input		    if mPostHocCalibration = nil then mPostHocCalibration = new postHocCalibration(self)		    mCursors(0).colour = &c000000 // Black, so users know they are in calibration mode		    CalibrationWindow.setPostHocCalibrationInstance mPostHocCalibration		    CalibrationWindow.show  // intentionally using implicit instantiation so that all interested parties can communicate with it.		    		  else		    mCursors(0).colour = &c39A50E // Green: back in normal mode		    CalibrationWindow.hide		  end if		  		  mParentSession.displaySet  // tell the session to redraw this set so that the new cursor colour is seen immediately.		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub updateSaccadeData(measurements() as dictionary)		  // called (by the iViewSession) when the the set of saccade measurements has been edited by the user in the DataWindow		  		  mSaccadeMeasurements = measurements		  self.hasUnsavedData = true		  		  		exception err		  gHandleException err, "updateSaccadeData method of iViewSet class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub writeMeasurementsToFile(fileStream as textOutputStream, writeColumnHeaders as boolean = true)		  // called by the saveSaccadeData method of the iViewSession class to write the dictionary(ies) of measurements to a file.		  // writeColumnHeaders indicates whether this is the first (or only) set of measurements, in which case		  // a label describing the column contents should be written as the first row.		  		  dim currMeasure as dictionary		  dim i, currRow, currColumn, numColumns, numRows as integer		  dim currLine, fileName as string		  dim tab as string = chr(9)		  		  		  numRows = uBound(mSaccadeMeasurements)  // how many measurements there are (-1)		  numColumns = mSaccadeMeasurements(0).Count -1 // how many 'fields' are in each measurement		  		  		  // first produce a 'header' containing labels for each column if required:		  if writeColumnHeaders then		    for i = 0 to numColumns		      currLine = currLine + mSaccadeMeasurements(0).key(i) + tab		    next i		    fileStream.writeline currLine   // automatically appends an end of line character		  end if		  		  // now export each row of values		  for currRow = 0 to numRows		    currLine = ""		    currMeasure = mSaccadeMeasurements(currRow)		    for currColumn = 0 to numColumns		      currLine = currLine + currMeasure.value(currMeasure.key(currColumn)) + tab		    next		    fileStream.writeline currLine  // automatically appends an end of line character		  next		  		  self.hasUnsavedData = false		  		exception err		  gHandleException err, "writeMeasurementsToFile method of iViewSet class."		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub zoomTimeAxis(zoomFactor as integer)		  // called by the iViewSet class to zoom the data in or out.		  // the range of data displayed is determined by 1/(2^(z-1)), where z is the zoom factor		  // (ie, a zoom factor of 1 displays all remaining data from the current minimum time to the end		  // of the recording, whereas larger values display smaller intervals).		  dim range as single		  		  'gLog "zoomTimeAxis method of iViewSet class"		  		  if zoomFactor = 1 then		    // display all the data		    mMinTimeDisplayed = self.firstSampleTime		    mMaxTimeDisplayed = self.lastSampleTime		  else		    // keep the current minumum displayed value, but expand or contract the range of values beyond that as required		    range = mDataDuration - mMinTimeDisplayed		    range = range/(pow(2,zoomFactor-1))		    		    // don't let the zooming mean that we attempt to display data that is outside the the bounds of the data itself		    if mMinTimeDisplayed + range > mDataDuration then		      mMaxTimeDisplayed = mDataDuration		    else		      mMaxTimeDisplayed = mMinTimeDisplayed + range		    end if		    		  end if		  		  // store the current zoomFactor		  mZoomFactor = zoomFactor		  		  self.dirty = TRUE		  		exception err		  gHandleException err, "zoomTimeAxis method of iViewSet class."		End Sub	#tag EndMethod	#tag Note, Name = About		This class represents a 'set' of data, which is a collection of eye data and stimuli associated with a set of one or more trials. 		It is named to reflect the concept of the iView 'set' but has now been generalised to deal with equivalent data from the MoVElab.		In MoVE data, a 'set' is equivalent to everything that occurs between the <trial> tags in the MoVE XML configuration files.  		So a set viewed from MoVE data may contain a single movement or many movements, depending on how the test was defined.				When the set is created, the importing thread tells the set from where it has been sourced  (i.e. either "iView" or "MoVE") so that 		source specific allowances can be made where needed.	#tag EndNote	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mAnalyse2D			End Get		#tag EndGetter		#tag Setter			Set			  if mAnalyse2D <> value then self.dirty = true // needs to be redrawn			  			  mAnalyse2D = value			  			  'if self.initialised then			  'self.dirty = true			  'end if			End Set		#tag EndSetter		analyse2D As boolean	#tag EndComputedProperty	#tag Property, Flags = &h0		#tag Note			A public property that states whether the analysis type (2D or 1D) was explicitly specified when imported.			If not, it will be set to the value of the first set (treated as a defualt) when added to a session.		#tag EndNote		analysisTypeSpecified As boolean = FALSE	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mBinocular			End Get		#tag EndGetter		#tag Setter			Set			  mBinocular = value			End Set		#tag EndSetter		binocular As boolean	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Note			Allows the set to know if it is the one that is currently displayed (set by the iViewSession object). The set needs to know this so that it knows if it			needs to be redrawn immediately in response to recalibration (sets can be recalibrated even though not currently displayed).		#tag EndNote		#tag Getter			Get			  return mCurrentlySelected			End Get		#tag EndGetter		#tag Setter			Set			  mCurrentlySelected = value			End Set		#tag EndSetter		currentlySelected As boolean	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Note			A more verbose description of the set if available (eg 'predictive 750 ms')		#tag EndNote		#tag Getter			Get			  return mDescription			End Get		#tag EndGetter		#tag Setter			Set			  mDescription = value			End Set		#tag EndSetter		description As string	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Note			Indicates that the set needs recalculating next time it is displayed (instituted when bulk re-calibrating across all sets, where changes			are applied to sets which are not currently being displayed).		#tag EndNote		#tag Getter			Get			  // Indicates that the set needs recalculating next time it is displayed (instituted when bulk re-calibrating across all sets, where changes			  // are applied to sets which are not currently being displayed).			  return mDirty			End Get		#tag EndGetter		#tag Setter			Set			  mDirty = value			End Set		#tag EndSetter		dirty As boolean	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mHasUnsavedData			End Get		#tag EndGetter		#tag Setter			Set			  mHasUnsavedData = value			End Set		#tag EndSetter		hasUnsavedData As boolean	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Note			// only the getter should accessible publicly.  The iViewSet itself gets and sets this value by directly accessing the			// mInitialised property		#tag EndNote		#tag Getter			Get			  return mInitialised			End Get		#tag EndGetter		#tag Setter			Set			  // there is nothing here as this should not be able to be set publicly.  The iViewSet itself sets this value by directly changing the			  // mInitialised property			End Set		#tag EndSetter		initialised As boolean	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mLastPlottedAs2D			End Get		#tag EndGetter		#tag Setter			Set			  mLastPlottedAs2D = value			End Set		#tag EndSetter		lastPlottedas2D As boolean	#tag EndComputedProperty	#tag Property, Flags = &h1		Protected mAbsStartTime As double = 0	#tag EndProperty	#tag Property, Flags = &h1		Protected mAnalyse2D As boolean = FALSE	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			A string describing the filter currrently applied to the data			Values:			None			Triangular			Butterworth		#tag EndNote		Protected mAppliedFilter As string	#tag EndProperty	#tag Property, Flags = &h1		Protected mBackgroundImages() As backgroundImage	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			If sourceOfData = iView, mBinocular = true if both eyes imported.  If only one eye, = false.		#tag EndNote		Protected mBinocular As boolean = false	#tag EndProperty	#tag Property, Flags = &h1		Protected mChart As chart	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Allows the set to know if it is the one that is currently displayed (set by the iViewSession object). The set needs to know this so that it knows if it			needs to be redrawn immediately in response to recalibration (sets can be recalibrated even though not currently displayed).		#tag EndNote		Protected mCurrentlySelected As boolean = FALSE	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Populated in the sourceOfData setter method as the number of cursors depends on the sort of data being measured.		#tag EndNote		Protected mCursors() As cursor	#tag EndProperty	#tag Property, Flags = &h1		Protected mDataDuration As double	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			A 2D array containing a column of dataPoints for each eye assuming both are present.			If not, it is a 1D array.  The key to the arrangement is kept in the property 'eyes' which can have values of Left, Right, or Both			(in which case the eye is column 0 and the right eye is column 1).		#tag EndNote		Protected mDataPoints() As dataPoint	#tag EndProperty	#tag Property, Flags = &h1		Protected mDescription As string = "not set"	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Indicates that the set needs recalculating next time it is displayed (instituted when bulk re-calibrating across all sets, because changes			can be applied to sets which are not currently being displayed).		#tag EndNote		Protected mDirty As boolean = TRUE	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			This flag is set to tru the first time the data is filtered.  This allows us to avoid repeatedly doing several operations which only need to be done once, not each time filtering is altered		#tag EndNote		Protected mHasBeenFilteredBefore As boolean = false	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			keeps track of whether the list of meaurement is "dirty"		#tag EndNote		Protected mHasUnsavedData As boolean = false	#tag EndProperty	#tag Property, Flags = &h1		Protected mHighestSampleNumDisplayed As Integer	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Signals whether the set is in calibration mode or normal analysis mode.		#tag EndNote		Protected mInCalibrationMode As boolean = false	#tag EndProperty	#tag Property, Flags = &h1		Protected mInitialised As boolean = false	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Helps keep track of changes that need to be made when switching from main canvas to thumbnail view		#tag EndNote		Protected mLastPlottedAs2D As boolean = false	#tag EndProperty	#tag Property, Flags = &h1		Protected mLowestSampleNumDisplayed As Integer	#tag EndProperty	#tag Property, Flags = &h1		Protected mMaxTimeDisplayed As single	#tag EndProperty	#tag Property, Flags = &h1		Protected mMinTimeDisplayed As single = 0	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			This applies only to arm data, where the vsiaul feedback of a movement may be scaled by some value to produce adaptation.			Value = 1.0 if not gain manipulation applied.		#tag EndNote		Protected mMovementFeedbackGain As double = 1.0	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			This applies only to arm data, where the subject may be able to see visual feedback of their own movement (1) or not (0).		#tag EndNote		Protected mMovementFeedbackVisible As integer = 1	#tag EndProperty	#tag Property, Flags = &h1		Protected mNumber As Integer	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Note			This applies only to arm data, where the subject may be able to see visual feedback of their own movement (true) or not (false).		#tag EndNote		#tag Getter			Get			  return mMovementFeedbackGain			End Get		#tag EndGetter		#tag Setter			Set			  mMovementFeedbackGain = value			End Set		#tag EndSetter		movementFeedbackGain As double	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Note			This applies only to arm data, where the subject may be able to see visual feedback of their own movement (true) or not (false).		#tag EndNote		#tag Getter			Get			  return mMovementFeedbackVisible			End Get		#tag EndGetter		#tag Setter			Set			  mMovementFeedbackVisible = value			End Set		#tag EndSetter		movementFeedbackVisible As integer	#tag EndComputedProperty	#tag Property, Flags = &h0		mParentSession As iViewSession	#tag EndProperty	#tag Property, Flags = &h1		Protected mPhase As string = "not set"	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Instantiated in the first call to the postHocCalibration method.		#tag EndNote		Protected mPostHocCalibration As postHocCalibration	#tag EndProperty	#tag Property, Flags = &h0		mResponses() As response	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			An array which holds the  saccade measurements made from this set's data.			They are sent to this class by the measurementWindow when accepted by the user.		#tag EndNote		Protected mSaccadeMeasurements() As dictionary	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Sample rate of data.			Formerly defaulted to 240 Hz.  If another value is required, then it percolates down from the iViewSet object as the value is determined when			iView data is imported.						MoVE:			240 Hz						iView:			240 Hz (monocular)			350 Hz (binocular)			?50/60 (MRI)			1250 (possible future system)		#tag EndNote		Protected mSampleRate As integer	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Value = "iView" or "MoVE"			This property allows the set to know where it was imported from so that source-specific things can be done when needed.			Set by the importing thread via the setter method.		#tag EndNote		Protected mSourceOfData As string	#tag EndProperty	#tag Property, Flags = &h1		Protected mSPstimuli() As pursuitStimulus	#tag EndProperty	#tag Property, Flags = &h1		Protected mStimuli() As stimulus	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Values =						Self-paced			Prosaccade			Antisaccade		#tag EndNote		Protected mTestType As string	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			A string describing the software/test protocol/modification date used to run the test.  e.g. "PD_reflexive.py 16May2010"		#tag EndNote		mTestVersion As string	#tag EndProperty	#tag Property, Flags = &h1		Protected mZoomFactor As Integer	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mNumber			End Get		#tag EndGetter		#tag Setter			Set			  mNumber = value			End Set		#tag EndSetter		number As Integer	#tag EndComputedProperty	#tag Property, Flags = &h0		#tag Note			The importing thread keeps track of how many invalid datapoints were found during the importing process and stores the result here.		#tag EndNote		numberOfInvalidPoints As Integer	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Note			A more verbose description of the set if available (eg 'predictive 750 ms')		#tag EndNote		#tag Getter			Get			  return mPhase			End Get		#tag EndGetter		#tag Setter			Set			  mPhase = value			End Set		#tag EndSetter		phase As string	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mInCalibrationMode			End Get		#tag EndGetter		#tag Setter			Set			  mInCalibrationMode = value			End Set		#tag EndSetter		postHocCalibrationMode As boolean	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mSampleRate			End Get		#tag EndGetter		#tag Setter			Set			  mSampleRate = value			End Set		#tag EndSetter		sampleRate As Integer	#tag EndComputedProperty	#tag Property, Flags = &h0		showCursors As boolean = true	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Note			Value = "iView" or "MoVE"			This property allows the set to know where it was imported from so that source-specific things can be done when needed.			Set by the importing thread via the setter method.		#tag EndNote		#tag Getter			Get			  return mSourceOfData			End Get		#tag EndGetter		#tag Setter			Set			  mSourceOfData = value			  mChart.sourceOfData = value // also let the chart know so it can display the data appropriately.			  			  // populate the set of cursors, depending on the source of data:			  select case value			    			  case "iView"			    redim mCursors(5)			    mCursors(0) = new cursor(&c39A50E)  // Green			    mCursors(1) = new cursor(&C30ACAC)  // Cyan			    mCursors(2) = new cursor(&CA40C05)  // Red			    mCursors(3) = new cursor(&CEE6BFD)  // Pink			    mCursors(4) = new cursor(&CEEEE00)  // Yellow			    mCursors(5) = new cursor(&CFF850E)  // Orange			    			    mCursors(3).lockToLowerCursor = TRUE  // make these rarely used cursors stick to the third cursor unless explicitly selected for individual movement.			    mCursors(4).lockToLowerCursor = TRUE			    mCursors(5).lockToLowerCursor = TRUE			    			    			  case "MoVE"			    redim mCursors(3)			    mCursors(0) = new cursor(&c39A50E)  // Green			    mCursors(1) = new cursor(&C30ACAC)  // Cyan			    mCursors(2) = new cursor(&CA40C05)  // Red			    mCursors(3) = new cursor(&CEE6BFD)  // Pink			    			    			  end select			  			  			End Set		#tag EndSetter		sourceOfData As string	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Note			Values =						Self-paced			Prosaccade			Antisaccade		#tag EndNote		#tag Getter			Get			  return mTestType			End Get		#tag EndGetter		#tag Setter			Set			  // lets the selected set know what testtype it is.  Either specified via a button in the UI or in a MSG in the iView data file.			  			  mTestType = value			  			End Set		#tag EndSetter		testType As string	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Note			A string describing the software/test protocol/modification date used to run the test.  e.g. "PD_reflexive.py 16May2010"		#tag EndNote		#tag Getter			Get			  return mTestVersion			End Get		#tag EndGetter		#tag Setter			Set			  mTestVersion = value			End Set		#tag EndSetter		testVersion As string	#tag EndComputedProperty	#tag ViewBehavior		#tag ViewProperty			Name="analyse2D"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="analysisTypeSpecified"			Group="Behavior"			InitialValue="FALSE"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="binocular"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="currentlySelected"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="description"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="dirty"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="hasUnsavedData"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="initialised"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="lastPlottedas2D"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="movementFeedbackGain"			Group="Behavior"			InitialValue="0"			Type="double"		#tag EndViewProperty		#tag ViewProperty			Name="movementFeedbackVisible"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="mTestVersion"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="number"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="numberOfInvalidPoints"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="phase"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="postHocCalibrationMode"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="sampleRate"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="showCursors"			Group="Behavior"			InitialValue="true"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="sourceOfData"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="testType"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="testVersion"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass