#tag ClassClass PostHocCalibration	#tag Method, Flags = &h0		Sub addPoint(measurement as dictionary)		  // add a dataPoint/stimulus pair to be used in the calculation (supplied by the iViewSet in response to a measurement		  // being made when it is in calibration mode).		  mData.append measurement.value("dataPoint")		  mStimuli.append measurement.value("stimulus")		  mEnabled.append true		  mHighlighted.append false		  		  // carry out the calculation on the updated data:		  self.calculate		  		  		exception err		  gHandleException err, "addPoint method of PostHocCalibration class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub applyParametersToData(reset as boolean, applyToAll as boolean, component as string)		  // if reset = true, then the offset and slope are ignored and the data is reset to its raw imported state.		  		  dim slopes(1), offsets(1), A(5), B(5) as double		  dim i as integer  // corresponds to horizontal or vertical components		  		  app.mouseCursor = system.cursors.Wait		  		  select case component		    		  case "horizontal", "vertical"		    		    for i = 0 to 1		      		      slopes(i) = 1.0/mSlope(i)		      offsets(i) = -1.0*mIntercept(i)		      		    next		    		    // apply the calculated values (or reset to raw data if reset = true).		    // the iViewSet will then message back to this instance to fetchUpdatedPointsFromSet		    // once the data has been modified so that we stay in step with the current state of the data.		    // that call has to be made from the iViewSet rather than in this method as otherwise we could		    // get out of step when calibration is applied manually rather than using this semi-auto calibration		    if mParentSet <> nil then mParentSet.manualRecalibration(reset, slopes, offsets, applyToAll, component)		    		  case "2D"		    		    self.calculate2D(A,B)  // solve the set of equations and return the values in two column arrays		    		    if mParentSet <> nil then mParentSet.manualRecalibration(reset, A, B, applyToAll, "2D")		    		  end select		  		  app.mouseCursor = system.cursors.standardPointer		  		exception err		  gHandleException err, "applyParametersToData method of PostHocCalibration class."		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub breakCircularReferences()		  mParentSet = nil		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub calculate()		  // for the purposes of the calculation below, X = the stimulus value, Y = the measured value		  		  dim i, noOfPoints, n, j as integer		  dim X, Y, sumX, sumY, sumXX, sumXY, sumYY as double		  		  // calculate sums, sums of squares, etc		  noOfPoints = ubound(mData)		  		  for j = 0 to 1  // once for x, once for y		    		    for i = 1 to noOfPoints		      		      if mEnabled(i) then  // only include selected points in the calculation		        		        n = n + 1		        		        if j = 0 then  // horizontal (x)		          X = mStimuli(i).value("x")		          Y = mData(i).x		        else  // vertical ("y")		          X = mStimuli(i).value("y")		          Y = mData(i).y		        end if		        		        sumX = sumX + X		        sumY = sumY + Y		        sumXX = sumXX + X^2		        sumYY = sumYY + Y^2		        sumXY = sumXY + X * Y		        		      end if		      		    next		    		    // calculate the parameters		    mSlope(j) = (n * sumXY - (sumX * sumY))/(n * sumXX - (sumX * sumX))		    mIntercept(j) = (sumY - (mSlope(j) * sumX))/n		    mPearson(j) = (n*sumXY - sumX * sumY)/sqrt((n * sumXX - sumX^2) * (n * sumYY - sumY^2))		    		    // these need to be zeroed so they don't carry over from x to y		    n= 0		    sumX = 0		    sumY = 0		    sumXX = 0		    sumYY = 0		    sumXY = 0		    		  next		  		  		  // send the data for output.		  // use implicit instantiation so we don't have to worry about who should hold a reference to the calibration window.		  // That way we don't have circular references and multiple PostHocCalibrationInstances can communicate with the same window:		  CalibrationWindow.plotPoints(mEnabled, mData, mStimuli, self.parameters, mHighlighted)		  		exception err		  gHandleException err, "calculate method of PostHocCalibration class."		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub calculate2D(byref Aarray() as double, byref Barray() as double)		  // for the purposes of the calculation below, X = the stimulus value, Y = the measured value		  		  dim i, noOfPoints, n, j as integer = 0		  dim eyeX, eyeY as double		  dim M, Mtrans, A, B, X, Y as matrix		  		  		  noOfPoints = ubound(mData) - 1  // as this is a one-based array		  		  // create the calculation matrix		  M = new Matrix(noOfPoints, 6)		  // create the column vectors to contain the calibration stimuli coordinates		  X = new Matrix(noOfPoints, 1)		  Y = new Matrix(noOfPoints, 1)		  		  // populate them		  for i = 0 to NoOfPoints		    		    eyeX = mData(i+1).x		    eyeY = mData(i+1).y		    		    NewElement(M, i, 0, 1.0)  // needs a first column of ones		    NewElement(M, i, 1, eyeX)		    NewElement(M, i, 2, eyeY)		    NewElement(M, i, 3, eyeX * eyeY)		    NewElement(M, i, 4, eyeX * eyeX)		    NewElement(M, i, 5, eyeY * eyeY)		    		    NewElement(X, i, 0, mStimuli(i+1).value("x"))		    NewElement(Y, i, 0, mStimuli(i+1).value("y"))		    		  next		  		  // solve for the coefficients A and B:		  Mtrans = transpose(M)		  A = inverse(Mtrans * M) * Mtrans * X		  B = inverse(Mtrans * M) * Mtrans * Y		  		  // these are returned as an array rather than a matrix to keep compatibility with other methods		  for i = 0 to 5		    Aarray(i) = A.element(i,0)		    Barray(i) = B.element(i,0)		  next		  		exception err		  gHandleException err, "calculate2D method of PostHocCalibration class."		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(parentSet as iViewSet)		  mParentSet = parentSet		  CalibrationWindow.show		  		exception err		  gHandleException err, "Constructor method of PostHocCalibration class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub enablePointAtIndex(index as integer, usePoint as boolean)		  // if true, use this point in the calculation, otherwise ignore it		  		  dim upperBound as integer		  		  upperBound = uBound(mEnabled)		  		  if index > 0 and index <= upperBound then		    mEnabled(index) = usePoint  // enable or disable this point as specified		    mHighlighted(index) = false // clicking the checkbox on or off deselects the row, so don't display a highlight ring for this point		  end if		  		  // recalculate using the amended list of selected points.		  self.calculate		  		exception err		  gHandleException err, "enablePointAtIndex method of PostHocCalibration class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub endCalibrationInResponseToCalibrationWindow()		  		  // should only be called from the calibrationWindow GUI or else we will get into infinite calling chains.		  if mParentSet <> nil then mParentSet.togglePostHocCalibrationMode		  		exception err		  gHandleException err, "endCalibrationInResponseToCalibrationWindow method of PostHocCalibration class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub fetchUpdatedPointsFromSet()		  // once calibration has been applied or reset, we need to get the updated values and recalculate the		  // regression to check that it worked.		  // the dataPoints were tagged with an index value "n" when they were originally extracted,		  // so we send that index value back to the parent set and request an updated data point.		  		  dim i, upper as integer		  		  upper = uBound(mData)		  		  if upper > 0 then  // only try if there are actually entries in this 1 based array.		    		    for i = 1 to upper		      mData(i) = mParentSet.getDataPointAtIndex(mData(i).n)		    next		    		  end if		  		  self.calculate  // redisplay the data based on the new values		  		exception err		  gHandleException err, "fetchUpdatedPointsFromSet method of PostHocCalibration class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub highlightPoint(pointNumber as integer)		  // highlight the plot point corresponding to the selected row of data.		  dim i, upper as integer		  		  upper = uBound(mHighlighted)		  		  for i = 1 to upper		    mHighlighted(i) = false		  next		  mHighlighted(pointNumber) = true		  		  // carry out the calculation on the updated data:		  self.calculate		  		  		exception err		  gHandleException err, "highlightPoint method of PostHocCalibration class."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function parameters() As dictionary()		  // return the results of the calculation (slope, intercept, r, etc) as		  // key/value pairs in a dictionary.		  // the first element of the array is for the horiontal data, the second for the vertical data.		  		  dim parameters(1) as dictionary		  dim i as integer		  		  for i = 0 to 1		    parameters(i) = new dictionary		    parameters(i).value("Slope") = mSlope(i)		    parameters(i).value("Intercept") = mIntercept(i)		    parameters(i).value("r") = mPearson(i)		  next		  		  return parameters		  		exception err		  gHandleException err, "parameters method of PostHocCalibration class."		  		End Function	#tag EndMethod	#tag Property, Flags = &h1		#tag Note			NB these arrays will be 1 based after the first point is added		#tag EndNote		Protected mData(0) As dataPoint	#tag EndProperty	#tag Property, Flags = &h1		Protected mEnabled(0) As boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected mHighlighted(0) As boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected mIntercept(1) As double	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Set so that the calibration can talk back to its parent data set, to tell it to apply calibration values, and so on.			A circular refernce so needs to be broken when necessary.		#tag EndNote		Protected mParentSet As iViewSet	#tag EndProperty	#tag Property, Flags = &h1		Protected mPearson(1) As double	#tag EndProperty	#tag Property, Flags = &h1		Protected mSlope(1) As double	#tag EndProperty	#tag Property, Flags = &h1		Protected mStimuli(0) As stimulus	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass