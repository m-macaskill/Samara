#tag ClassClass iViewParserThreadInherits Thread	#tag Event		Sub Run()		  dim dlg as OpenDialog		  dim folderDlg as selectFolderDialog		  dim f, imageFolder as FolderItem		  dim stream as TextInputStream		  		  dim fileAsArray() as string		  dim lineIndex as integer = -1		  dim currIndex as integer		  dim upperLimit as integer		  		  dim session as iViewSession		  dim currentSet as iViewSet		  dim p as dataPoint		  dim currStim, SPstim as stimulus		  dim stimulusList() as stimulus		  dim currSPstim as pursuitStimulus		  dim SPstimulusList() as pursuitStimulus		  dim currResponse as response		  dim targetDefaults as new dictionary		  dim currentLine(), temp, msgString, targetName, CurrBackgndImageFilename as string		  dim tab as string = chr(9)		  dim i, CurrentSetNumberFromFile, countOfInvalidPointsInThisSet, numberOfEyesInData, sampleRate, previousStimulusNumber as integer = 0		  dim xColumn(1), yColumn(1) as integer		  dim firstStimulusSeenAlready, leftEyeData, rightEyeData, binocularData, haveImageFolderItem as boolean = false		  dim baseTime, x, y, currentOnset, currentTime as double		  dim converter as new screenGeometry		  dim currBackGndImage as backGroundImage		  		  dim XMLMessage as XMLDocument  // the xml msg string gets parsed into an XML document and passed around to extract its info		  dim root as XMLElement  // the SAM tag for an XML message		  dim currentRootChild as XMLNode  // the TGT/CONFIG tag which is currently selected		  dim typeOfMessage as string // what sort of XML message has been received (e.g. CONFIG, TGT)		  dim rootChildCount as integer // how many TGT or CONFIG tags are nested within the SAM tag for a message		  dim itemCount, iteration as integer		  		  		  'gLog "Run event of parserThread class"		  		  dlg = new openDialog		  dlg.title="Select a .txt file created by IDF Converter"		  f = dlg.showModalWithin(mParentWindow)		  		  if f = nil then // can't do anything		    mParentWindow.displayProgressInfo("Data import cancelled.")		    return		  end if		  		  // else start importing		  mParentWindow.displayProgressInfo("Reading file into memory...")		  mParentWindow.turnProgressWheelOn(TRUE)		  session = new iViewSession		  session.sourceOfData = "iView"		  session.fileName = left(f.name, len(f.name)-4)  // allows the chartWindow to be titled with the source filename (crudely removing extension).		  session.label = session.fileName // this may be overridden later by a specific label value passed in an XML message		  		  mParentWindow.displayProgressInfo("Reading file into memory...")		  stream = f.openAsTextFile		  		  mParentWindow.displayProgressInfo("Splitting into individual lines...")		  fileAsArray = stream.readAll.split(EndOfLine.Windows)		  stream.close		  		  mParentWindow.displayProgressInfo("Processing the session...")		  do // scan through the (usually) 21 lines which form the file header.  Each line is prefixed by "##".		    		    lineIndex = lineIndex + 1		    currentLine() = split(fileAsArray(lineIndex), tab) // read the first line.		    		    select case currentLine(0)		      		    case "## Date:"		      session.date = currentLine(1)		      		    case "## Subject:", "## User:" // SMI seem to have changed to the former		      session.subject_id = RTrim(currentLine(1))  // seems to have a large number (~250) of trailing spaces		      		    case "## Sample Rate:"		      sampleRate = val(currentLine(1))		      		    case "## Calibration Area:"		      converter.pixelWidth = val(currentLine(1))  // width of screen (pixels)		      converter.pixelHeight = val(currentLine(2))  // height of screen (pixels)		      		    case "## Stimulus Dimension [mm]:"		      converter.width = val(currentLine(1))  // width of screen (mm)		      converter.height = val(currentLine(2))  // height of screen (mm)		      		    case "## Head Distance [mm]:"		      converter.distance = val(currentLine(1))  // mm eye to screen distance		      		    case "## Format:"		      // check if the format string (e.g. "LEFT, RIGHT, POR, QUALITY, MSG") specifies only one or both eyes		      if inStr(currentLine(1), "left") > 0 then		        leftEyeData = true		        numberOfEyesInData = 1		      end if		      		      if  inStr(currentLine(1), "right") > 0 then		        rightEyeData = true		        numberOfEyesInData = numberOfEyesInData + 1		      end if		      		      if numberOfEyesInData = 2 then		        binocularData = true		      end if		      		    end select		    		  loop until currentLine(0) = "## "  // the last line of the header consists of just those three characters		  		  // can now calculate other values needed for the pixel > deg calculation.		  converter.setupValues		  		  // determine what data is represented in which column.		  lineIndex = lineIndex + 1		  currentLine() = split(fileAsArray(lineIndex), tab) // The tab-separated column labels are given in row 22 of the file		  const timeColumn = 0  // the first three are fixed for all files?		  const typeColumn = 1		  const setColumn = 2		  		  // specify the columns which contains the x and y data:		  if binocularData then  // create a variable to refer to the data column for each eye		    		    xColumn(0) = currentLine.indexOf("L POR X [px]")		    yColumn(0) = currentLine.indexOf("L POR Y [px]")		    xColumn(1) = currentLine.indexOf("R POR X [px]")		    yColumn(1) = currentLine.indexOf("R POR Y [px]")		    		  else  // there is only one eye to imported.		    		    if leftEyeData then		      xColumn(0) = currentLine.indexOf("L POR X [px]")		      yColumn(0) = currentLine.indexOf("L POR Y [px]")		    else		      xColumn(0) = currentLine.indexOf("R POR X [px]")		      yColumn(0) = currentLine.indexOf("R POR Y [px]")		    end if		    		  end if		  		  // now start parsing the eye data.		  		  // make the first set		  // NB ENSURE THIS MATCHES THE CODE WITHIN THE DO LOOP BELOW WHERE EACH SUBSEQUENT SET IS CREATED		  currentSet = new iViewSet(session)		  currentSet.sampleRate = sampleRate		  currentSet.binocular = binocularData		  currentSet.addGeometry(converter)		  countOfInvalidPointsInThisSet = 0		  currentSetNumberFromFile = 1 // NB this may not always be a valid guess?? May need to address this in the future		  mParentWindow.displayProgressInfo("Processing set number " + str(currentSetNumberFromFile))		  		  lineIndex = lineIndex + 1		  currentLine() = split(fileAsArray(lineIndex), tab) // read the first line		  baseTime = val(currentLine(0)) // the baseTime is the time of the start of each set (in microseconds).  It is used to provide a zero point for the first set.		  		  upperLimit = uBound(fileAsArray)		  		  // main loop which processes each line of the file, which will either be a data sample or a message.		  for currIndex = lineIndex to upperLimit		    		    // first check if this data is from a new  set; if so, we need to store the previous one and create a new set.		    // Beware of sets labelled zero which seem to occur sometimes but usually only for one line of data?		    if currentSetNumberFromFile <> val(currentLine(setColumn)) and val(currentLine(setColumn)) <> 0 then		      		      currentSet.number = currentSetNumberFromFile  // label the set with its index number		      currentSet.numberOfInvalidPoints = countOfInvalidPointsInThisSet		      currentSet.addStimulus stimulusList  // add the current list of stimuli to the set		      currentSet.addBackgroundImage(nil, currentTime) // set the offset time of the last backGroundImage		      		      // When the first set has been imported, send the session and the first set to the window for display.		      // But will continue importing subsequent sets in the background and adding them to the stored session		      if currentSetNumberFromFile = 1 then		        mParentWindow.displayProgressInfo("Processing and plotting first trial.  Will continue importing any others in the background.")		        mParentWindow.addSession session		      end if		      session.addSet currentSet  // store the set. This needs to be done after the session is added to the window as that is how the session gets a handle to the window to pass on to the set		      		      // make a new set		      // NB ENSURE THIS MATCHES THE CODE ABOVE WHERE THE FIRST SET SUBSEQUENT SET WAS CREATED		      currentSet = new iViewSet(session)		      currentSet.sampleRate = sampleRate		      currentSet.binocular = binocularData		      currentSet.addGeometry(converter)		      countOfInvalidPointsInThisSet = 0		      currentSetNumberFromFile =  val(currentLine(setColumn))  // get the number of this new set		      mParentWindow.displayProgressInfo("Processing set number " + str(currentSetNumberFromFile))		      		      baseTime = val(currentLine(0))  // get the time at which it starts, to provide a zero for subsequent samples		      redim stimulusList(-1)  // restart the list of stimuli for the next set		      currBackgndImageFilename = ""		      		    end if		    		    // now process the current line, which will be either a sample (SMP) or message (MSG)		    currentTime = (val(currentLine(timeColumn)) - baseTime)/1000000		    		    select case currentLine(typeColumn)		      		    case "SMP" // a line with eye position sample data.		      		      // now create a new data point		      p = new dataPoint("iView", numberOfEyesInData)  // source of data = iView and 1 or 2 channels of data (i.e. eye) per sample.		      p.t = currentTime		      		      // i.e. just cycle through getting xy coordinates once for monocular or twice for binocular data as required		      for i = 1 to numberOfEyesInData		        x = val(currentLine(xColumn(i-1)))		        y = val(currentLine(yColumn(i-1)))		        // sometimes the iView POR values can be hugely outside the acceptable values (due to loss of tracking??):		        if x <= 0 or y <= 0 or x > converter.pixelWidth or y > converter.pixelHeight then		          p.valid = false  //  the eye was not being tracked in this sample		          countOfInvalidPointsInThisSet = countOfInvalidPointsInThisSet +1		        else		          p.valid = true		        end		        // even if the xy values are invalid, we take them anyway.  They won't be plotted later on.		        p.x(i-1) = converter.convertPixelsToAngle(x, true)		        p.y(i-1) = converter.convertPixelsToAngle(y, false)		        		      next		      		      // store the data point		      currentSet.addDataPoint p		      		      		    case "MSG"  // a message line		      		      // In iView files up until early 2007, the set number was missing from MSG lines.  Hence the messages appeared in the same column (2)		      // as set numbers did in other lines.  In early 2007, this was changed by SMI so that set numbers appeared in MSG lines as well, bumping		      // the messages into column 3.  So now, rather than having a fixed integer value for the message column, we test whether the set column		      // data is numeric in order to figure out in which column the message lives.  This means the user doesn't have to worry about which version		      // of file is being opened.		      if isNumeric(currentLine(setColumn)) then		        msgString = currentLine(setColumn+1)  // a new file: the message is in the next column		      else		        msgString = currentLine(setColumn) // an old file: the message is where the set number should normally be		      end if		      mParentWindow.displayProgressInfo("Processing set number " + str(currentSetNumberFromFile) + endOfLine + msgString)		      		      select case msgString.left(11)		        		      case "Scene Image"		        // not handled, as these are messages to the iView software and operator rather than directly affecting the subject.		        		      case "# Message: "		        // trim the "# Message: " prefix		        msgString = msgString.right(len(msgString) - 11)		        		        // trim "TRG: " prefix if it exists.  It is imbued with special meaning for BeGaze, but Samara can ignore it.		        if msgString.left(4) = "TRG:" then msgString = msgString.right(len(msgString) - 4)		        		        // check if the message contains a specially crafted XML message for SAMARA:		        if msgString.left(5) = "<SAM>" and msgString.right(6) = "</SAM>" then		          		          // parse the string into an XMLdocument and get some info from it:		          XMLMessage = new XMLDocument		          XMLMessage.loadXml(msgString)  // parse the XML message string		          root = XMLmessage.DocumentElement  // the SAM tag		          rootChildCount = root.childCount -1		          if rootChildCount > -1 then  // are there any TGT or CONFIG elements?		            typeOfMessage = root.child(0).name  // if so, get the name of the zeroth one		          else		            typeOfMessage = ""		          end if		          		          // decide what to do in response to the message		          select case typeOfMessage		            		            		          case "SESSION"  // session level info which applies to all contained sets (currently, Sex, Group, and session Label which overrides the one derived from the file name.		            self.extractInfoFromSessionXML(session, root.child(0))		            		          case "CONFIG"  // apply configuration setting(s)		            // currently just specifies the test type is specified and whether the analysis should be in 2D mode.		            extractInfoFromConfigXML(currentSet, root.child(0))		            		            		          case "TGT_DEF"  // define default target settings		            		            // create 1 or more definitions depending on how many TGT_DEFs there are in the message		            for i = 0 to rootChildCount		              currentRootChild = root.child(i)		              currStim = new stimulus		              currStim.value("onsetTime") = 0		              // get values from the XML and apply them to the stimulus:		              extractInfoFromTgtXML(currStim, currentRootChild, converter)		              // store the definition in a dictionary, keyed by the name of the definition.  Targets can then look up their name		              // to see if a set of defaults exists for them:		              targetDefaults.value(currStim.value("name")) = currStim		            next		            		            		          case "TGT"  // create target(s)		            		            // create 1 or more stimuli depending on how many TGTs there are in the message		            for i = 0 to rootChildCount		              currentRootChild = root.child(i)		              currStim = new stimulus		              currStim.value("onsetTime") = currentTime		              		              // get values from the XML and apply them to the stimulus:		              extractInfoFromTgtXML(currStim, currentRootChild, converter)		              		              // get any default values that may exist, depending on the name of the target:		              targetName = currStim.value("name")		              if targetDefaults.hasKey(targetName) then		                applyDefaultsToStimulus(currStim, targetDefaults.value(targetName))		              end if		              		              // now apply any global defaults that may exist for all targets, and have not been specified for this particular target:		              if targetDefaults.hasKey("*Unspecified") then		                applyDefaultsToStimulus(currStim, targetDefaults.value("*Unspecified"))		              end if		              		              // finally, fill in dummy values for any fields which are required yet which have not been specified:		              fillInBlankValuesInStimulus(currStim)		              		              currStim.value("background") = currBackgndImageFilename		              		              // lastly calculate amplitude values. These are still signed (ie negative = left or downward)		              previousStimulusNumber = uBound(stimulusList)		              if previousStimulusNumber = -1 then		                // this is the first stimulus, so assume a starting position at the screen centre:		                currStim.value("amplitudeX") = currStim.value("x")		                currStim.value("amplitudeY") = currStim.value("y")		                		              else  // calculate the amplitude from the previous target position. Not pure amplitudes as also signed negative when leftward/downward		                // NB this won't be correct for memory-guided tests, as these need to be worked out wrt the target two before. But can't assume that the		                // test type is correctly specified at the importing stage, so that correction is applied later at the measurement stage.		                currStim.value("amplitudeX") = currStim.value("x") - stimulusList(previousStimulusNumber).value("x")		                currStim.value("amplitudeY") = currStim.value("y") - stimulusList(previousStimulusNumber).value("y")		                		              end if		              		              // calculate Euclidean amplitude (unsigned) and direction (angle in degrees).		              currStim.value("2Damplitude") = sqrt(currStim.value("amplitudeX")^2 + currStim.value("amplitudeY")^2)		              currStim.value("2Ddirection") = atan(currStim.value("amplitudeY")/currStim.value("amplitudeX")) * 180/gPi		              		              // store this stimulus:		              stimulusList.append currStim		              'gLog currStim.value("name") + ": " + format(currStim.value("offsetTime") - currStim.value("onsetTime"), "-##.000")		              		            next		            		            		          case "SP_TGT"		            currentRootChild = root.child(0)		            currSPstim = new PursuitStimulus		            currSPstim.onsetTime = currentTime		            		            // get values from the XML and apply them to the stimulus:		            extractInfoFromSPtgtXML(currSPstim, currentRootChild, converter)		            SPstimulusList.append currSPstim// store this stimulus		            		            		          case "RESPONSE"		            currResponse = new response		            currResponse.time = currentTime		            currentRootChild = root.child(0) // assuming here that just one response is sent in each message, whereas for targets we assume that more than one might be sent.		            self.extractInfoFromResponseXML(currResponse, currentRootChild)		            currentSet.addResponse currResponse		            		            		          case "OFFSET"  // marks the time at which a target actually disappeared, a check that its specified duration was actually adhered to.		            if currStim <> nil then		              currStim.value("offsetMsgTime") = currentTime		            end if		            		            		          case else // oops, don't know what this message is supposed to do		            gLog "Unknown or invalid message tag: " + typeOfMessage		            mParentWindow.displayProgressInfo("Unknown or invalid message tag: " + typeOfMessage)		            		            		          end select		          		          		        else  // the message is not Samara XML, so check to see if it is a background image message for BeGaze:		          		          select case msgString.right(3)		            		          case "bmp","jpg","png"		            currBackgndImageFilename = msgString		            		            if not haveImageFolderItem then		              folderDlg = new selectFolderDialog		              folderDlg.actionButtonCaption = "Select Folder"		              folderDlg.title = "Select image folder"		              folderDlg.promptText = "Select the folder containing the image '" + currBackGndImageFilename +"'."		              imageFolder = folderDlg.ShowModalWithin(mParentWindow)		              		              haveImageFolderItem = TRUE  // doesn't matter if the folderItem is nil, we just want to ask this question once of the user		            end if		            		            session.storeBackgroundPicture(imageFolder, currBackgndImageFilename, converter)  // the session keeps a central store of these, later to be married up with the pictures themselves		            // the iViewSet, meanwhile, keeps a store of BackGroundImage objects, which contain the name, the on/offset, and later, the picture itself.		            currBackGndImage = new backGroundImage		            currBackGndImage.fileName = currBackGndImageFilename		            currBackGndImage.pic = session.backgroundPictureRefFromName(currBackGndImageFilename)		            currBackGndImage.onset = currentTime		            currentSet.addBackgroundImage(currBackGndImage, currentTime)		            		          case else		            gLog "Unrecognised message: " + msgString		            mParentWindow.displayProgressInfo("Unrecognised message: " + msgString)		            		          end select		          		        end if		        		        		      end select		      		    end select		    		    // get the next line		    if  upperLimit >= currIndex then		      currentLine() = split(fileAsArray(currIndex), tab)		    end if		    		  next		  		  		  // add the last set to the session		  currentSet.number = currentSetNumberFromFile		  currentSet.addStimulus stimulusList		  currentSet.addSPstimulus SPstimulusList		  currentSet.addBackgroundImage(nil, currentTime) // set the offset time of the last backGroundImage		  currentSet.numberOfInvalidPoints = countOfInvalidPointsInThisSet		  		  if currentSetNumberFromFile = 1 then		    mParentWindow.addSession session		  end if		  		  session.addSet currentSet  // needs to happen after the session is added to the window, as adding a set causes UI changes		  session.dataImportCompleted = TRUE		  mParentWindow.displayProgressInfo("All sets imported.")		  mParentWindow.turnProgressWheelOn(FALSE)		  		  		  		exception err		  gHandleException err, "run method of dataParser thread."		End Sub	#tag EndEvent	#tag Method, Flags = &h1		Protected Sub applyDefaultsToStimulus(target as stimulus, defaults as stimulus)		  dim i, count as integer		  dim label as string		  		  count = defaults.count - 1		  		  // cycle through all the values stored in the default stimulus.  If they have not already been set for this stimulus,		  // then create them and use the default value. The default values are defined by the experimenter using TGT_DEF messages.		  		  for i = 0 to count		    // the offset time is a bit different as the default contains a duration rather than a time per se, so add it to the target's onset time:		    if defaults.hasKey("offsetTime") and not target.hasKey("offsetTime")  then		      target.value("offsetTime") = target.value("onsetTime") + defaults.value("offsetTime")		    end if		    		    // the others are simpler:		    label = defaults.key(i)		    if not target.hasKey(label) then target.value(label) = defaults.value(label)		  next		  		  		  		exception err		  gHandleException err, "addMissingValuesToStimulus method of dataParser thread."		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(w as chartWindow)		  mParentWindow = w  // this lets the thread know which window to display a progress window within as a sheet.		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Destructor()		  'gLog "iViewParserThread destructor"		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub extractInfoFromConfigXML(currentSet as iViewSet, tgtNode as XMLNode)		  // extracts info from an XML string which sets parameters of a stimulus or a template stimulus used to hold default values.		  		  dim iteration, itemCount as integer		  dim tagName, stringValue as string		  		  // extract the parameters of the target from its sub-tags:		  itemCount = tgtNode.childCount - 1 // the number of sub-tags within the TGT tag		  		  for iteration = 0 to itemCount		    		    tagName = tgtNode.child(iteration).name		    		    // get a value for the tag. But some don't have a value (e.g. <ZeroTimeFromStimulusOnset/> so check first)		    if tgtNode.child(iteration).ChildCount > 0 then		      stringValue = tgtNode.child(iteration).firstChild.value		    end if		    'gLog tagName + "  " + stringValue		    		    // choose what to do depending on the tagName:		    select case tagName  // the code below is case insensitive for tag names, so files should be robust for incorrect case.		      // but not sure about dictionary values, so they are all set individually to ensure they are the correct (lower/camel) case.		      		    case "TEST"		      		      currentSet.testType = stringValue		      		    case "ANALYSIS"		      		      if stringValue = "2D" then		        currentSet.analyse2D = TRUE		      else		        currentSet.analyse2D = FALSE		      end if		      currentSet.analysisTypeSpecified = TRUE		      		    case "UNITS"		      if stringValue = "Degrees"  or stringValue = "degrees" or stringValue ="deg" then		        mUnits = "Degrees" // otherwise remains at the default value of "pixels"		      end if		      		    case "VERSION"  // string info describing the file or software  used to run the test		      currentSet.testVersion = stringValue		      		    case "ZeroTimeFromStimulusOnset"		      // set a property of the set accordingly		      		    case else		      gLog "Config From XML: unrecognised CONFIG child tag"		      		      		    end select		    		    		  next		  		  		  		exception err		  gHandleException err, "extractInfoFromTgtXML method of dataParser thread."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub extractInfoFromResponseXML(currResponse as response, tgtNode as XMLNode)		  // extracts info from an XML string which gives any specified parameters of a response		  dim iteration, itemCount as integer		  dim tagName, stringValue as string		  		  // extract the parameters of the target from its sub-tags:		  itemCount = tgtNode.childCount - 1 // the number of sub-tags within the RESPONSE tag		  		  if itemCount > -1 then		    		    for iteration = 0 to itemCount		      		      tagName = tgtNode.child(iteration).name		      		      // get a value for the tag. But some don't have a value (e.g. <displayOnly/> so check first)		      if tgtNode.child(iteration).ChildCount > 0 then		        stringValue = tgtNode.child(iteration).firstChild.value		      end if		      		      // choose what to do depending on the tagName:		      select case tagName  // the code below is case insensitive for tag names, so files should be robust for incorrect case.		        // but not sure about dictionary values, so they are all set individually to ensure they are the correct (lower/camel) case.		        		      case "value"  // the response the subject gave		        currResponse.value =  stringValue		        		      case "actual" // what the correct response should have been		        currResponse.actual =  stringValue		        		      case "judgment" // whether the response was correct or not		        currResponse.judgment =  stringValue		        		      case "tgt_ID" // to associate this response with the appropriate trial/stimulus		        currResponse.stimulus_ID =  stringValue		        		      case "type"  // mode of response (e.g. 'keyboard', 'verbal').  Not currrently used		        currResponse.type =  stringValue		        		        		      case else		        gLog "iViewParserThread extractInfoFromResponseXML: unrecognised response child tag: " + tagName		        		        		      end select		      		      		    next		    		  end if		  		  		  		exception err		  gHandleException err, "extractInfoFromResponseXML method of dataParser thread."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub extractInfoFromSessionXML(session as iViewSession, tgtNode as XMLNode)		  // extracts info from an XML string which sets parameters which apply globally to all sets within the session		  		  dim iteration, itemCount as integer		  dim tagName, stringValue as string		  		  // extract the parameters of the target from its sub-tags:		  itemCount = tgtNode.childCount - 1 // the number of sub-tags within the Session tag		  		  for iteration = 0 to itemCount		    		    tagName = tgtNode.child(iteration).name		    		    if tgtNode.child(iteration).firstChild <> nil then // need this check as empty tags lead to NilObjectEXceptions rather than returning empty strings		      stringValue = tgtNode.child(iteration).firstChild.value		    else		      stringValue = ""		    end if		    'gLog tagName + "  " + stringValue		    		    // choose what to do depending on the tagName:		    select case tagName  // the code below is case insensitive for tag names, so files should be robust for incorrect case.		      // but not sure about dictionary values, so they are all set individually to ensure they are the correct (lower/camel) case.		      		    case "Subject"		      		      session.subject_id = stringValue		      		    case "Sex"		      		      session.subject_sex = stringValue		      		    case "Group"		      		      session.subject_group = stringValue		      		    case "Label"		      // this has already been set to the default value of the file name in the Run method.		      // it can be overridden by this value if supplied.		      if stringValue <> "" then session.label = stringValue		      		    case else		      gLog "Session From XML: unrecognised SESSION child tag: " + tagname		      		      		    end select		    		    		  next		  		  		  		exception err		  gHandleException err, "extractInfoFromSessionXML method of dataParser thread."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub extractInfoFromSPtgtXML(currStim as pursuitStimulus, tgtNode as XMLNode, converter as screenGeometry)		  // extracts info from an XML string which sets parameters of a pursuit stimulus		  		  dim iteration, itemCount as integer		  dim tagName, stringValue as string		  		  // extract the parameters of the target from its sub-tags:		  itemCount = tgtNode.childCount - 1 // the number of sub-tags within the TGT tag		  		  for iteration = 0 to itemCount		    		    tagName = tgtNode.child(iteration).name		    		    // get a value for the tag. But some don't have a value (e.g. <displayOnly/> so check first)		    if tgtNode.child(iteration).ChildCount > 0 then		      stringValue = tgtNode.child(iteration).firstChild.value		    end if		    'gLog tagName + "  " + stringValue		    		    // choose what to do depending on the tagName:		    select case tagName  // the code below is case insensitive for tag names, so files should be robust for incorrect case.		      // but not sure about dictionary values, so they are all set individually to ensure they are the correct (lower/camel) case.		      		      		    case "amplX"		      // decide if angle is passed directly or has to be computed from a pixel value		      if mUnits = "Degrees" then		        currStim.amplX = val(stringValue)		      else		        currStim.amplX =  roundStimulusPosition(converter.convertPixelsToAngle(val(stringValue), true))		      end if		      		      		    case "amplY"		      // decide if angle is passed directly or has to be computed from a pixel value		      if mUnits = "Degrees" then		        currStim.amplY = val(stringValue)		      else		        currStim.amplY =  roundStimulusPosition(converter.convertPixelsToAngle(val(stringValue), false))		      end if		      		      		    case "DUR"		      currStim.duration = val(stringValue)/1000 // the times in the XML are specified in ms		      		      		    case "peakVelX"		      currStim.peakVx = val(stringValue)		      		      		    case "peakVelY"		      currStim.peakVy = val(stringValue)		      		      		    case "phaseX"		      currStim.phaseX = val(stringValue)		      		      		    case "phaseY"		      currStim.phaseY = val(stringValue)		      		      		    case "TYPE"  // Specify whether the stimulus is a point target or an entire background (in which case it is specified by either the colour or file elements). Not currently implemented.		      currStim.type = stringValue		      		      		    case "COLOUR"		      		      select case stringValue		        		      case "red"		        currStim.colour = RGB(255,78,81) ' &cFF0000		        		      case "green"		        currStim.colour = &c00FF00		        		      case "blue"		        currStim.colour = &c0000FF		        		      case "yellow"		        currStim.colour = &cFFFF00		        		      case "black"		        currStim.colour = &c000000		        		      case "white"		        currStim.colour = &cFFFFFF		        		      case "grey"		        currStim.colour = &cAAAAAA		        		      case else  //default to pink if unclear		        currStim.colour = &cFF00FF		        		      end		      		      gLog "iViewParserThread extractInfoFromSPtgtXML: unrecognised stimulus child tag"		      		      		    end select		    		    		  next		  		  		  		exception err		  gHandleException err, "extractInfoFromSPtgtXML method of dataParser thread."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub extractInfoFromTgtXML(currStim as stimulus, tgtNode as XMLNode, converter as screenGeometry)		  // extracts info from an XML string which sets parameters of a stimulus or a template stimulus used to hold default values.		  		  dim iteration, itemCount as integer		  dim tagName, stringValue as string		  		  // extract the parameters of the target from its sub-tags:		  itemCount = tgtNode.childCount - 1 // the number of sub-tags within the TGT tag		  		  for iteration = 0 to itemCount		    		    tagName = tgtNode.child(iteration).name		    		    // get a value for the tag. But some don't have a value (e.g. <displayOnly/> so check first)		    if tgtNode.child(iteration).ChildCount > 0 then		      stringValue = tgtNode.child(iteration).firstChild.value		    end if		    'gLog tagName + "  " + stringValue		    		    // choose what to do depending on the tagName:		    select case tagName  // the code below is case insensitive for tag names, so files should be robust for incorrect case.		      // but not sure about dictionary values, so they are all set individually to ensure they are the correct (lower/camel) case.		      		    case "X"		      // decide if angle is passed directly or has to be computed from a pixel value		      if mUnits = "Degrees" then		        currStim.value("x") = val(stringValue)		      else		        currStim.value("x") =  roundStimulusPosition(converter.convertPixelsToAngle(val(stringValue), true))		      end if		      // store some parallel values for when plotting binocular data		      currStim.value("leftx") = currStim.value("x")		      currStim.value("rightx") = currStim.value("x")		      		    case "Y"		      // decide if angle is passed directly or has to be computed from a pixel value		      if mUnits = "Degrees" then		        currStim.value("y") = val(stringValue)		      else		        currStim.value("y") =  roundStimulusPosition(converter.convertPixelsToAngle(val(stringValue), false))		      end if// store some parallel values for when plotting binocular data		      currStim.value("lefty") = currStim.value("y")		      currStim.value("righty") = currStim.value("y")		      		    case "DUR"		      currStim.value("offsetTime") = currStim.value("onsetTime") + val(stringValue)/1000 // the times in the XML are specified in ms		      		    case "OVERLAP", "GAP"		      currStim.value("gap") = val(stringValue)/1000  //needs to be converted from ms to s.  -ve values = gap, +ve = overlap		      		    case "DELAY"		      currStim.value("delay") = val(stringValue)/1000  //needs to be converted from ms to s.		      		    case "NAME"		      currStim.value("name") = stringValue		      		    case "ID"		      currStim.value("ID") = stringValue		      		    case "TYPE"  // Specify whether the stimulus is a point target or an entire background (in which case it is specified by either the colour or file elements). Not currently implemented.		      currStim.value("type") = stringValue		      		    case "Comment"		      currStim.value("comment") = stringValue		      		    case "COLOUR"		      		      select case stringValue		        		      case "red"		        currStim.value("colour") = RGB(255,78,81) ' &cFF0000		        		      case "green"		        currStim.value("colour") = &c00FF00		        		      case "blue"		        currStim.value("colour") = &c0000FF		        		      case "yellow"		        currStim.value("colour") = &cFFFF00		        		      case "black"		        currStim.value("colour") = &c000000		        		      case "white"		        currStim.value("colour") = &cFFFFFF		        		      case "grey"		        currStim.value("colour") = &cAAAAAA		        		      case else  //default to pink if unclear		        currStim.value("colour") = &cFF00FF		        		      end		      		    case "SHAPE"		      currStim.value("shape") = stringValue		      		    case "FILE"		      currStim.value("file") = stringValue		      		    case "SIZE"		      currStim.value("size") = stringValue		      		    case "displayOnly"		      currStim.value("displayOnly") = TRUE		      // a target with this attribute will be drawn on screen but ignored for analysis purposes		      // for backwards compatibility and for tasks where this attribute is not set, don't subsequently test the value of this key directly but instead use the "displayOnly" accessor method of the stimulus class		      		    case "disconnected"		      currStim.value("disconnected") = TRUE		      // a target with this attribute will not be drawn on screen connected to its predecessor		      // for backwards compatibility and for tasks where this attribute is not set, don't subsequently test the value of this key directly but instead use the "disconnected" accessor method of the stimulus class		      		    case else		      gLog "iViewParserThread extractInfoFromTgtXML: unrecognised stimulus child tag"		      		      		    end select		    		    		  next		  		  // all targets need a name for matching to target defaults, so insert one here if none specified:		  if not currStim.hasKey("name") then currStim.value("name") = "*Unspecified"		  		  		exception err		  gHandleException err, "extractInfoFromTgtXML method of dataParser thread."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub fillInBlankValuesInStimulus(target as stimulus)		  		  		  // fill in any blank values that the user may have skipped and that will cause 'key not found' errors later if they don't exist:		  if not target.hasKey("offsetTime") then target.value("offsetTime") =  target.value("onsetTime")		  if not target.hasKey("x") then target.value("x") = 0.0		  if not target.hasKey("y") then target.value("y") = 0.0		  if not target.hasKey("lefty") then target.value("lefty") = target.value("y") = 0.0		  if not target.hasKey("righty") then target.value("righty") = target.value("y") = 0.0		  if not target.hasKey("gap") then target.value("gap") = 0.0		  if not target.hasKey("delay") then target.value("delay") = 0.0		  if not target.hasKey("comment") then target.value("comment") = ""		  if not target.hasKey("ID") then target.value("ID") = ""		  if not target.hasKey("colour") then target.value("colour") = RGB(255,78,81) // red		  		  		  // if no type has been specified, take a guess based on any "name" specified, else give the default value "target"		  // which is needed in anti-saccade analysis		  if not target.hasKey("type") then		    if target.hasKey("name") then		      target.value("type") = target.value("name")		    else		      target.value("type") ="target"		    end if		  end if		  		exception err		  gHandleException err, "fillInBlankValuesInStimulus method of dataParser thread."		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function roundStimulusPosition(position as double) As double		  // Stimulus positions are communicated to iView/Samara in integer pixels.  The rounding required to display		  // a target at an integer pixel introduces a slight deviation from the intended value (usually <= 0.02 deg).		  // Accordingly we round the calculated angular position of the stimulus to force it to the nearest 0.05 deg value.		  		  return round(position*20)/20		End Function	#tag EndMethod	#tag Property, Flags = &h1		#tag Note			Set in the constructor		#tag EndNote		Protected mParentWindow As chartWindow	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Defines whether stimuli in the file are specified in pixel coordinates (with top-left origin) or in degrees (with screen centre origin), which is the way they will eventually be stored			in the set and displayed and anallysed.		#tag EndNote		Protected mUnits As String = "Pixels"	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Priority"			Visible=true			Group="Behavior"			InitialValue="5"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="StackSize"			Visible=true			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass