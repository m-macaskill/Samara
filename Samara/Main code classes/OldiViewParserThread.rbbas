#tag ClassClass OldiViewParserThreadInherits Thread	#tag Event		Sub Run()		  dim dlg as OpenDialog		  dim f as FolderItem		  dim stream as TextInputStream		  dim currentLine(), temp, msgString, stimulusName as string		  dim tab as string = chr(9)		  dim i, CurrentSetNumberFromFile, countOfInvalidPointsInThisSet as integer		  dim firstStimulusSeenAlready as boolean = false		  dim importFromThisSet as boolean = true		  dim baseTime, x, y, currentOnset as double		  dim p as dataPoint		  dim s, stimulusList() as stimulus		  dim prevStim, currStim, SPstim as stimulus		  dim currentSet as iViewSet		  		  // sometimes the iView POR values can be hugely outside the acceptable values (due to loss of tracking??).		  // Need to screen for this.  Note that eventually these values should be parsed from the iView file itself		  // to cater for experiments with different screen calibration set ups.		  const hScreenMax = 640		  const vScreenMax = 480		  		  'gLog "Run event of parserThread class"		  		  //		  // can switch pixel > deg calculation by changing the value of this boolean:		  dim convertFromPixels as boolean = true		  //		  // other values needed for the pixel > deg calculation.  These may change from time to time so		  // eventually will need to extract some of these from the iView file.		  dim hMmPerPixel, vMmPerPixel, headDistance, radToDeg as double		  dim hScreenPixelCentre, vScreenPixelCentre as integer		  radToDeg = 180/gPi		  headDistance = 500  // mm eye to screen distance		  hMmPerPixel = 400/hScreenMax  // 400 mm screen width / 640 pixels		  vMmPerPixel = 300/vScreenMax  // 300 mm screen height / 480 pixels		  hScreenPixelCentre = hScreenMax/2		  vScreenPixelCentre = vScreenMax/2		  		  		  dlg = new openDialog		  dlg.Title="Select a .txt file created by IDF Converter"		  f = dlg.showModalWithin(mParentWindow)		  		  if f = nil then		    exit  // can't do anything		  else  // start importing		    		    mParentWindow.turnProgressWheelOn(true)		    mSession = new iViewSession		    mSession.sourceOfData = "iView"		    mSession.label = left(f.name, len(f.name)-4)  // allows the chartWindow to be titled with the source filename (crudely removing extension).		    stream = f.openAsTextFile		    		    // process header.  For the time being, just skip through it		    for i = 1 to 23  // NB the header is actually only 22 lines but we want to skip the first MSG until we are able to process it.		      temp = stream.readLine		    next		    		    // now start parsing the eye data.		    currentSet = new iViewSet(mSession)		    countOfInvalidPointsInThisSet = 0		    currentSetNumberFromFile = 1 // NB this may not always be a valid guess?? May need to address this in the future		    mParentWindow.displayProgressInfo("Importing set number " + str(currentSetNumberFromFile))		    currentLine() = split(stream.readLine, tab) // read the first line		    baseTime = val(currentLine(0)) // the baseTime is the time of the start of each set (in microseconds).  It is used to provide a zero point for the first set.		    // create some initial blank stimuli		    prevStim = new stimulus		    currStim = new stimulus		    		    do  // main loop which gets each line of the file, which will either be a data sample or a message.		      		      select case currentLine(1)		        		      case "SMP" // a line with eye position sample data.		        // only import new samples and create a new set when the data is from a valid saccade task set		        // (ie not TOL recordings, as they are handled by BeGaze)		        if importFromThisSet then		          		          // if this data is from a new  set, we need to store the previous one and create a new set		          if currentSetNumberFromFile <> val(currentLine(2)) then		            currentSet.number = currentSetNumberFromFile  // label the set with its set number		            if uBound(stimulusList) > -1 then		              stimulusList(UBound(stimulusList)).value("offsetTime") = p.t  // the last stimulus does not have an offset time.  Give it the time of the last eye sample.		            end if		            		            // need a crude test indicating that this is a self-paced test.  Will do, just for Saskia's first expt		            // need to add two stimuli for the self-paced test, which aren't specified in the file		            if uBound(stimulusList) = -1 then		              SPstim = new stimulus		              SPstim.value("onsetTime") = 0		              SPstim.value("offsetTime") = p.t		              SPstim.value("amplitudeX") = 26		              SPstim.value("x") = 13		              SPstim.value("y") = 0		              stimulusList.append SPstim		              stimulusList.append SPstim.clone		              stimulusList(1).value("x") = -13		            end		            		            currentSet.addStimulus stimulusList  // add the current list of stimuli to the set		            if currentSetNumberFromFile = 1 then		              // When the first set has been imported, send the session and the first set to the window for display.		              // But will continue importing subsequent sets in the background and adding them to the stored session		              mParentWindow.displayProgressInfo("Processing and plotting first trial.  Will continue importing any others in the background.")		              mParentWindow.addSession mSession		            end if		            		            currentSet.numberOfInvalidPoints = countOfInvalidPointsInThisSet		            mSession.addSet currentSet  // store the set		            		            currentSet = new iViewSet(mSession)  // make a new one		            currentSetNumberFromFile =  val(currentLine(2))  // get the number of this new set		            mParentWindow.displayProgressInfo("Importing set number " + str(currentSetNumberFromFile))		            baseTime = val(currentLine(0))  // get the time at which it starts, to provide a zero for subsequent samples		            		            redim stimulusList(-1)  // restart the list of stimuli for the next set		            firstStimulusSeenAlready = false  // recreate some initial blank stimuli		            prevStim = new stimulus		            currStim = new stimulus		            		          end if		          		          // now create a new data point		          p = new dataPoint("iView", 1)  // source of data = iView and 1 channel of data (i.e. eye) per sample.		          p.t = (val(currentLine(0)) - baseTime)/1000000		          x = val(currentLine(3))		          y = val(currentLine(4))		          if x <= 0 or y <= 0 or x > hScreenMax or y > vScreenMax then // then the eye was not being tracked in this sample		            p.valid = false		            countOfInvalidPointsInThisSet = countOfInvalidPointsInThisSet +1		          else		            p.valid = true		          end		          // even if the xy values are invalid, we take them anyway.  They won't be plotted later on.		          if convertFromPixels then		            p.x = atan((x-hScreenPixelCentre) * hMmPerPixel / headDistance) * radToDeg		            p.y = atan((y-vScreenPixelCentre) * vMmPerPixel / headDistance) * radToDeg		          else  // keep the pixel values		            p.x = x		            p.y = y		          end if		          currentSet.addDataPoint p		        end if		        		      case "MSG"  // a message line		        		        msgString = currentLine(2)		        mParentWindow.displayProgressInfo("Importing set number " + str(currentSetNumberFromFile) + endOfLine + msgString)		        		        select case msgString.left(11)		          		        case "Scene Image"		          // not handled		          'progressWindow.statusText.text = "Scene image message."		          importFromThisSet = true		          		        case "# Message: "		          stimulusName = mid(msgString, 12)		          currentOnset =  (val(currentLine(0)) - baseTime)/1000000		          		          if stimulusName.left(3) = "TOL" then		            // somehow Tower of London recordings have gotten into the file and we left the analysis of that to BeGaze.		            // So set a flag which will stop importing of samples, but keep searching in case another valid set arrives.		            importFromThisSet = false		            mParentWindow.displayProgressInfo("TOL detected.")		          else		            		            select case stimulusName		              		            case "finished planning", "one", "two", "three", "four", "five", "six"  // don't respond to the following TOL-associated messages		              mParentWindow.displayProgressInfo("Unhandled message:" + stimulusName)		              		            case else  // it must be a valid saccade stimulus message		              		              if stimulusName = "gap" then  // this is a gap between 2 stimuli rather a stimulus itself		                prevStim.value("offsetTime") =  currentOnset		                currStim.value("gap") = -0.2  // hardwired 200 ms gap		                		              else		                if instr(stimulusName, "delay") <> 0  then// then this is a stimulus overlapping the previous one		                  currStim.value("onsetTime") = currentOnset		                  prevStim.value("offsetTime") =  currentOnset + 0.4  // hardwired 400 ms overlap		                  currStim.value("gap") = 0.4		                  		                else		                  		                  // this is a standard stimulus, with some default values:		                  currStim.value("y") = 0		                  currStim.value("type") = "target"		                  		                  // some values depend on whether a gap is in effect		                  if currStim.hasKey("gap") then		                    		                    if currStim.value("gap") = -0.2 then		                      currStim.value("onsetTime") = currentOnset  // if there is a delay in effect, the onset has already been set.		                    end if		                    		                  else  // no gap or overlap has been set, so specify these values here:		                    currStim.value("gap") = 0		                    currStim.value("onsetTime") = currentOnset		                    prevStim.value("offsetTime") =  currentOnset		                  end if		                  		                  select case stimulusName		                    		                  case "targetmin15.bmp"		                    currStim.value("x") = -13.0		                  case "targetmin12.bmp"		                    currStim.value("x") = -10.5		                  case "targetmin9.bmp"		                    currStim.value("x") = -8.0		                  case "center"		                    currStim.value("x") = 0.0		                    currStim.value("type") = "centre"  // NB spelling difference		                  case "target9.bmp"		                    currStim.value("x") = 8.0		                  case "target12.bmp"		                    currStim.value("x") = 10.5		                  case "target15.bmp"		                    currStim.value("x") = 13		                  else		                    msgBox "Unrecognised stimulus message: " + msgString		                  end select		                  		                  // setting amplitude values for a 'centre' stimulus is more difficult than for peripheral 'target' stimuli		                  if currStim.value("type") = "target" then		                    currStim.value("amplitudeX") = currStim.value("x")  // simple, as all targets appear from a the central location		                  else		                    if uBound(stimulusList) = -1 then  // this is the first fixation stimulus, so it doesn't really have an associated amplitude		                      currStim.value("amplitudeX") = 0.0		                    else  // the amplitude needs to be worked out from where the target was previously		                      currStim.value("amplitudeX") = -1.000 * prevStim.value("x") // NB the zeros are necessary here as if just multiply by 1,		                      // the amplitude is forced into an integer and loses any fractional part.		                    end if		                  end if		                  		                  if firstStimulusSeenAlready  then  // shouldn't store the first stimulus until it is completed, which it won't be on the first pass.		                    stimulusList.append prevStim.clone  // ie store a true copy rather than a pointer, which will shift target in the next line.		                  end if		                  		                  prevStim = currStim		                  currStim = new stimulus		                  firstStimulusSeenAlready = true		                  		                end if		              end if		            end select		          end if		        end select		        		      end select		      		      // get the next line		      currentLine() = split(stream.readLine, tab)		      		    loop until stream.EOF		    		    stream.close		    // add the last set to the session		    if importFromThisSet then		      currentSet.number = currentSetNumberFromFile		      if uBound(stimulusList) > -1 then		        stimulusList(UBound(stimulusList)).value("offsetTime") = p.t  // the last stimulus does not have an offset time.  Give it the time of the last eye sample.		      end if		      currentSet.addStimulus stimulusList		      currentSet.numberOfInvalidPoints = countOfInvalidPointsInThisSet		      mSession.addSet currentSet		    end if		    mParentWindow.displayProgressInfo("All sets imported.")		    mParentWindow.turnProgressWheelOn(false)		    		  end if		  		  		exception err		  gHandleException err, "run method of dataParser thread."		End Sub	#tag EndEvent	#tag Method, Flags = &h0		Sub Constructor(w as chartWindow)		  mParentWindow = w  // this lets the thread know which window to display a progress window within as a sheet.		  		End Sub	#tag EndMethod	#tag Note, Name = About				This thread was implemented in the first incarnation of Samara, which was designed purely to read data files from Saskia van Stockum's MA thesis. 		 This was at a stage when Experimenter could display only full screen images.  Accordingly, reconstructing the point target stimulus was a very idiosyncratic		process based on the file names of dispplayed images.				This thread is retained for backwards compatibility only.  It can only be used to import files from that particular study.  Subsequent to that study, 		we gained the ability to display point targets and implemented the generalised XML scheme for sending stimulus information to Samara.	#tag EndNote	#tag Property, Flags = &h1		Protected mParentWindow As chartWindow	#tag EndProperty	#tag Property, Flags = &h1		Protected mSession As iViewSession	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Priority"			Visible=true			Group="Behavior"			InitialValue="5"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="StackSize"			Visible=true			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass