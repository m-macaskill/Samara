#tag ClassClass HDF5ParserThreadInherits Thread	#tag Event		Sub Run()		  // this thread handles the importing of data from the HDF5 files produced in the MoVElab to record arm movements.		  		  dim dlg as openDialog		  dim f as folderItem		  dim fullPathName, tempStr, trialName, stimulusTypeName, stimulusType as string		  dim i, currentSetNumberFromFile,  currentSetNumberFromCounting, countOfInvalidPointsInThisSet, upperBound as integer		  dim file_ID, dataSet_ID, dataSpace_ID, trial_ID, stimulusNumberInFile as integer		  dim group, numOfGroups as integer		  dim status as variant		  dim phase, dimensions(), row, col, numOfStimuli, numOfSamples, primarySensor, baseByte as integer		  dim tempMem, readData, armData as memoryBlock		  dim setDuration, alpha, r, g, b, tempFloat, startX, startY, startZ, previousOffset, currentOnset, fileVersion as single		  dim baseTime, trialStartTime, sampleTime, prevSampleTime as double = 0		  dim stimColour as color		  dim s, stimulusList() as stimulus		  dim p, tempDataPointStore(-1) as dataPoint		  dim currentSet as iViewSet		  dim settingsWindow as HDF5ImportSettingsWindow		  dim bufferProblemDetected as boolean = false		  dim sampleNumberBufferProblemDetectedIn as integer		  dim sampleInterval as double = 1/240  // interval between samples at 240 Hz = approx  4.1666 ms, but this keeps it real		  		  		  'gLog "Run event of HDF5parserThread"		  		  // select the file for importing		  dlg = new openDialog		  dlg.title="Select a .h5 file containing MoVElab data"		  'dlg.initialDirectory = preferencesFolder.parent.parent  //i.e. the user folder in OS X		  f = dlg.showModalWithin(mParentWindow)		  		  		  if f = nil then		    return  // can't do anything		  else  // start importing		    		    // open the data file		    fullPathName = f.shellPath  // need UNIX path separators rather than Mac colons to pass to the HDF5 library		    'fullPathName = fullPathName.replaceAll("\", "\\")		    'fullPathName = fullPathName.replaceAll(" ", "\ ")		    		    'gLog "HDF5parserThread: " + fullPathName		    		    // a call to H5Fis_hdf5 to check whether the file is actually an HDF5 file and allow a graceful		    // exit if accidentally trying to open something else.		    status = H5Fis_hdf5(fullPathName)		    if status.type = 8 then // a string error message is returned if the function is unable to be called		      msgBox status		      return		    end if		    		    // if the call to H5F_ishdf5 occurs, it returns an integer:		    select case status		      		    case is > 0 // it is HDF5, so ignore and continue		      		    case 0 // the file is not HDF5		      msgBox "The selected file is not a valid HDF5 file."		      return		      		      return		    case is < 0   // the function failed to get a definite answer		      msgBox "There was a problem with assessing the file:" + fullPathName +". It may have 'invalid' characters in the file or path name.  Please try again. Status:" + str(status)		      return		      		    end select		    		    // Attempt to open the file.  NB the libraries will also complain about spaces & hyphens.  Underscores are OK.		    file_ID =  H5Fopen(fullPathName, 0, 0)		    if file_ID < 0 then // the H5 file could not be opened		      msgBox "The file could not be opened.  Try examining the Console log for more details.  The problem may be as simple as the file or path name containing characters which confuse the HDF library, such as spaces amd hyphens."		      return		    end if		    		    // some actions are dependent on the version of the HDF file structure, so determine that early on:		    fileVersion = self.determineHDFfileVersionNumber(file_ID)		    		    		    // the primary sensor number was not always written to the file, so it sometimes needs to be specified manually.		    // alternatively, it may be written to the file but be incorrect, so needs to be overridden with a manual value:		    do		      // display a window for the user to manually select the sensor number or to request that it be determined from the file		      settingsWindow = new HDF5ImportSettingsWindow		      settingsWindow.show		      // loop until the settingsWindow has been closed by the user		      while settingsWindow.visible = true		      wend		      		      // then get the relevant value from it		      if settingsWindow.stopThread then		        return  // as the user pressed "cancel"		      else		        primarySensor = settingsWindow.selectedSensor		      end if		      		      if primarySensor = -1 then // the user wants the selected sensor to be extracted from the file		        primarySensor = self.determinePrimarySensorFromFile(file_ID)		        // a value of -1 is returned if unsuccessful:		        if primarySensor = -1 then		          msgBox "The primary sensor number was not recorded in the file.  Please select it manually."		        end if		      end if		      		      // primarySensor will be between 1 and 8 if either selected by the user or successfully determined from the file.		      // if neither is the case, loop back		      		    loop until primarySensor <> -1		    'gLog "Primary sensor = " + str(primarySensor)		    		    		    // create session		    mSession = new iViewSession		    mSession.label = left(f.name, len(f.name)-2)  // allows the chartWindow to be titled with the source filename (crudely removing extension).		    mSession.sourceOfData = "MoVE"   // let the session be able to introspect what sort of data it holds.		    mSession.primarySensor = primarySensor		    		    // get the number of groups in the file.  This will include all trials but (from file version 2.1) also possibly other things (e.g. /session and /subject)		    status = H5Gget_num_objs(file_ID, numOfGroups)		    // need to subtract  /session and /subject if present, as they are groups at the root level also:		    if self.objectOfThisNameExists(file_ID, "session") then numOfGroups = numOfGroups - 1		    if self.objectOfThisNameExists(file_ID, "subject") then numOfGroups = numOfGroups - 1		    		    		    // loop through each group at the root level of the file.  so  need to be  careful about checking the name of each group		    mParentWindow.turnProgressWheelOn(true)		    for group = 1 to numOfGroups		      		      // create a string representation of the trial name in the HDF file.  Pad the string with appropriate number of zeros, eg trial_0001 or trial_0100		      trialName = "trial_" + left("0000", 4 - len(str(group))) +  str(group)  // assumes that there will not be more than 9999 trials		      		      // check that a trial of this name does exist		      if self.objectOfThisNameExists(file_ID, trialName) then		        		        // get a handle to the trial for when needed		        trial_ID = H5Gopen(file_ID, trialName)		        		        // create an iViewSet instance to corrrespond to each each trial (ie HDF 'group') in the HDF5 file:		        currentSet = new iViewSet(mSession)		        countOfInvalidPointsInThisSet = 0		        		        // extract some attributes of the set from the HDF file:		        self.getSetAttributesFromFile(trialName, currentSet, file_ID)		        // needed later to check stimuli don't exceed the set's duration.		        // but found that this value was often incorrect, so now we will have to calculate an approximation later		        'setDuration = MMGetSolitaryFloat(file_ID, trialName + "/duration")		        		        // keep track of the set number		        if self.objectOfThisNameExists(trial_ID,  "index") then		          currentSetNumberFromFile = MMGetSolitaryFloat(file_ID, trialName + "/index")		        else		          currentSetNumberFromFile = 0		        end if		        		        // maintain a parallel number for certain purposes as sometimes the number from the file was not equal to the ordinal number.		        currentSetNumberFromCounting = currentSetNumberFromCounting + 1		        // in some situations, the set number is not recorded properly and ends up being 0 for each set.		        // In that case, ignore the index value from the file and use the counted value:		        if currentSetNumberFromFile <> 0 then		          currentSet.number = currentSetNumberFromFile		        else		          currentSet.number = currentSetNumberFromCounting		        end if		        		        // notify progress		        mParentWindow.displayProgressInfo("Importing set number " + str(currentSetNumberFromCounting) + " of " + str(numOfGroups))		        		        // because of some changes in the file structure, we now need to start reading in the arm data (just to get the time stamp of the first sample)		        // before reading in the stimuli (which may now need to be shifted temporally to match the arm data samples) and then finally completing		        // the processing of the arm data (which need to be shifted spatially relative to the stimuli).		        		        // Begin getting the actual arm data.  This array will be of a variable length so need to pay attention to its dimensions.		        // NB these values really are 64 bit double precision numbers, so we treat them as such, unlike above where they actually seemed		        // to be 32 bit.  So here each value takes 8 bytes in the memory block.		        dataSet_ID = H5Dopen(file_ID, trialName + "/data")		        dataSpace_ID = H5Dget_space(dataSet_ID)		        dimensions() = MMGetDimensionsOfDataSpace(dataSpace_ID)  // this method returns the dimensions directly in an array		        numOfSamples = dimensions(0)		        // calculate an approximation of the set duration here, as the trial_000n/duration value is often incorrect.		        // Note that this value is no longer what it was intended to be, as it now includes any extra data recorded after the regular stimuli end.		        setDuration = numOfSamples * sampleInterval		        // Read the data.  Here we are very inefficient and get all the data in one huge memory block- we could be more clever and		        // get a smaller hyperslab corresponding only to the subset we are interested in, but I haven't figured out the library functions		        // for that.  The size of the memoryBlock is given by numOfSamples * number of values per sensor (8) * number of sensors (8)		        // * 4 bytes per value.		        // But first check that data actually exists, as sometimes bugs mean that there is no data accessible in the file:		        if self.objectOfThisNameExists(trial_ID,  "data") then		          armData = newMemoryBlock(numOfSamples * 8 * 8 * 8)		          status = H5LTread_dataset_double(file_ID, trialName + "/data", armData)		          status = H5Sclose(dataSpace_ID)		          status = H5Dclose(dataSet_ID)		        else		          msgBox "There was no data recorded for set " + str(currentSet.number) + "."		          continue   // jump out of this iteration of the set creation loop and go on to the next set if there is one.		        end if		        		        // Set a 'baseByte' value that is the first byte of the set's data		        baseByte = (primarySensor -1) * 8		        // we want to make the first sample be at time zero, so create a baseTime from the first sample to subtract from all times:		        baseTime = armData.doubleValue(basebyte)		        		        // from file version 2.5, there exists a trial attribute "/stimuli_start_delay" which specifies the time to which the zero time used		        // in stimulus timing values corresponded.  Previously, the zero time corresponded to the first movement data sample time for the trial,		        // but now we might have a bit of information recorded at the beginning of the trial before the specified stimulus events get underway.		        select case fileVersion		          		        case is <2  // stimuli and data began at the same time back then		          trialStartTime = 0.0		          		        case is <2.5  // this had an attribute "trial_start_vrpn_time", but there was an occasional bug where it could be grossly incorrect.		          trialStartTime = 2.0  // But it was always set to be 2.0 s anyway, so just use that		          		        case else		          // need to use MMGetSolitaryDouble rather than MMGetSolitaryFloat here or else the returned value does not have sufficient digits:		          trialStartTime = MMGetSolitaryDouble(file_ID, trialName + "/stimuli_start_delay")  // the time which corresponds to the zero time for the stimuli.		          		        end select		        		        // Find out how many stimuli there are		        dataSet_ID = H5Dopen(file_ID, trialName + "/stimulus_colour")		        dataSpace_ID = H5Dget_space(dataSet_ID)		        dimensions() = MMGetDimensionsOfDataSpace(dataSpace_ID)  // this method returns the dimensions directly in an array rather than via a memory block		        numOfStimuli = dimensions(1)		        		        if numOfStimuli > 0  then  // sometimes there is no stimulus info in the file, leading to a value of zero here, which causes array exceptions later on.		          // so only continue processing if there are stimuli to be had		          		          redim stimulusList(numOfStimuli - 1)		          		          // get their colours		          readData = newMemoryBlock(numOfStimuli * 4 * 4)  // 4 is the number of bytes to hold a 'single' and the number of parameters (r,g,b, & a)		          status = H5LTread_dataset_float(file_ID, trialName + "/stimulus_colour", readData)		          status = H5Sclose(dataSpace_ID)		          status = H5Dclose(dataSet_ID)		          		          for col = 0 to numOfStimuli - 1		            		            s = new stimulus		            // insert a dummy delay value to be consistent with iView stimuli, so stimuli are drawn consistently:		            s.value("delay") = 0.0		            		            // readData here consists of  an array of numOfStimuli * 4 (bytes per float) * 4 (r,g,b,a values)		            // e.g.  for the first of five stimuli, we access its rgba values using offsets of 0,20,40,60 bytes respectively.		            r = readData.singleValue((numOfStimuli*4*0) +(col * 4)) * 255		            g = readData.singleValue((numOfStimuli*4*1) + (col * 4)) * 255		            b = readData.singleValue((numOfStimuli*4*2)  + (col * 4)) * 255		            s.value("colour") =  RGB(r, g, b)		            s.value("alpha") =  readData.singleValue((numOfStimuli*4*3) + (col * 4)) * 255		            stimulusList(col) = s  // begin populating the stimulus array		          next		          		          // get the stimulus onsets.  We already know the number of stimuli, so the size of readData will be		          // simply numOfStimuli * 4 bytes (4 bytes is the size of a single/float).		          readData = newMemoryBlock(numOfStimuli * 4)		          status = H5LTread_dataset_float(file_ID, trialName + "/stimulus_onset", readData)		          for row = 0 to numOfStimuli -1		            stimulusList(row).value("onsetTime") = readData.singleValue(row *4) + trialStartTime // (takes account of the trialStartTime if non-zero)		          next row		          		          // get the stimulus offset times.  We already know the number of stimuli, so the size of readData will be		          // simply numOfStimuli * 4 bytes		          readData = newMemoryBlock(numOfStimuli * 4)		          status = H5LTread_dataset_float(file_ID, trialName + "/stimulus_duration", readData)		          for row = 0 to numOfStimuli -1		            tempFloat = readData.singleValue(row *4)		            if tempFloat > setDuration then  // some stimuli have ludicrous durations (eg 1000s).  If so, constrain it to the end of the data.		              stimulusList(row).value("offsetTime") = setDuration + trialStartTime		            else  //use the real stimulus duration.		              stimulusList(row).value("offsetTime") = stimulusList(row).value("onsetTime") + tempFloat 'readData.singleValue(row *4)		            end if		          next row		          		          // get the stimulus coordinates.  We already know the number of stimuli, so the size of readData will be		          // simply numOfStimuli * 3 (ie x,y, & z values) * 8 bytes		          readData = newMemoryBlock(numOfStimuli * 24)		          status = H5LTread_dataset_double(file_ID, trialName + "/stimulus_coords", readData)		          // we need to store the coordinates of the home target and zero everything else relative to that.		          // This assumes that the first target is at the origin which may not always be the case: the <centre>		          // coordinates need to be stored in the HDF5 file to be unambiguous about this.		          startX = readData.doubleValue(0)		          startY = readData.doubleValue(numOfStimuli*8)		          startZ = readData.doubleValue(numOfStimuli*16)		          // now read in the stimulus coordinates, zeroing them wrt the start:		          for col = 0 to numOfStimuli -1		            stimulusList(col).value("x") = readData.doubleValue((numOfStimuli*8*0) +(col * 8)) - startX		            stimulusList(col).value("y") = readData.doubleValue((numOfStimuli*8*1) +(col * 8)) - startY		            stimulusList(col).value("z") = readData.doubleValue((numOfStimuli*8*2) +(col * 8)) - startZ		            'calcPythagoreanDisplacement(dictionary(stimulusList(col)))  // calculate the 1D distance from the origin to the point.		          next		          		          // Remove beep & text stimuli as they won't be displayed.		          // May want to revisit this for some particular experiments.		          stimulusNumberInFile = 0		          for row = 0 to uBound(stimulusList)  // recalculates the upper bound each time through the loop so OK for us to delete array entries		            stimulusTypeName =  "stimulus_type_" + str(stimulusNumberInFile)		            stimulusType = MMGetStringAttribute(file_ID, trialName, stimulusTypeName)		            if stimulusType <> "target"  and stimulusType <> ""  then		              stimulusList.remove row		              row = row - 1  // need to bump this index as a new entry has been moved down to fill the entry just checked.		            else		              stimulusList(row).value("type") = MMGetStringAttribute(file_ID, trialName, "stimulus_name_" + str(stimulusNumberInFile))		            end if		            stimulusNumberInFile = stimulusNumberInFile + 1  // need to maintain this parallel counter so that our access to the array we are deleting		            // entries from, and the fixed array in the HDF file, stay synchronised.		          next		          		          // in some files, the stimulus_type information wan't recorded.  So we can delete any stimuli which get through the check above		          // by seeing if their spatial coordinates are NaNs:		          for row = 0 to uBound(stimulusList)  // recalculates the upper bound each time through the loop so OK for us to delete array entries		            if stimulusList(row).value("x").doubleValue <> stimulusList(row).value("x").doubleValue then		              stimulusList.remove row		              row = row - 1  // need to bump this index as a new entry has been moved down to fill the entry just checked.		            end if		          next		          		          		          // get the gap/overlap between successive stimuli.		          // NB this has to be done after the removal of the beep stimuli, otherwise successive stimuli are not actually visual ones.		          stimulusList(0).value("gap") = 0  // the first stimulus has to have a zero gap as there is no preceding stimulus		          // now get the rest, if there are any.		          for row = 1 to uBound(stimulusList)  // numOfStimuli is no longer correct as the beeps have been removed		            previousOffset = stimulusList(row-1).value("offsetTime")		            currentOnset = stimulusList(row).value("onsetTime")		            stimulusList(row).value("gap") = previousOffset - currentOnset  // -ve = gap, +ve = overlap		          next row		          		          // store the completed set of stimuli.		          currentSet.addStimulus stimulusList		          		        end if		        		        // finally, complete the processing of the position data.		        // first, we need to zero everything relative to an origin.  If there are stimuli, we use the initial stimulus location.		        // (see startX, Y, Z, etc derived from the stimuli above). Otherwise, we use the first data sample:		        if numOfStimuli <= 0  then		          baseByte = (primarySensor -1) * 8		          startX = armData.doubleValue(basebyte + 64)		          startY = armData.doubleValue(basebyte + 128)		          startZ = armData.doubleValue(basebyte + 192)		        end if		        		        // now actually get the samples:		        upperBound = numOfSamples -1		        for row = 0 to upperBound		          baseByte = (primarySensor -1) * 8 + row * 512		          sampleTime = armData.doubleValue(basebyte) - baseTime      // 1st 8 bytes of the row		          		          p = new dataPoint("MoVE", 1)  // source of data = MoVE and 1 channel of data (i.e. sensor) per sample.		          p.t = sampleTime		          p.x = armData.doubleValue(basebyte + 64) - startX   // 2nd 8 bytes, etc...  Subtract the start stimulus coords to act as a spatial zero		          p.y = armData.doubleValue(basebyte + 128) - startY  // if there are no stimuli, these values should be 0, which may cause problems with plotting the data		          p.z = armData.doubleValue(basebyte + 192) - startZ		          'calcPythagoreanDisplacement(dictionary(p))  // calculate the 1D distance from the origin to the point.		          		          // we also need to do a check for another buffer problem (another aspect of the tardis bug) where, instead of one sample appearing to occur 4.1666 ms		          // its predecessor, it would appear to be approx 120 s later.  In that case, it indicates that the sample with the large		          // timestamp increase is actually the first valid sample.  Everything prior to that was invalid.  But the duration of those samples was correct,		          // so we need to subtract the number of invalid samples * 4.1666 ms from the time stamp of the first valid sample to find when the data stream began:		          if sampleTime - prevSampleTime > 0.005 then  // testing to see if the sample is more than 10 ms later than its predecessor, as it should be about 4.16666 ms		            bufferProblemDetected = true		            sampleNumberBufferProblemDetectedIn = row		          end if		          		          // insert a check to see that each sample follows the previous one in time.  There is an occasional bug in the MoVE system where a sample		          // will have a time stamp indicating it occurred before its predecessor.  These should be marked as invalid.  Sometimes Liberty also drops packets, leading to data which is all NaNs.		          // The way to test for NaNs in REALbasic is to test for equality:		          if sampleTime <> sampleTime  then  // the time stamp is NaN		            p.valid = false		            countOfInvalidPointsInThisSet = countOfInvalidPointsInThisSet + 1		            prevSampleTime = prevSampleTime + sampleInterval  // so as not to propagate NaN values		            		          elseif sampleTime < 0 then // another buffer problem: the time stamp is wrong so need to calculate a new one		            p.valid = false		            countOfInvalidPointsInThisSet = countOfInvalidPointsInThisSet + 1		            prevSampleTime = prevSampleTime + sampleInterval  // so as not to propagate NaN values		            p.t = prevSampleTime  // now need to keep manual count of the time value, as it would otherwise go negative.		          else		            p.valid = true		            prevSampleTime = sampleTime		          end		          		          		          // store the sample		          tempDataPointStore.append p		          		        next row		        		        // correct the buffer problem		        if bufferProblemDetected then		          //  shift the crap early samples up in time to join the first valid sample, and invalidate them		          upperBound = sampleNumberBufferProblemDetectedIn - 1		          for row = upperBound downTo 0		            tempDataPointStore(row).t = tempDataPointStore(row+1).t - sampleInterval		            tempDataPointStore(row).valid = false		            countOfInvalidPointsInThisSet = countOfInvalidPointsInThisSet + 1		          next		          		          // calculate the actual baseTime at which data started:		          baseTime = tempDataPointStore(0).t		          		          // now zero all samples time values to the correct base time:		          upperBound = numOfSamples -1		          for row = 0 to upperBound		            p = tempDataPointStore(row)		            p.t = p.t - baseTime		            // store the sample		            currentSet.addDataPoint p		          next		          		        else  // no problem, just store the samples		          upperBound = numOfSamples -1		          for row = 0 to upperBound		            currentSet.addDataPoint tempDataPointStore(row)		          next		          		        end if		        		        		        // if the first set has just been imported,  send the session and the first set to the window for display.		        // But continue importing subsequent sets in the background and adding them to the stored session		        if group = 1 then		          mParentWindow.displayProgressInfo("Processing and plotting first trial.  Will continue importing any others in the background.")		          mParentWindow.addSession mSession		          // can't set these attributes until now as they require a reference to the parentWindow as they cause info to be added to the window's textfields		          mSession.subject_group = MMGetStringAttribute(file_ID, "/", "group")		          mSession.subject_id = MMGetStringAttribute(file_ID, "/", "subject_id")		          mSession.subject_sex = MMGetStringAttribute(file_ID, "/", "sex")		        end if		        		        // tidy up & get ready for next set		        currentSet.numberOfInvalidPoints = countOfInvalidPointsInThisSet		        mSession.addSet currentSet		        bufferProblemDetected = false		        redim tempDataPointStore(-1)		        		        		      end if		      		      // otherwise, get the next trial from the file		    next group		    		    		    		  end if		  		  mParentWindow.displayProgressInfo("Completed importing " + str(currentSetNumberFromCounting) + " data sets.")		  mParentWindow.turnProgressWheelOn(false)		  'gLog "Exiting run event of HDF5parserThread."		  		exception err		  gHandleException err, "Run event of HDF5dataParser thread."		End Sub	#tag EndEvent	#tag Method, Flags = &h1		Protected Function attributeOfThisNameExists(loc_ID as integer, attributeName as string) As boolean		  dim status as integer		  		  // to check if there is an attribute in the file with a particular name		  		  status = H5LTfind_attribute(loc_ID, attributeName)		  		  if status <> 1 then //   there is no such trial		    		    return false		    		  else  // a trial of that name exists		    		    return true		    		  end if		  		  		  		exception err		  gHandleException err, "attributeOfThisNameExists method of HDF5dataParser thread."		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub calcPythagoreanDisplacement(point as dictionary)		  // works out the Pythagorean distance (m) from the origin of a dataPoint or stimulus		  // (i.e. a 1 dimensional value rather than the 3 xyz components).		  		  dim magnitude as single		  		  magnitude = sqrt(point.value("x")^2 + point.value("y")^2 + point.value("z")^2)		  		  point.value("m") = magnitude		  		exception err		  gHandleException err, "calcPythagoreanDisplacement method of HDF5dataParser thread."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(w as chartWindow)		  mParentWindow = w  // this lets the thread know which window to display a progress window within as a sheet.		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Destructor()		  'gLog "HDF5ParserThread destructor"		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function determineHDFfileVersionNumber(file_ID as integer) As single		  dim tempMem as memoryBlock		  dim status as integer		  		  tempMem = newMemoryBlock(4)		  		  		  status = H5LTget_attribute_float(file_ID, "/", "version", tempMem)		  		  if status < 0 then // this attribute didn't exist in version 1 of the file structure		    		    return 1.0		    		  else  // the file version is at least 2.0 and includes its version number in the attribute:		    		    return tempMem.singleValue(0)		    		  end if		  		  		  		exception err		  gHandleException err, "determineHDFfileVersionNumber method of HDF5dataParser thread."		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function determinePrimarySensorFromFile(file_ID as integer) As integer		  dim tempMem as memoryBlock		  dim status as integer		  		  // the existence of the primarySensor attribute does not neatly map on to the HDF file version numbering system.		  // So we need to check whether it exists:		  		  tempMem = newMemoryBlock(4)		  status = H5LTget_attribute_int(file_ID, "/", "primarySensor", tempMem)		  		  if status < 0 then // this attribute wasn't recorded		    		    return -1 // the calling code will then ask the user what to do		    		  else  // extract the primarySensor information		    		    return tempMem.UInt32Value(0)		    		  end if		  		  		  		exception err		  gHandleException err, "determineHDFfileVersionNumber method of HDF5dataParser thread."		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub getSetAttributesFromFile(trialName as string, currentSet as iViewSet, file_ID as integer)		  dim status as integer		  dim trial_ID as integer		  		  // get a handle to the trial itself, and use this rather than the file_ID handle when needed:		  trial_ID = H5Gopen(file_ID, trialName)		  		  		  // find out what type of trial this is (from the 'type' attribute of this trial), and other info, setting some default values if not specified.		  // Use a mixture of calls to attributeOfThisNameExists and objectOfThisNameExists as required:		  		  'if self.attributeOfThisNameExists(trial_ID, "type") then		  currentSet.testType = MMGetStringAttribute(file_ID, trialName, "type")		  'else		  'currentSet.testType = "unspecified"		  'end if		  		  'if self.attributeOfThisNameExists(trial_ID, "description") then		  currentSet.description = MMGetStringAttribute(file_ID, trialName, "description")		  'else		  'currentSet.description = "unspecified"		  'end if		  		  'if self.attributeOfThisNameExists(trial_ID, "phase_description") then		  currentSet.phase = MMGetStringAttribute(file_ID, trialName, "phase_description")		  'else		  'currentSet.phase = "unspecified"		  'end if		  		  if self.objectOfThisNameExists(trial_ID, "gain") then		    currentSet.movementFeedbackGain = MMGetSolitaryFloat(file_ID, trialName + "/gain")		  else		    currentSet.movementFeedbackGain = 1.0		  end if		  		  if self.objectOfThisNameExists(trial_ID, "feedback") then		    currentSet.movementFeedbackVisible = MMGetSolitaryFloat(file_ID, trialName + "/feedback")		  else		    currentSet.movementFeedbackVisible = 1		  end if		  		  		exception err		  gHandleException err, "getSetAttributesFromFile method of HDF5dataParser thread."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function objectOfThisNameExists(file_ID as integer, trialName as string) As boolean		  dim status as integer		  		  // to check if there is a group in the file with a particular name (e.g. "trial_0009").		  		  status = H5LTfind_dataset(file_ID, trialName)		  		  if status <> 1 then //   there is no such trial		    		    return false		    		  else  // a trial of that name exists		    		    return true		    		  end if		  		  		  		exception err		  gHandleException err, "objectOfThisNameExists method of HDF5dataParser thread."		End Function	#tag EndMethod	#tag Note, Name = About		This thread was created to import data from HDF5 files containing arm movements from the MoVElab.		Designed to be equivalent to the original parserThread which imports Saskia's data from iView text files.	#tag EndNote	#tag Property, Flags = &h1		Protected mParentWindow As chartWindow	#tag EndProperty	#tag Property, Flags = &h1		Protected mSession As iViewSession	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Priority"			Visible=true			Group="Behavior"			InitialValue="5"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="StackSize"			Visible=true			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass