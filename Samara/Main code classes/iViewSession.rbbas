#tag ClassClass iViewSession	#tag Method, Flags = &h0		Sub addSet(d as iViewSet)		  dim numOfGraphPics as integer		  		  // store nil objects in the cache of the pictures representing each set, as they haven't been created yet.		  numOfGraphPics = uBound(mGraphPic,1) + 1		  redim mGraphPic(numOfGraphPics, 1)		  mGraphPic(numOfGraphPics,0) = nil		  mGraphPic(numOfGraphPics,1) = nil		  		  d.sourceOfData = mSourceOfData		  mSets.append d		  self.parentWindow.setSelectorPopup.addRow(str(d.number))		  if self.parentWindow.setSelectorPopup.listCount > 1 then self.parentWindow.setSelectorPopup.enabled = true // only enable the button if there is another set available to choose.		  		  if uBound(mSets) = 0 then		    // carry out those things need only when the first set is shown		    self.displayforFirstTime		    		  else		    		    if d.testType = "" then		      // in some files with many short tests, there might only be one test type config message instead of one per set.		      // in that case, assume that the type specified for the first test applies to all:		      d.testType = mSets(0).testType		    end		    		    if not d.analysisTypeSpecified then		      // in some files with many short tests, there might only be one test type config message instead of one per set.		      // in that case, assume that the type specified for the first test applies to all:		      d.analyse2D = mSets(0).analyse2D		    end if		    		  end if		  		  		exception err		  gHandleException err, "addSet method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function backgroundPictureRefFromName(fileName as string) As picture		  // the session object maintains a central list of pictures so that the iViewSet objects just maintain		  // references to them in their backGroundImage objects rather than creating a proliferation of new instantiations of each image.		  		  		  if mBackgroundPicturesByName.hasKey(fileName)  then		    		    return mBackgroundPicturesByName.value(fileName)		    		  else		    		    return nil		    		  end if		  		exception err		  gHandleException err, "backgroundPictureRefFromName method of iViewSession class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function binocular() As boolean		  return mSets(mSelectedSetIndex).binocular		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub breakCircularReferences()		  // break circular references to allow memory to be freed up when a chartWindow is closed.		  // a cascade of these messages is initiated when a window is closed.		  		  dim i, upperLimit as integer		  		  		  		  upperLimit = uBound(mSets)		  if upperLimit > -1 then  // if there are sets to be removed		    for i = 0 to upperLimit		      mSets(i).breakCircularReferences // tell them to remove their own circular references		      mSets(i) = nil		    next		  end if		  		  mDataWindow.breakCircularReferences		  mDataWindow = nil		  parentWindow = nil		  		  		  		exception err		  gHandleException err, "breakCircularReferences method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub changeYAxisScale(upwards as boolean)		  // change y axis scaling in response to keyboard input		  		  dim changed as boolean		  dim components() as string		  		  if keyboard.asyncControlKey then  // the user wants to scale the velocity graphs.		    if sourceOfData = "iView" then		      components.append "vx"		      components.append "leftvx"		      components.append "rightvx"		      		    else		      components.append "v"		      components.append "vx"		      components.append "ax"		      components.append "a3"		      		    end if		    changed = mSets(mSelectedSetIndex).changeYAxisScale(upwards, components)		    		  else  // scale other graphs		    		    if sourceOfData = "iView" then		      components.append "x"		      components.append "y"		      components.append "leftx"		      components.append "lefty"		      components.append "rightx"		      components.append "righty"		    else		      components.append "x"		      components.append "y"		      components.append "z"		    end if		    		    changed = mSets(mSelectedSetIndex).changeYAxisScale(upwards, components)		  end if		  		  // only redraw if the y axes were actually changed		  if changed then		    self.displaySet		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub compressCursors()		  // in response to a keypress (9), make all the cursors jump back to the position of the first one.		  		  mSets(mSelectedSetIndex).compressCursors		  		  self.displaySet  //  don't need to recalculate graph as it hasn't changed.  Just redraw it.		  		  mChartWindow.displayCursorData mSets(mSelectedSetIndex).getCursorDisplayData // get updated numeric values for the cursor locations send those values to the chartWindow for display		  		  		exception err		  gHandleException err, "compressCursors method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub compressHigherCursors()		  // in response to a keypress (8), make all the cursors > #3 jump back to the position of the #3.		  		  mSets(mSelectedSetIndex).compressHigherCursors		  		  self.displaySet  //  don't need to recalculate graph as it hasn't changed.  Just redraw it.		  		  mChartWindow.displayCursorData mSets(mSelectedSetIndex).getCursorDisplayData // get updated numeric values for the cursor locations send those values to the chartWindow for display		  		  		exception err		  gHandleException err, "compressCursors method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor()		  'gLog "iViewSession constructor"		  mDataWindow = new dataWindow		  mMeasurementWindow = new measurementWindow		  mGraphsToDisplay = new dictionary		  mBackgroundPicturesByName = new dictionary		  		  		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Destructor()		  'gLog "iViewSession destructor"		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub detectNextSaccade()		  // tell the iViewSet object to calculate new cursor positions if possible to detect the next saccade		  mSets(mSelectedSetIndex).moveCursorsToNextMovement		  // redisplay the charts, which will be done using the updated cursors		  self.displaySet		  // get updated numeric values for the cursor locations send those values to the chartWindow for display:		  mChartWindow.displayCursorData mSets(mSelectedSetIndex).getCursorDisplayData		  		  		exception err		  gHandleException err, "detectNextSaccade method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub displayforFirstTime()		  // called the first time a data set is added		  		  dim canvasWidth, canvasHeight as integer		  dim chartGroup2D as group2D		  		  // Deal here with "session-level" interface matters, such as choosing between sets,		  // and other session info.		  		  // populate the list of available test types		  select case mSourceOfData		    		  case "iView"		    mChartWindow.testTypePopUp.addrow "Prosaccade"		    mChartWindow.testTypePopUp.addrow "Anti-saccade"		    mChartWindow.testTypePopUp.addrow "Self-paced"		    mChartWindow.testTypePopUp.addrow "Predictive"		    mChartWindow.testTypePopUp.addrow "Memory-guided"		    mChartWindow.testTypePopUp.addrow "Delayed"		    mChartWindow.testTypePopUp.addrow "Fixation"  // no code to analyse this yet!		    		    		  case "MoVE"		    mChartWindow.testTypePopUp.addrow "Ballistic"		    mChartWindow.testTypePopUp.addrow "Self-paced"		    mChartWindow.testTypePopUp.addrow "Predictive"		    mChartWindow.testTypePopUp.addrow "Visual"		    mChartWindow.testTypePopUp.addrow "Memory"		  end select		  		  'self.makeSelectedSetDirty		  self.displaySet  // tell the selected set to draw its plot		  filterButterworth.checked = true  // set the filter menu item to its default setting		  self.syncGUIwithSet  // this has to be called after the set is displayed or else the GUI elements will not get the correct values (eg filter type, etc)		  self.parentWindow.enableAllControls(true) // the controls in the window are disabled.  Need to enable them now that data is becoming available		  		  		exception err		  gHandleException err, "displayInChartWindow method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub displayGraphComponent(component as string, show as boolean)		  // enable or disable the given component (e.g. x, y, vx,..) as changed by the user by checking or unchecking the relevant menu		  mGraphsToDisplay.value(component) = show		  self.makeSelectedSetDirty		  self.displaySet		  		exception err		  gHandleException err, "displayGraphComponent method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub displayHighlightedStimulus()		  app.mouseCursor = system.cursors.Wait		  		  mSets(mSelectedSetIndex).displayHighlightedStimulus(TRUE)		  self.displaySet		  mSets(mSelectedSetIndex).displayHighlightedStimulus(FALSE) // so it doesn't "stick"		  app.mouseCursor = system.cursors.standardPointer		  		  		  		exception err		  gHandleException err, "displayHighlightedStimulus method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub displayProgressInfo(message as string)		  // called by the iViewSet class when it needs to show some status info to the user (e.g. when applying a filter)		  		  mChartWindow.displayProgressInfo(message)		  		exception err		  gHandleException err, "displayProgressInfo method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub displaySet(destinedForPrinter as boolean = FALSE)		  // this method can be invoked by the chartWindow in its resized event.  Otherwise it is always called by the iViewSession class itself,		  // generally in response to user events.		  // also called by the iViewSet itself when it feels it needs to be redrawn (it can't do this itself directly as it doesn't know the		  // graphics context into which it will be drawn).		  		  'gLog "displaySet method of iViewSession class"		  		  dim width, height, thumbWidth, thumbHeight as integer		  dim component() as string		  dim selectedSet as iViewSet		  dim componentPic, twoDPic as picture		  dim g as graphics		  dim ps as printerSetup		  dim resolution as integer = 72		  dim i, upperBound as integer		  		  selectedSet = mSets(mSelectedSetIndex)		  // access the cached graph pictures:		  twoDPic = mGraphPic(mSelectedSetIndex,1)		  componentPic = mGraphPic(mSelectedSetIndex,0)		  		  		  if not destinedForPrinter then		    		    if componentPic <> nil and self.display2D = selectedSet.LastPlottedas2D and not selectedSet.dirty then		      // i.e. we don't need to recalculate anything, just redraw whatever we already have stored plus any moved cursors, and then return		      		      if self.display2D then		        parentWindow.chartCanvas.setPlotPicture twoDPic  // send the bitmap to the twoDCanvas		        parentWindow.thumbCanvas.setPlotPicture componentPic		      else		        componentPic.objects = selectedSet.drawCursors  // get the latest cursors from the set		        parentWindow.chartCanvas.setPlotPicture componentPic  // send the bitmap and the cursors to the chartCanvas		        parentWindow.thumbCanvas.setPlotPicture twoDPic		      end if		      		      return		      		    end if		    		  end if		  		  // So we must need to redraw the graphs for some reason (e.g. the scale has been changed),		  // or the given set has not actually been displayed before, so there will be no existing picture to re-display,		  // or the set is dirty for some other reason (e.g. data was re-calibrated even though it was not the selected, visible set),		  // or the set needs to be printed (and thus needs to be redrawn into a high resolution graphics object).		  		  // first we must get a graphics object to draw into, from the printer or from a cached picture.		  if destinedForPrinter then		    		    ps = new printerSetup		    ps.maxHorizontalResolution=-1 // set the printer resolution to max possible		    ps.maxVerticalResolution=-1		    		    if parentWindow.mPrinterSettings <> "" then          // if the window property holding the setup info exists,		      ps.SetupString = parentWindow.mPrinterSettings // then apply it.		    end If		    		    g = openPrinterDialog(ps, parentWindow) // pass window reference to produce a sheet window under OS X		    if g = nil then return		    resolution = ps.HorizontalResolution		    		  else  // destined for on-screen display.  The graphics object comes from a cached or new picture.		    		    width = parentWindow.chartCanvas.width		    height = parentWindow.chartCanvas.height		    thumbWidth = parentWindow.thumbCanvas.width		    thumbHeight = parentWindow.thumbCanvas.height		    		    if self.display2D then		      if twoDPic = nil or (twoDPic.width <> width or twoDPic.height <> height) then twoDPic = newPicture(width, height, 32)		      g = twoDPic.graphics		      componentPic = newPicture(thumbWidth, thumbHeight, 32)		    else		      if componentPic = nil or (componentPic.width <> width or componentPic.height <> height) then componentPic = newPicture(width, height, 32)		      g = componentPic.graphics		      twoDPic = newPicture(thumbWidth, thumbHeight, 32)		    end if		    		  end if		  		  // determine which components will be plotted, according to a default set in the session.sourceOfData method		  // and as updated by the user changing the settings via the View menu.		  if selectedSet.sourceOfData = "iView" and selectedSet.binocular then		    // in this case we just have some fixed options until we can figure out something more clever		    component.append "leftx"		    component.append "lefty"		    component.append "rightx"		    component.append "righty"		    'component.append "leftvx"		    'component.append "rightvx"		    		  else  // use the stored options:		    		    upperBound = mGraphsToDisplay.count - 1		    for i = 0 to upperBound		      // if each key (say, x, y, vx, etc) is paired with a true value, then tell the set to display it.		      if mGraphsToDisplay.value(mGraphsToDisplay.key(i)) then component.append mGraphsToDisplay.key(i)		    next		    		  end		  		  		  // finally initiate the actual drawing		  if self.display2D then		    //  send the graphics for drawing the main 2D graph:		    selectedSet.display(g, nil, resolution, TRUE)		    		    if not destinedForPrinter then //draw the images to the window and store some cached versions		      		      parentWindow.chartCanvas.setPlotPicture twoDPic		      mGraphPic(mSelectedSetIndex,1) = twoDPic		      selectedSet.lastPlottedas2D = TRUE		      		      // now draw the component thumbnail:		      selectedSet.display(componentPic.graphics, component(), resolution, FALSE)		      componentPic.objects = nil // don't display the cursors in the thumbnail for the time being as they are still scaled for the larger image.		      parentWindow.thumbCanvas.setPlotPicture componentPic		      mGraphPic(mSelectedSetIndex,0) = componentPic		      		    else		      return // sends the graphics object to the printer		      		    end if		    		  else		    //  send the graphics for drawing the main component graph:		    selectedSet.display(g, component(), resolution, FALSE)		    		    if not destinedForPrinter then //draw the images to the window and store some cached versions		      		      componentPic.objects = selectedSet.drawCursors  // get the latest cursors from the set		      parentWindow.chartCanvas.setPlotPicture componentPic		      mGraphPic(mSelectedSetIndex,0) = componentPic		      selectedSet.lastPlottedas2D = FALSE		      //  and draw the 2D thumbnail:		      selectedSet.display(twoDPic.graphics, nil, resolution, TRUE)		      parentWindow.thumbCanvas.setPlotPicture twoDPic		      mGraphPic(mSelectedSetIndex,1) = twoDPic		      		    else		      return // sends the graphics object to the printer		      		    end if		    		  end if		  		  parentWindow.displayTrialInfo mSets(mSelectedSetIndex).getSetInfoDisplayData  // send text info describing the set to the window for display		  parentWindow.displayCursorData mSets(mSelectedSetIndex).getCursorDisplayData // get updated numeric values for the cursor locations send those values to the chartWindow for display		  		  		  		exception err		  gHandleException err, "displaySet method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub drawCrossHair(mouseX as integer, mouseY as integer)		  mSets(mSelectedSetIndex).drawCrossHair(mouseX, mouseY)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub editSaccadeData()		  dim measurements() as dictionary		  		  measurements = mSets(mSelectedSetIndex).getSaccadeData		  		  // a data set sends measurements to the session so that they can be displayed in the window which		  // the session maintains for that.		  		  if uBound(measurements) <> -1 then		    mDataWindow.showDataForEditing(measurements, self)		    mDataWindow.showModalWithin self.parentWindow		  end if		  		exception err		  gHandleException err, "editSaccadeData method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub exportProfiles()		  // export movement profiles to a text file, either in response to a user request or programatically		  		  dim profiles() as dataTraceForExport		  dim status as boolean		  dim i, j, numberOfSets, numberOfProfiles as integer		  dim set as iViewSet		  dim name as string		  dim dlg as saveAsDialog		  dim file as folderItem		  		  		  		  		  dlg = new saveAsDialog		  dlg.promptText="Choose where to save the movement profile text file."		  dlg.suggestedFileName= "Movement profiles.txt"		  dlg.title = "Save movement profile data"		  dlg.filter = "application/text"		  file = dlg.ShowModal		  if file = nil then return		  		  numberOfSets = uBound(mSets)		  		  for i = 0 to numberOfSets  // cycle through all sets		    set = mSets(i)		    if set.hasSaccadeData then  // only for ones with measurements,		      profiles = set.getMovementProfiles		      numberOfProfiles = uBound(profiles)		      name = self.label + " set " + str(set.number) + " profile.txt"		      for j = 0 to numberOfProfiles		        status = profiles(j).saveToTextFile(false, file.name, file.parent)  // export each trace, hopefully appending to the same file when needed		      next j		    end if		  next		  		  'profiles = mSets(mSelectedSetIndex).getMovementProfiles  // the user will want to export the currently visible set		  		  'if uBound(profiles) = -1 then return		  		  		exception err		  gHandleException err, "exportProfiles method of iViewSession class."		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub exportTraces(userRequested as boolean = true, location as folderItem = nil)		  // export movement traces to a text file, either in response to a user request or programatically		  		  dim trace as dataTraceForExport		  dim status as boolean		  dim i, numberOfSets as integer		  dim set as iViewSet		  dim name as string		  		  		  // tell the object to save itself to a file		  if userRequested then		    		    trace = mSets(mSelectedSetIndex).exportTrace  // the user will want to export the currently visible set		    status = trace.saveToTextFile(true)  // ask the user where to put it and what to call it		    		  else  // this request is to export a trace programatically  to the same folder as the measurement file, with		    // an automatically generated filename.		    numberOfSets = uBound(mSets)		    		    for i = 0 to numberOfSets  // cycle through all sets		      set = mSets(i)		      if set.hasSaccadeData then  // only for ones with measurements,		        trace = set.exportTrace		        name = self.label + " set " + str(set.number) + " trace.txt"		        status = trace.saveToTextFile(false, name, location)  // export their traces		      end if		      		    next		    		    		  end if		  		exception err		  gHandleException err, "exportTraces method of iViewSession class."		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub filter(filterType as string)		  mSets(mSelectedSetIndex).filter filterType  // apply the given filter to the data		  self.displaySet  // redraw the filtered data		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function howManySetsHaveUnSavedSaccadeData() As integer		  // lets the chartWindow query whether any measured saccade data exists so it can pop up a warning		  // dialog to prompt the user to save any data.		  		  // cf selectedSetHasSaccadeData, which gives info about only the selected set for menu enabling purposes		  		  dim i, upperBound, numberOfSetsWithData as integer = 0		  		  upperBound = uBound(mSets)		  		  for i = 0 to upperBound		    if mSets(i).hasUnsavedData then numberOfSetsWithData = numberOfSetsWithData + 1		  next		  		  return numberOfSetsWithData		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub makeSelectedSetDirty()		  // indicate that the currently visible set needs to be recalculated before being redrawn (i.e. the data has changed in some way, not just the cursor positions).		  mSets(mSelectedSetIndex).dirty = TRUE		  		exception err		  gHandleException err, "makeSelectedSetDirty method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub manualRecalibration(reset as boolean, factor() as double, offset() as double, applyToAllSets as boolean, component as string)		  dim i, numOfSets as integer		  		  if applyToAllSets then		    		    numOfSets = uBound(mSets)		    for i = 0 to numOfSets		      mSets(i).manualRecalibration reset, factor, offset, FALSE, component  // each set thinks it the only one getting calibrated, or else we get into an infinite loop		      glog "Session sending recal to set: " + str(i)		    next		    		  else		    		    mSets(mSelectedSetIndex).manualRecalibration reset, factor, offset, FALSE, component		    		  end if		  		  'self.displaySet  // now the set knows if it is on show and controls its own display.		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub measure()		  // this method is called in response to the user pushing 'enter' or 'return' to take measurements from the current cursor positions		  		  // also need to check for some modifier keys which allow the user to force the stimulus selection algorithm to choose an adjoining		  // stimulus rather than the automatic one.  A value 0 (default) means		  // that the saccade is measured relative to the automatically detected stimulus.  A value of -1 forces the preceding stimulus		  // to be used and +1 means the next one is selected.  This is because due to very slow or very anticipatory latencies, the		  // stimulus selection algorithm may not correctly identify the stimulus which corresponds to the movement.		  		  dim stats as dictionary		  dim set as iViewSet		  		  set = mSets(mSelectedSetIndex)		  		  // if we are in calibration mode, we don't do anything with the returned data, as the set has already dealt with it.		  // Otherwise, we display data from the measurement.		  		  if not set.postHocCalibrationMode then		    		    if keyboard.asyncControlKey then		      stats = set.measure(1)  // select the stimulus following the automatically-chosen one		      		    elseif keyboard.asyncShiftKey then		      stats = set.measure(-1)  // select the stimulus preceding the automatically-chosen one		      		    else		      stats = set.measure // select the automatically-chosen stimulus (generally correct).		    end if		    		    		    if stats <> nil then  // the method returns nil if there is a problem.		      		      // once a measurement is made, then the user shouldn't be able to change the analysis again		      // between 1D and 2D or else we will end up with inconsistent dependent variables in succcessive measurements:		      mChartWindow.analysisGroupBox.enabled = FALSE		      		      // display the measured values in a sheet window for the user to check/edit:		      mMeasurementWindow.resetToDefaults  // clear settings which would otherwise persist from the last time it was shown.		      mMeasurementWindow.displayStats(stats, self)		      mMeasurementWindow.showModalWithin parentWindow		      		    end if		    		  else  // we are in calibration mode, so we don't do anything with the returned data, so 'call' the method rather than use what it returns.		    call set.measure		    		  end if		  		exception err		  gHandleException err, "measure method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub measureREDO()		  // ReDo all the existing measurements in each set. This allows data to be updated when, for example, we want to add a new dependent variable to existing measurements		  // or if there was a bug in previous measurements, filtering was incorrect, etc. It will cycle through each existing measurement, shift the cursors to their recorded timepoints,		  // and re-measure, being careful to extract the human-generated data from the previous one (such as comments or when another stimulus was selected rather than the default).		  		  dim i as integer		  dim set as iViewSet		  dim result as string		  dim alert as new messageDialog		  dim btn as messageDialogButton		  		  app.mouseCursor = system.cursors.Wait		  		  for i = 0 to uBound(mSets)  // cycle through all sets		    		    set = mSets(i)		    if set.hasSaccadeData then		      		      // some necessary tasks (such as filtering) occur only when the set is first displayed.  If the set hasn't been displayed, we must carry them out.		      // Ideally we would display the set while working, but the set.display() method currently shifts the cursors around in some situations and so		      // would need to be altered to be compatible with the fixed cursor positions required by the re-measurement process:		      if not set.initialised then set.preDisplayTasks		      result = set.measureREDO		      		      if result <> "OK" then		        alert.Message = "An error occurred when re-measuring set " + str(i) + ": " + result		        btn = alert.showModalWithin(self.parentWindow)		        return		      end if		      		    end if		    		  next		  		  app.mouseCursor = system.cursors.StandardPointer		  self.saveSaccadeData		  		  		exception err		  gHandleException err, "measureREDO method of iViewSession class."		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub moveAlongTimeAxis(leftward as boolean, amount as single = 1)		  // if cursors are shown, move them.  Otherwise move the data itself		  		  dim set as iViewSet		  dim chartGroup as group2D		  		  set = mSets(mSelectedSetIndex)		  		  		  if set.canMoveAlongTimeAxis(leftward, amount) then		    self.makeSelectedSetDirty		    self.displaySet  // only if the set actually needs to be redrawn		  end if		  		  		exception err		  gHandleException err, "moveAlongTimeAxis method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub moveCursors(leftward as boolean, amount as single = 1)		  // if cursors are shown, move them.  Otherwise move the data itself		  		  dim set as iViewSet		  dim chartGroup as group2D		  		  set = mSets(mSelectedSetIndex)		  		  if set.showCursors then  // only move the cursors if they are visible		    if set.moveCursor(leftward, amount) then  // returns true if the cursors actually moved		      self.displaySet  // the graph doesn't need to be recalculated, just the cursors need to be redrawn		      mChartWindow.displayCursorData mSets(mSelectedSetIndex).getCursorDisplayData // get updated numeric values for the cursor locations send those values to the chartWindow for display		      		    end if		  end if		  		exception err		  gHandleException err, "moveCursors method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub postHocCalibration()		  mSets(mSelectedSetIndex).togglePostHocCalibrationMode   // switch on calibration mode for that set		  		  		exception err		  gHandleException err, "postHocCalibration method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub reattachMeasurements()		  // import previously made measurements from a text file.  Parse them into dictionaries and send to their		  // respective sets for storage.		  		  dim dlg as openDialog		  dim file as folderItem		  dim textInput as textInputStream		  dim rowFromFile, labels(), currentStringValues() as string		  dim i, numberOfFields, setNumber as integer		  dim currentMeasurement as dictionary		  		  // select the file for importing		  dlg = new openDialog		  dlg.title="Select a text file containing measurements previously made from this recording:"		  file = dlg.showModalWithin(mChartWindow)		  if file = nil then return		  		  mChartWindow.turnProgressWheelOn(true)		  mChartWindow.displayProgressInfo("Re-attaching measurements from text file.")		  		  // get the field names from the first row of the file:		  textInput = file.openAsTextFile		  rowFromFile = textInput.ReadLine		  labels = split(rowFromFile, chr(9))		  call labels.pop  // remove the last item as it is a blank due to an excess tab character after the final field name		  numberOfFields = uBound(labels)		  		  // cycle through each row of the file, storing each value in a dictionary, keyed by its field name.		  do		    currentMeasurement = new dictionary		    rowFromFile=textInput.ReadLine		    currentStringValues = split(rowfromFile, chr(9))		    		    for i = 0 to numberOfFields		      // all values are stored as strings in file.  But internally, we distingush between numbers and strings.  So need to check which is what:		      if currentStringValues(i) = str(val(currentStringValues(i))) then  // this must be a number, as val turns a string into a zero.		        currentMeasurement.value(labels(i)) = val(currentStringValues(i))  // store the number		      else		        currentMeasurement.value(labels(i)) = currentStringValues(i)  // store the string		      end if		    next		    		    // decide on which set this measurement is associated with, and send it there for storage:		    if currentMeasurement.hasKey("Set number") then // iView data		      mSets(currentMeasurement.value("Set number")-1).storeMeasurement currentMeasurement		    else		      mSets(currentMeasurement.value("Trial number")-1).storeMeasurement currentMeasurement		    end if		    		  loop until textInput.EOF		  		  textInput.close		  self.collateMeasurements = TRUE  // generally, will want to do this		  mChartWindow.displayProgressInfo("Re-attaching measurements completed.")		  mChartWindow.turnProgressWheelOn(false)		  		  		  		  		exception err		  		  msgBox "There was an exception when attempting to re-attach previous measurements from a file.  The likely cause of this is a problem with the content or structure of the file. Check that the measurement file was actually produced from THIS recording."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub returnEditedDataToSet(measurements() as dictionary)		  mSets(mSelectedSetIndex).updateSaccadeData(measurements)		  		exception err		  gHandleException err, "returnEditedDataToSet method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub saveSaccadeData()		  // this method is called in response the user choosing the 'save saccade data' menuitem.		  // exports the set of saccade measurements.  The menuitem is only enabled when data exists, so don't need to worry about checking that.		  // may export data just from the selected set or may collate information from all measured sets.		  // additionally may need to export movement traces to text files at the same selected location.		  		  dim file as folderItem		  dim fileStream as textOutputStream		  dim dlg as SaveAsDialog		  dim i, numberOfSets as integer		  dim fileName as string		  dim writeHeader as boolean = true		  dim set as iViewSet		  		  'gLog "saveSaccadeData method of iViewSession class"		  		  // come up with a suggested filename either for a given set or for multiple ones		  if self.collateMeasurements then		    fileName = self.label + ", multiple sets.txt"		  else		    fileName = self.label + " set " + str(mSets(mSelectedSetIndex).number) + ".txt"		  end if		  		  dlg = new SaveAsDialog		  dlg.promptText="Enter a filename for this saccade measurement data"		  dlg.suggestedFileName= fileName		  dlg.title = "Save saccade measurement data"		  dlg.filter = "application/text"		  file = dlg.ShowModalWithin(parentWindow)		  		  if file <> nil then		    fileStream = file.createTextFile		    self.parentWindow.turnProgressWheelOn(true)		    		    if not collateMeasurements then		      // just save the selected set's data		      mSets(mSelectedSetIndex).writeMeasurementsToFile(fileStream, writeHeader)		      		    else  // loop through all sets and, if each has data, write it to the same file.		      		      numberOfSets = uBound(mSets)		      for i = 0 to numberOfSets		        set = mSets(i)		        		        if set.hasSaccadeData then		          set.writeMeasurementsToFile(fileStream, writeHeader)		          writeHeader = false  // don't write the header again after the first lot of data is added to the file		          self.parentWindow.displayProgressInfo "Saved measurements for set " + str(set.number)		        end if		        		      next		      		    end if		    		    fileStream.close		    		    // if necessary export a movement trace for each set which has measurements		    		    		    if self.exportTracesWithMeasurements then		      self.parentWindow.displayProgressInfo "Beginning export of movement traces..."		      self.exportTraces(false, file.parent)		      self.parentWindow.displayProgressInfo "Completed export of movement traces."		      		    end if		    		  end if		  		  self.parentWindow.turnProgressWheelOn(false)		  		  		exception err		  gHandleException err, "saveSaccadeData method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub selectCursors(cursorSelection as integer)		  // the session receives an integer (0 = "all", 1, 2, 3, 4, 5, 6) from the interface when the user chooses which cursors should be selected for moving		  		  mSets(mSelectedSetIndex).selectCursors cursorSelection		  		exception err		  gHandleException err, "selectCursors method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function selectedSetHasSaccadeData() As boolean		  // lets the chartWindow query whether any measured saccade data exists so it can enable the "save as" menuitem when required		  		  return mSets(mSelectedSetIndex).hasSaccadeData		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function selectedSetHasUnsavedSaccadeData() As boolean		  // lets the chartWindow query whether any measured saccade data exists so it can enable the "save" menuitem when required		  		  return mSets(mSelectedSetIndex).hasUnsavedData		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub selectSet(setNumber as integer)		  // This method decides which set (ie block of trials) is currently selected for display.  It		  // is invoked by the set popup menu in the chart window		  		  'gLog "selectSet method of iViewSession class"		  		  mSets(mSelectedSetIndex).currentlySelected =FALSE  // deselect current set		  mSelectedSetIndex = setNumber		  mSets(mSelectedSetIndex).currentlySelected =TRUE // and let new one know that it is now on show		  		  self.displaySet		  self.syncGUIwithSet  // this has to be called after the set is displayed or else the GUI elements will not get the correct values (eg filter type, etc)		  		  		exception err		  gHandleException err, "selectSet method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub setTestType(testType as string)		  // lets the selected set know what testtype it is.  At the moment this is done in response to a button in the UI.		  // In the future, it should be specified as a MSG in the iView data file.		  		  mSets(mSelectedSetIndex).testType = testType		  		exception err		  gHandleException err, "setTestType method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub showCursors(show as boolean)		  dim chartObjects as group2D		  		  mSets(mSelectedSetIndex).showCursors = show		  		  self.displaySet  // ie don't need to recalculate graph as it hasn't changed.  Just redraw it, with or without cursors		  mChartWindow.displayCursorData mSets(mSelectedSetIndex).getCursorDisplayData // get updated numeric values for the cursor locations send those values to the chartWindow for display		  		  		exception err		  gHandleException err, "showCursors method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub storeBackgroundPicture(imageFolder as folderItem, fileName as string, geometry as screenGeometry)		  // the session object maintains a central list of pictures so that the iViewSet objects just maintain		  // references to them in their backGroundImage objects rather than creating a proliferation of new instantiations of each image.		  		  // this method is called by the iViewParserThread when it finds a background image name in the recorded data		  		  dim pictureItem as folderItem		  dim backPic as picture		  dim g as graphics		  		  		  if  mBackgroundPicturesByName.hasKey(fileName)  then		    		    return // only add a picture file if it hasn't already been imported		    		  else		    		    if imageFolder <> nil then pictureItem = imageFolder.Child(filename)		    		    if pictureItem <> nil and pictureItem.Exists then		      backPic = pictureItem.OpenAsPicture		    end if		    		    // if the picture can't be found, create a dummy picture to represent it		    if backPic = nil then		      backPic = newPicture(geometry.pixelWidth, geometry.pixelHeight, 32)		      g= backPic.graphics		      g.foreColor = &CDDDDDD		      g.fillRect(0, 0, geometry.pixelWidth, geometry.pixelHeight)		      g.foreColor = &CAAAAAA		      g.textSize = 72		      g.drawString(fileName, geometry.pixelWidth/4, geometry.pixelHeight/2)		    end if		    		    // store the image in a dictionary corresponding to its fileName.		    mBackgroundPicturesByName.value(fileName) = backPic		    		    		    		  end if		  		exception err		  gHandleException err, "storeBackgroundPicture method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub storeMeasurement(measurement as dictionary)		  // if the user decides (in the measurementWindow instance) to accept a saccade measurement, it is sent back to the		  // set instance for storage and subsequent saving.		  		  mSets(mSelectedSetIndex).storeMeasurement measurement		  		  		exception err		  gHandleException err, "storeMeasurement method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub syncGUIwithSet()		  // get the GUI elements in sync with the newly selected set		  		  dim set as iViewSet		  dim testType, temp, filterType as string		  dim i as integer		  		  set = mSets(mSelectedSetIndex)		  		  		  mChartWindow.parametersBeingSetInCode = true		  		  mChartWindow.setSelectorPopup.listIndex = mSelectedSetIndex		  mChartWindow.zoomTimeAxisSlider.value = set.getZoomFactor		  ViewShowCursors.checked = set.showCursors		  mChartWindow.selectAnalysis(0).value = not set.analyse2D		  mChartWindow.selectAnalysis(1).value = set.analyse2D		  		  		  // set the text of the testType popup		  testType = set.testType		  mChartWindow.testTypePopUp.listIndex = -1  // if the testtype has not been set, or if it doesn't match an available choice, there should be no value selected		  		  if testType <> "" then		    // cycle through and find which row to select		    for i = 0 to mChartWindow.testTypePopUp.ListCount - 1		      temp = mChartWindow.testTypePopUp.list(i)		      // check if the test type equals the text in a given row of the testType popup.		      // unfortunately, several versions of some terms are used and so they should be interchangeable:		      if temp = testType or (temp = "Prosaccade" and testType = "Reflexive") or (temp = "Anti-saccade" and testType = "Antisaccade") then		        mChartWindow.testTypePopUp.listIndex = i		      end if		    next		  end if		  		  		  // set the correct filter menuitem to be checked		  filterType = set.getAppliedFilter		  filterButterworth.checked = false		  filterNone.checked = false		  filterTriangular.checked = false		  		  select case filterType		    		  case "None"		    filterNone.checked = true		    		  case "Triangular"		    filterTriangular.checked = true		    		  case "Butterworth"		    filterButterworth.checked = true		    		  end select		  		  // set the correct graph viewing check marks		  self.syncViewMenusWithSettings		  mChartWindow.displayCursorData mSets(mSelectedSetIndex).getCursorDisplayData // get updated numeric values for the cursor locations send those values to the chartWindow for display		  		  		  mChartWindow.parametersBeingSetInCode = false		  		exception err		  gHandleException err, "syncGUIwithSet method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub syncViewMenusWithSettings()		  // this is a public method, as it can be called either by the session.syncGUIwithSet method, or by the chartWindow activate event		  		  if mGraphsToDisplay <> nil then		    		    if self.sourceOfData = "MoVE" then		      MoVEXPosition.checked = mGraphsToDisplay.value("x")		      MoVEYPosition.checked = mGraphsToDisplay.value("y")		      MoVEZPosition.checked = mGraphsToDisplay.value("z")		      MoVEVelocity.checked = mGraphsToDisplay.value("vx")		      MoVEAcceleration.checked = mGraphsToDisplay.value("ax")		    else		      iViewHorizontalposition.checked = mGraphsToDisplay.value("x")		      iViewHorizontalVelocity.checked = mGraphsToDisplay.value("vx")		      iViewVerticalposition.checked = mGraphsToDisplay.value("y")		      iViewVerticalVelocity.checked = mGraphsToDisplay.value("vy")		    end if		    		  end if		  		exception err		  gHandleException err, "syncViewMenusWithSettings method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub updateCursorDisplayData()		  // This is triggered by a timer in the chartWindow which monitors whether the SHIFT or CONTROL		  // modifier keys are pressed , so that the cursor data (latency, selected stimulus, etc) can be updated immediately		  // to reflect which stimulus will be selected.		  		  mChartWindow.displayCursorData mSets(mSelectedSetIndex).getCursorDisplayData // get updated numeric values for the cursor locations send those values to the chartWindow for display		  		  		exception err		  gHandleException err, "updateCursorDisplayData method of iViewSession class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub zoomTimeAxis(zoomFactor as integer)		  // zooms the time axis in or out		  mSets(mSelectedSetIndex).zoomTimeAxis(zoomFactor)		  		  		  // plot the new chart		  self.displaySet		  		exception err		  gHandleException err, "zoomTimeAxis method of iViewSession class."		End Sub	#tag EndMethod	#tag Note, Name = About		This class holds the collection of sets which make up a recording session from iView	#tag EndNote	#tag ComputedProperty, Flags = &h0		#tag Note			Whether the iView data should be analysed as 2D (TRUE) or horizontally only (FALSE). This is called by the user			changing the setting in the interface. The iViewSet gets an initial value for this when it is created.		#tag EndNote		#tag Getter			Get			  return mSets(mSelectedSetIndex).analyse2D			End Get		#tag EndGetter		#tag Setter			Set			  mSets(mSelectedSetIndex).analyse2D = value			  self.displaySet			End Set		#tag EndSetter		analyse2D As boolean	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Note			A setting which determines whether measurements form all measured sets in this session should be collated in a single file			rather than just saving the measurements from the currently selected set.  Useful for when there are many sets, but which may			each contain only one measurement.			Changed via a menuitem toggling the value.		#tag EndNote		#tag Getter			Get			  return mCollateMeasurements			End Get		#tag EndGetter		#tag Setter			Set			  mCollateMeasurements = value			End Set		#tag EndSetter		collateMeasurements As boolean	#tag EndComputedProperty	#tag Property, Flags = &h0		#tag Note			Set in the iViewParserThread		#tag EndNote		dataImportCompleted As boolean = FALSE	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Note			currrently only set for iView data		#tag EndNote		#tag Getter			Get			  if mDate <> "" then			    return mDate			  else			    return "Not set"			  end if			End Get		#tag EndGetter		#tag Setter			Set			  mDate = value			End Set		#tag EndSetter		date As string	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Note			Whether the iView data should be displayed as 2D (TRUE) or as component line traces (FALSE)		#tag EndNote		#tag Getter			Get			  return mDisplay2D			End Get		#tag EndGetter		#tag Setter			Set			  			  // only replot the images if we are actually switching from one mode to the other (i.e. 2D vs component graphs).			  // i.e. ignore extraneous clicks in the interface to switch to a mode that is already current.			  			  if value <> mDisplay2D then			    mDisplay2D = value			    self.makeSelectedSetDirty			    self.displaySet  // the pictures need to be redrawn as they are switching from the thumbnail view to full size, and vice versa.			    mChartWindow.displayCursorData mSets(mSelectedSetIndex).getCursorDisplayData // get updated numeric values for the cursor locations send those values to the chartWindow for display			    			  end if			End Set		#tag EndSetter		display2D As boolean	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Note			A setting which determines whether movement traces should be exported in separate text files when measurement files are saved.			Changed via a menuitem toggling the value.		#tag EndNote		#tag Getter			Get			  return mExportTracesWithMeasurements			End Get		#tag EndGetter		#tag Setter			Set			  mExportTracesWithMeasurements = value			End Set		#tag EndSetter		exportTracesWithMeasurements As boolean	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mLabel			End Get		#tag EndGetter		#tag Setter			Set			  mLabel = value			End Set		#tag EndSetter		fileName As string	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mFileName			End Get		#tag EndGetter		#tag Setter			Set			  mFileName = value			End Set		#tag EndSetter		label As string	#tag EndComputedProperty	#tag Property, Flags = &h1		#tag Note			the session object maintains a central list of pictures so that the iViewSet objects just maintain			references to them in their backGroundImage objects rather than creating a proliferation of new instantiations of each image.		#tag EndNote		Protected mBackgroundPicturesByName As dictionary	#tag EndProperty	#tag Property, Flags = &h1		Protected mChartWindow As chartWindow	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			A setting which determines whether measurements form all measured sets in this session should be collated in a single file			rather than just saving the measurements from the currently selected set.  Useful for when there are many sets, but which may			each contain only one measurement.			Changed via a menuitem toggling the value.		#tag EndNote		Protected mCollateMeasurements As boolean = false	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Displays the set of measurements in a table.		#tag EndNote		Protected mDataWindow As dataWindow	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			currently only for iViewData, extract the date of the recording from the iView file and stick it here as a string.		#tag EndNote		Protected mDate As string	#tag EndProperty	#tag Property, Flags = &h1		Protected mDisplay2D As boolean = false	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			A setting which determines whether movement traces should be exported in separate text files when measurement files are saved.			Changed via a menuitem toggling the value.		#tag EndNote		Protected mExportTracesWithMeasurements As boolean = false	#tag EndProperty	#tag Property, Flags = &h1		Protected mFileName As string	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			// a stored copy of the drawn graphs so that they can be redrawn rapidly when needed (i.e. when not needed to be recalculated).			// for 2D plotting, made this a two column array.  The second column stores the 2D graphs.		#tag EndNote		Protected mGraphPic(-1,-1) As picture	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Hold a list of key/value pairs like:			X : true			vX: false						which indicates which graphs should and shouldn't be displayed.			Altered in response to the user, the current values are sent to the set to be displayed in the displaySet method.			Originally populated in the SourceOfData setter method.		#tag EndNote		Protected mGraphsToDisplay As dictionary	#tag EndProperty	#tag Property, Flags = &h1		Protected mLabel As string	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			A property able to be accessed by each child iViewSet to display the current measurement of a movement.		#tag EndNote		mMeasurementWindow As measurementWindow	#tag EndProperty	#tag Property, Flags = &h1		Protected mSelectedSetIndex As Integer = 0	#tag EndProperty	#tag Property, Flags = &h1		Protected mSets() As iViewSet	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Allows session to introspect where its data came from (iView or MoVE).			Set by the importing parser thread, and cascades from the session to the set, data, and chart			via the setter method		#tag EndNote		Protected mSourceOfData As string	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			the group to which the subject belongs (eg, PD, Control, etc).  Set in the HDF import, and should be able to be set by the user also and from the iView import		#tag EndNote		Protected mSubject_group As string = "????"	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			the ID number of the subject.  Set in the HDF import, and should be able to be set by the user also and from the iView import		#tag EndNote		Protected mSubject_id As string = "?????"	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			the sex of the subject.  Set in the HDF import, and should be able to be set by the user also and from the iView import		#tag EndNote		Protected mSubject_sex As string = "??"	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mChartWindow			End Get		#tag EndGetter		#tag Setter			Set			  mChartWindow = value			End Set		#tag EndSetter		parentWindow As chartWindow	#tag EndComputedProperty	#tag Property, Flags = &h0		#tag Note			Set in the HDF importer thread (i.e. MoVE data only).		#tag EndNote		primarySensor As Integer	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Note			Allows session to introspect where its data came from (iView or MoVE).			Set by the importing parser thread.  The session sets the same property in each iViewSet			as it is added to the session.		#tag EndNote		#tag Getter			Get			  return mSourceOfData			End Get		#tag EndGetter		#tag Setter			Set			  mSourceOfData = value			  			  select case value			    			  case "iView"			    // set which graphs will be displayed			    mGraphsToDisplay.value("x") = true			    mGraphsToDisplay.value("y") = true			    mGraphsToDisplay.value("v") = false			    mGraphsToDisplay.value("vx") = true			    mGraphsToDisplay.value("vy") = false			    			  case "MoVE"			    // disable some UI elements which are only used for eye data.			    mMeasurementWindow.antiSaccadeErrorComboBox.visible = false			    mMeasurementWindow.captionStaticText(0).visible = false			    mMeasurementWindow.captionStaticText(1).visible = false			    mMeasurementWindow.trialTypeComboBox.visible = false			    			    // set which graphs will be displayed			    mGraphsToDisplay.value("x") = true			    mGraphsToDisplay.value("y") = true			    mGraphsToDisplay.value("z") = true			    mGraphsToDisplay.value("vx") = true			    mGraphsToDisplay.value("vy") = false			    mGraphsToDisplay.value("vz") = false			    mGraphsToDisplay.value("v") = false			    mGraphsToDisplay.value("ax") = false			    mGraphsToDisplay.value("ay") = false			    mGraphsToDisplay.value("az") = false			    mGraphsToDisplay.value("a3") = false			  end select			  			  exception err			    gHandleException err, "sourceOfData setter method of iViewSession class."			End Set		#tag EndSetter		sourceOfData As string	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mSubject_group			End Get		#tag EndGetter		#tag Setter			Set			  mSubject_group = value			  if self.parentWindow <> nil then			    self.parentWindow.parametersBeingSetInCode = true			    self.parentWindow.groupField.text = value			    self.parentWindow.parametersBeingSetInCode = false			  end if			End Set		#tag EndSetter		subject_group As string	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mSubject_id			End Get		#tag EndGetter		#tag Setter			Set			  mSubject_id = value			  if self.parentWindow <> nil then			    self.parentWindow.parametersBeingSetInCode = true			    self.parentWindow.subjectIDField.text = value			    self.parentWindow.parametersBeingSetInCode = false			  end if			End Set		#tag EndSetter		subject_id As string	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mSubject_sex			End Get		#tag EndGetter		#tag Setter			Set			  mSubject_sex = value			  if self.parentWindow <> nil then			    self.parentWindow.parametersBeingSetInCode = true			    self.parentWindow.sexField.text = value			    self.parentWindow.parametersBeingSetInCode = false			  end if			End Set		#tag EndSetter		subject_sex As string	#tag EndComputedProperty	#tag ViewBehavior		#tag ViewProperty			Name="analyse2D"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="collateMeasurements"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="dataImportCompleted"			Group="Behavior"			InitialValue="FALSE"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="date"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="display2D"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="exportTracesWithMeasurements"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="fileName"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="label"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="primarySensor"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="sourceOfData"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="subject_group"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="subject_id"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="subject_sex"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass