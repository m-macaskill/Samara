#tag ClassClass OxMQuaternion	#tag Method, Flags = &h0		Function Angle(q As OxMQuaternion) As Double		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Returns the angle in radians between self and 'q'		  		  return Acos( (X*q.X) + (Y*q.Y) + (Z*q.Z) + (W*q.W) )		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor()		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Identity		  W = 1.0		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(rx As Double, ry As Double, rz As Double)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  SetRotate(rx, ry, rz)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub Constructor(qX As Double, qY As Double, qZ As Double, qW As Double)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Pointless to expose this, but it's useful for operator overloads		  		  X = qX		  Y = qY		  Z = qZ		  W = qW		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(axisang As OxMAxisAngle)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  SetRotate(axisang)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(q As OxMQuaternion)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  Copy(q)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(axis As OxMVector3, angle As Double)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  SetRotate(axis, angle)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Copy(q As OxMQuaternion)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  X = q.X		  Y = q.Y		  Z = q.Z		  W = q.W		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub CopyInverse(q As OxMQuaternion)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Copies an inverted version of q into this quaternion.		  ' This turns out to be really handy...		  		  X = -q.X		  Y = -q.Y		  Z = -q.Z		  W = q.W		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function DotProduct(q As OxMQuaternion) As Double		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  return ( (X*q.X) + (Y*q.Y) + (Z*q.Z) + (W*q.W) )		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Identity()		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  X = 0.0		  Y = 0.0		  Z = 0.0		  W = 1.0		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function Inverse() As OxMQuaternion		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Returns a new quaternion leaving this one untouched.		  		  Return New OxMQuaternion( -X, -Y, -Z, W )		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Invert()		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Negates the vector portion in place.		  		  X = -X		  Y = -Y		  Z = -Z		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub MultiplyForward(q As OxMQuaternion)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverfloWChecking False		  #endif		  		  ' Multiply in place: (self*q)		  Dim tx, ty, tz, tw As Double		  		  tx = ( (W*q.X) + (X*q.W) + (Y*q.Z) - (Z*q.Y) )		  ty = ( (W*q.Y) + (Y*q.W) + (Z*q.X) - (X*q.Z) )		  tz = ( (W*q.Z) + (Z*q.W) + (X*q.Y) - (Y*q.X) )		  tw = ( (W*q.W) - (X*q.X) - (Y*q.Y) - (Z*q.Z) )		  		  X = tx		  Y = ty		  Z = tz		  W = tw		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub MultiplyReverse(q As OxMQuaternion)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverfloWChecking False		  #endif		  		  ' Multiply in place: (q*self)		  ' NOTE: This is equivalent to Rb3D's Quaternion.MultiplyBy(q) which is always reversed.		  Dim tx, ty, tz, tw As Double		  		  tx = ( (W*q.X) + (X*q.W) - (Y*q.Z) + (Z*q.Y) )		  ty = ( (W*q.Y) + (Y*q.W) - (Z*q.X) + (X*q.Z) )		  tz = ( (W*q.Z) + (Z*q.W) - (X*q.Y) + (Y*q.X) )		  tw = ( (W*q.W) - (X*q.X) - (Y*q.Y) - (Z*q.Z) )		  		  X = tx		  Y = ty		  Z = tz		  W = tw		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Normalize()		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Sets length to 1.0 (unit quaternion)		  		  Dim mag As Double		  		  mag = (X*X) + (Y*Y) + (Z*Z) + (W*W)		  if mag = 0.0 then return		  mag = Sqrt(mag)		  		  X = X/mag		  Y = Y/mag		  Z = Z/mag		  W = W/mag		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function Operator_Multiply(q As OxMQuaternion) As OxMQuaternion		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' quat = quat1 * quat2		  		  Return New OxMQuaternion( _		  ( (W*q.X) + (X*q.W) + (Y*q.Z) - (Z*q.Y) ), _		  ( (W*q.Y) + (Y*q.W) + (Z*q.X) - (X*q.Z) ), _		  ( (W*q.Z) + (Z*q.W) + (X*q.Y) - (Y*q.X) ), _		  ( (W*q.W) - (X*q.X) - (Y*q.Y) - (Z*q.Z) ) )		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub SetBetween(q1 As OxMQuaternion, q2 As OxMQuaternion, pos As Double)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Sets values to a spherical interpolation (slerp) between q1 and q2 at 'pos'		  ' pos = 0.0 (q1) to 1.0 (q2)		  		  Dim cosom, omega, sinom, scale0, scale1 As Double		  Dim flip As Boolean		  		  cosom = ((q1.X*q2.X)+(q1.Y*q2.Y)+(q1.Z*q2.Z)+(q1.W*q2.W))' inline q1.DotProduct(q2)		  		  ' Adjust signs if necessary		  if cosom < 0.0 then		    cosom = -cosom		    flip = true		  end if		  		  ' Use linear for small movements		  if cosom < OxMath.kOneMinusEpsilon then		    		    ' Spherical		    omega = ACos(cosom)		    sinom = Sin(omega)		    scale0 = Sin((1.0-pos)*omega)/sinom		    if flip then		      scale1 = -(Sin(pos*omega)/sinom)		    else		      scale1 = Sin(pos*omega)/sinom		    end if		    		  else		    		    ' Linear		    scale0 = 1.0 - pos		    if flip then		      scale1 = -pos		    else		      scale1 = pos		    end if		    		  end if		  		  X = (scale0*q1.X) + (scale1*q2.X)		  Y = (scale0*q1.Y) + (scale1*q2.Y)		  Z = (scale0*q1.Z) + (scale1*q2.Z)		  W = (scale0*q1.W) + (scale1*q2.W)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetBetweenFast(q1 As OxMQuaternion, q2 As OxMQuaternion, pos As Double)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Sets values to a linear interpolation between q1 and q2 at 'pos'		  ' pos = 0.0 (q1) to 1.0 (q2)		  		  Dim scale0, scale1 As Double		  		  scale0 = 1.0 - pos		  		  if ((q1.X*q2.X)+(q1.Y*q2.Y)+(q1.Z*q2.Z)+(q1.W*q2.W)) < 0.0 then' inline q1.DotProduct(q2)		    scale1 = -pos		  else		    scale1 = pos		  end if		  		  X = (scale0*q1.X) + (scale1*q2.X)		  Y = (scale0*q1.Y) + (scale1*q2.Y)		  Z = (scale0*q1.Z) + (scale1*q2.Z)		  W = (scale0*q1.W) + (scale1*q2.W)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetRotate(rx As Double, ry As Double, rz As Double)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Set orientation to that described by a set of Euler angles		  ' This may seem handy, but it's also pretty nasty, so don't use it!		  		  ' Normally rx = pitch, ry = yaw, rz = roll, but we refrain		  ' from using those names since Z up orientation is sometimes prefered...		  		  Dim hrx As Double = rx/2.0		  Dim hry As Double = ry/2.0		  Dim hrz As Double = rz/2.0		  		  Dim cx As Double = Cos(hrx)		  Dim cy As Double = Cos(hry)		  Dim cz As Double = Cos(hrz)		  Dim sx As Double = Sin(hrx)		  Dim sy As Double = Sin(hry)		  Dim sz As Double = Sin(hrz)		  		  Dim cc As Double = cx * cz		  Dim cs As Double = cx * sz		  Dim sc As Double = sx * cz		  Dim ss As Double = sx * sz		  		  X = cy * sc - sy * cs		  Y = cy * ss + sy * cc		  Z = cy * cs - sy * sc		  W = cy * cc + sy * ss		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetRotate(aX As Double, aY As Double, aZ As Double, angle As Double)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Set orientation to that described by an arbitrary axis and angle		  		  Dim halfang, sinang As Double		  		  halfang = angle/2		  sinang = Sin(halfang)		  		  X = aX * sinang		  Y = aY * sinang		  Z = aZ * sinang		  W = Cos(halfang)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetRotate(axisang As OxMAxisAngle)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Set orientation to that described by an arbitrary axis and angle		  ' axisang's vector component should be a unit vector for proper results		  		  Dim halfang, sinang As Double		  		  halfang = axisang.Angle/2		  sinang = Sin(halfang)		  		  X = axisang.X * sinang		  Y = axisang.Y * sinang		  Z = axisang.Z * sinang		  W = Cos(halfang)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetRotate(axis As OxMVector3, angle As Double)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Set orientation to that described by an arbitrary axis and angle		  ' 'axis' should be a unit vector for proper results		  		  Dim halfang, sinang As Double		  		  halfang = angle/2		  sinang = Sin(halfang)		  		  X = axis.X * sinang		  Y = axis.Y * sinang		  Z = axis.Z * sinang		  W = Cos(halfang)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetRotateX(angle As Double)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Set orientation around the X axis		  		  Dim halfang As Double		  		  halfang = angle/2		  		  X = Sin(halfang)		  Y = 0.0		  Z = 0.0		  W = Cos(halfang)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetRotateY(angle As Double)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Set orientation around the Y axis		  		  Dim halfang As Double		  		  halfang = angle/2		  		  X = 0.0		  Y = Sin(halfang)		  Z = 0.0		  W = Cos(halfang)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetRotateZ(angle As Double)		  		  #if NOT DebugBuild		    #pragma BackgroundTasks False		    #pragma BoundsChecking False		    #pragma NilObjectChecking False		    #pragma StackOverflowChecking False		  #endif		  		  ' Set orientation around the Z axis		  		  Dim halfang As Double		  		  halfang = angle/2		  		  X = 0.0		  Y = 0.0		  Z = Sin(halfang)		  W = Cos(halfang)		  		End Sub	#tag EndMethod	#tag Property, Flags = &h0		W As Double	#tag EndProperty	#tag Property, Flags = &h0		X As Double	#tag EndProperty	#tag Property, Flags = &h0		Y As Double	#tag EndProperty	#tag Property, Flags = &h0		Z As Double	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="2147483648"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="W"			Group="Behavior"			InitialValue="0"			Type="Double"		#tag EndViewProperty		#tag ViewProperty			Name="X"			Group="Behavior"			InitialValue="0"			Type="Double"		#tag EndViewProperty		#tag ViewProperty			Name="Y"			Group="Behavior"			InitialValue="0"			Type="Double"		#tag EndViewProperty		#tag ViewProperty			Name="Z"			Group="Behavior"			InitialValue="0"			Type="Double"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass