#tag ClassClass DataPoint	#tag Method, Flags = &h0		Function a3(index as integer = - 1) As double		  return getDataValue(index, "a3")		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub a3(index as integer = - 1, assigns value as double)		  setDataValue(index, "a3", value)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function ax(index as integer = - 1) As double		  return getDataValue(index, "ax")		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub ax(index as integer = - 1, assigns value as double)		  setDataValue(index, "ax", value)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function ay(index as integer = - 1) As double		  return getDataValue(index, "ay")		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub ay(index as integer = - 1, assigns value as double)		  setDataValue(index, "ay", value)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function az(index as integer = - 1) As double		  return getDataValue(index, "az")		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub az(index as integer = - 1, assigns value as double)		  setDataValue(index, "az", value)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(dataSource as string, numberOfChannels as integer = 1)		  // takes a string (either "MoVE" or "iView") to specify the source of the data for the point, and the number of channels of data per point		  // i.e. = 1 for monocular eye data, 2 for binocular		  // currently always = 1 for arm data, but having this setting allows for future generalisation to more than one sensor per sample.		  		  self.sourceOfData = dataSource		  		  numberOfChannels = numberOfChannels -1		  		  if numberOfChannels >= 0 then  // just to check it won't be out of bounds		    		    redim mX(numberOfChannels, 1)  // the second dimension is to allow storage of original, unfiltered data		    redim mY(numberOfChannels, 1)		    redim mvX(numberOfChannels)		    redim mvY(numberOfChannels)		    redim mv(numberOfChannels)		    		    if dataSource = "MoVE" then		      redim mZ(numberOfChannels, 1)		      redim mvZ(numberOfChannels)		      redim maX(numberOfChannels)		      redim maY(numberOfChannels)		      redim maZ(numberOfChannels)		      redim ma3(numberOfChannels)		      		    end if		    		  else		    'gLog "Invalid number of channels in dataPoint constructor."		    		  end if		  		  		exception err		  gHandleException err, "Constructor method of DataPoint class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function getDataValue(index as integer = - 1, label as string) As double		  // called by any of the x, y, z, vx, vy, vz, etc methods		  		  		  // returns the x coordinate of the data point		  // if the passed index value is -1 (the default), then return which ever x value is best for this point.		  // e.g. for eye data, return left eye position if it is a left point, or right if right, or left if binocular		  // Binocular have both available		  // if 0, then return left eye specifically (or -9999 if not available)		  // if 1, return right eye specifically (or -9999 if not available)		  // for arm data, for the time being just return the only value there is.  In the future, will need to be more detailed if we implement multiple sensors.		  		  		  select case mSourceOfData		    		  case 0 // "iView"		    		    select case index  // which eye the calling method wants		      		    case -1, 0 // choose what is best to return (-1), or return left data		      		      select case label		        		      case "t"		        return mT		        		      case "x", "leftx"		        return mX(0,0)  // i.e. left data for a left-only point or a binocular point, right data for a right-only point.		        		      case "y", "lefty"		        return mY(0,0)		        		      case "valid"		        if mValid then return 1 else return 0		        		      case "vx", "leftvx"		        return mvX(0)		        		      case "vy", "leftvy"		        return mvY(0)		        		      case "v", "leftv"		        return mv(0)		        		      case "rightx"		        return mX(1,0)  // i.e. right data from a binocular point		        		      case "righty"		        return mY(1,0)		        		      case "rightvx"		        return mvX(1)		        		      case "rightvy"		        return mvY(1)		        		      case "rightv"		        return mv(1)		        		      case else		        return -9999.0		        		      end select		      		    case 1 // right		      select case label		        		      case "t"		        return mT		        		      case "x", "rightx"		        return mX(1,0)  // i.e. right data from a binocular point		        		      case "y", "righty"		        return mY(1,0)		        		      case "v", "rightv"		        return mv(1)		        		      case "valid"		        if mValid then return 1 else return 0		        		      case "vx", "rightvx"		        return mvX(1)		        		      case "vy", "rightvy"		        return mvY(1)		        		      case else		        return -9999.0		        		      end select		      		    end select		    		    		  case 1 // "MoVE"		    		    select case label		      		    case "t"		      return mT		      		    case "x"		      return mX(0,0)  // i.e. left data for a left-only point or a binocular point, right data for a right-only point.		      		    case "y"		      return mY(0,0)		      		    case "z"		      return mZ(0,0)		      		    case "valid"		      if mValid then return 1 else return 0		      		    case "vx"		      return mvX(0)		      		    case "vy"		      return mvY(0)		      		    case "vz"		      return mvZ(0)		      		    case "v"		      return mv(0)		      		    case "ax"		      return maX(0)		      		    case "ay"		      return maY(0)		      		    case "az"		      return maZ(0)		      		    case "a3"		      return ma3(0)		      		    case else		      return -9999.0		      		    end select		    		  end select		  		  		  		  		exception err		  gHandleException err, "getDataValue method of DataPoint class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function originalDataHasBeenStored() As boolean		  return mOriginalDataHasBeenStored		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub resetToOriginalData()		  // removes any filtering or calibration that may have been applied		  		  mX(0,0) = mX(0,1)		  mY(0,0) = mY(0,1)		  		  		  if mSourceOfData = 1 then		    mZ(0,0) = mZ(0,1)		  end if		  		  		  		exception err		  gHandleException err, "resetToOriginalData method of DataPoint class."		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub setDataValue(index as integer, label as string, value as double)		  // called by any of the x, y, z, vx, vy, vz, etc "assigns" methods		  		  		  select case mSourceOfData		    		  case 0 // "iView"		    		    select case index  // which eye the calling method is referring to		      		    case -1, 0 // choose what is appropriate (-1), or the left data of a binocular point		      		      select case label		        		      case "x"		        mX(0,0) = value		        		      case "y"		        mY(0,0) = value		        		      case "vx"		        mvX(0) = value		        		      case "vy"		        mvY(0) = value		        		      case "v"		        mv(0) = value		        		      end select		      		    case 1 // right		      		      select case label		        		      case "x"		        mX(1,0) = value		        		      case "y"		        mY(1,0) = value		        		      case "vx"		        mvX(1) = value		        		      case "vy"		        mvY(1) = value		        		      case "v"		        mv(1) = value		        		      end select		      		    end select		    		    		  case 1 // "MoVE"		    		    select case label		      		    case "x"		      mX(0,0) = value		      		    case "y"		      mY(0,0) = value		      		    case "z"		      mZ(0,0) = value		      		    case "vx"		      mvX(0) = value		      		    case "vy"		      mvY(0) = value		      		    case "vz"		      mvZ(0) = value		      		    case "v"		      mv(0) = value		      		    case "ax"		      maX(0) = value		      		    case "ay"		      maY(0) = value		      		    case "az"		      maZ(0) = value		      		    case "a3"		      ma3(0) = value		      		    end select		    		  end select		  		  		  		  		exception err		  gHandleException err, "setDataValue method of DataPoint class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub storeOriginalData()		  // so any filtering or calibration can be undone		  		  if not mOriginalDataHasBeenStored then		    		    mX(0,1) = mX(0,0)		    mY(0,1) = mY(0,0)		    		    		    if mSourceOfData = 1 then		      mZ(0,1) = mZ(0,0)		    end if		    		    mOriginalDataHasBeenStored = true		    		  end if		  		  		  		exception err		  gHandleException err, "storeOriginalData method of DataPoint class."		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function v(index as integer = - 1) As double		  return getDataValue(index, "v")		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub v(index as integer = - 1, assigns value as double)		  setDataValue(index, "v", value)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function vector() As OxMVector3		  // returns a OxMVector3 representing the location of the data point.		  // for 2D stimuli, the z coordinate is returned as zero.		  // Allows easy calculation of distances and angles between		  // stimuli or between a stimulus and a given datapoint (i.e. an error).		  		  dim vec as  new OxMVector3(self.x, self.y, 0)		  		  if mSourceOfData = 1 then vec.Z = self.z  // currently only MoVE data		  		  return vec		  		exception err		  gHandleException err, "vector method of the dataPoint class."		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function vx(index as integer = - 1) As double		  return getDataValue(index, "vx")		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub vx(index as integer = - 1, assigns value as double)		  setDataValue(index, "vx", value)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function vy(index as integer = - 1) As double		  return getDataValue(index, "vy")		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub vy(index as integer = - 1, assigns value as double)		  setDataValue(index, "vy", value)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function vz(index as integer = - 1) As double		  return getDataValue(index, "vz")		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub vz(index as integer = - 1, assigns value as double)		  setDataValue(index, "vz", value)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function x(index as integer = - 1) As double		  // when index = -1, the datapoint itself decides what data to return (e.g. left or right eye).		  // when equals 0, the caller is asking specifically for the left eye		  // when equals 1, the caller is asking specifically for the right eye		  // For arm data, always return just one sensor value for the time being.  But in the future, we may have		  // x values from more than one sensor, just as we can have eye data from more than one eye.		  		  		  return getDataValue(index, "x")		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub x(index as integer = - 1, assigns value as double)		  setDataValue(index, "x", value)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function y(index as integer = - 1) As double		  return getDataValue(index, "y")		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub y(index as integer = - 1, assigns value as double)		  setDataValue(index, "y", value)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function z(index as integer = - 1) As double		  // returns the z coordinate of the data point		  		  if mSourceOfData = 1  then // only return for arm data		    return getDataValue(index, "z")		  else		    return -9999		  end if		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub z(index as integer = - 1, assigns value as double)		  setDataValue(index, "z", value)		End Sub	#tag EndMethod	#tag Note, Name = About		Contains methods so that for convenience a OxMVector3 can be returned, specifiying the location		of the data point in space.  The OxMVector3 class provides methods for vectorial calculations.				x: horizontal position.		y: y position		z (arm only): z position		vx: x velocity 		vy: y velocity		vz (arm only): z velocity		m (currently arm only but could be generalised to eyes too): absolute magnitude distance from origin.		vm: velocity of m	#tag EndNote	#tag Property, Flags = &h1		#tag Note			the vector acceleration for arm data, combining the x, y, and z components		#tag EndNote		Protected ma3(-1) As double	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Contains an array of x acceleration values.  only 1 entry for left or right eye data, or two for binocular eye data.			Currently only one entry for MoVE data, but could be expanded to allow for multiple sensors.		#tag EndNote		Protected maX(-1) As double	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Contains an array of Y acceleration values.  only 1 entry for left or right eye data, or two for binocular eye data.			Currently only one entry for MoVE data, but could be expanded to allow for multiple sensors.		#tag EndNote		Protected maY(-1) As double	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Contains an array of Z acceleration values.  only 1 entry for left or right eye data, or two for binocular eye data.			Currently only one entry for MoVE data, but could be expanded to allow for multiple sensors.		#tag EndNote		Protected maZ(-1) As double	#tag EndProperty	#tag Property, Flags = &h0		mN As Integer	#tag EndProperty	#tag Property, Flags = &h1		Protected mOriginalDataHasBeenStored As boolean = false	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			0 = iView			1 = MoVE			returned by computed property		#tag EndNote		Protected mSourceOfData As Integer = -1	#tag EndProperty	#tag Property, Flags = &h1		Protected mT As double	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			the vector velocity for arm data, combining the x, y, and z components		#tag EndNote		Protected mv(-1) As double	#tag EndProperty	#tag Property, Flags = &h1		Protected mValid As boolean = true	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Contains an array of x velocity values.  only 1 entry for left or right eye data, or two for binocular eye data.			Currently only one entry for MoVE data, but could be expanded to allow for multiple sensors.		#tag EndNote		Protected mvX(-1) As double	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Contains an array of y velocity values.  only 1 entry for left or right eye data, or two for binocular eye data.			Currently only one entry for MoVE data, but could be expanded to allow for multiple sensors.		#tag EndNote		Protected mvY(-1) As double	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Ubound = -1 for eye data.  The array is redimmed to uBound = 0 if the sourceOfData is set to MoVE.			Could be used for pupil diameter for eye data if needed.		#tag EndNote		Protected mvZ(-1) As double	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			0 = left			1 = right			2 = binocular			returned by computed property		#tag EndNote		Protected mWhatEyeDataHeld As Integer = -1	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Contains an array of x values.  only 1 entry for left or right eye data, or two for binocular eye data.			The second dimension is to allow storage of raw imported values, before any filtering or recalibration is applied.			Currently only one entry for MoVE data, but could be expanded to allow for multiple sensors.		#tag EndNote		Protected mX(-1,-1) As double	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Contains an array of y values.  only 1 entry for left or right eye data, or two for binocular eye data.			Currently only one entry for MoVE data, but could be expanded to allow for multiple sensors.		#tag EndNote		Protected mY(-1,-1) As double	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			Ubound = -1 for eye data.  The array is redimmed to uBound = 0 if the sourceOfData is set to MoVE.			Could be used for pupil diameter for eye data if needed.		#tag EndNote		Protected mZ(-1,-1) As double	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mN			End Get		#tag EndGetter		#tag Setter			Set			  mN = value			End Set		#tag EndSetter		n As integer	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  select case mSourceOfData			    			  case 0			    return "iView"			    			  case 1			    return "MoVE"			    			  case else			    return "Unspecified"			    			  end select			  			End Get		#tag EndGetter		#tag Setter			Set			  select case value			    			  case "iView"			    mSourceOfData = 0			    			  case "MoVE"			    mSourceOfData = 1			    			  case else			    mSourceOfData = -1			    'gLog "Attempt to set dataPoint sourceOfData to invalid value."			    			  end select			  			End Set		#tag EndSetter		sourceOfData As string	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mT			End Get		#tag EndGetter		#tag Setter			Set			  mT = value			End Set		#tag EndSetter		t As double	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  return mValid			End Get		#tag EndGetter		#tag Setter			Set			  mValid = value			End Set		#tag EndSetter		valid As boolean	#tag EndComputedProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  select case mWhatEyeDataHeld			    			  case 0			    return "left"			    			  case 1			    return "right"			    			  case 2			    return "binocular"			    			  case else			    return "Unspecified/unapplicable"			    			  end select			  			End Get		#tag EndGetter		#tag Setter			Set			  select case value			    			  case "left"			    mWhatEyeDataHeld = 0			    			  case "right"			    mWhatEyeDataHeld = 1			    			  case "binocular"			    mWhatEyeDataHeld = 2			    redim mX(1,1)			    redim mY(1,1)			    redim mvX(1)			    redim mvY(1)			    			    			  case else			    mSourceOfData = -1			    'gLog "Attempt to set dataPoint sourceOfData to invalid value."			    			  end select			  			End Set		#tag EndSetter		whatEyeDataHeld As string	#tag EndComputedProperty	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="2147483648"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="mN"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="n"			Group="Behavior"			InitialValue="0"			Type="integer"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="sourceOfData"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="t"			Group="Behavior"			InitialValue="0"			Type="double"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="valid"			Group="Behavior"			InitialValue="0"			Type="boolean"		#tag EndViewProperty		#tag ViewProperty			Name="whatEyeDataHeld"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass